{"file_contents":{"source-2/lib/utils/mediaConverter.js":{"content":"const path = require('path');\nconst fs = require('fs');\nconst ff = require('fluent-ffmpeg');\nconst webp = require('node-webpmux');\nconst FileType = require('file-type');\nconst Crypto = require('crypto');\nconst { tmpdir } = require('os');\nconst { globalPackname, globalAuthor } = require('../../config.js');\n\nasync function gifToWebp(media) {\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.gif`);\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`);\n    fs.writeFileSync(tmpFileIn, media);\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on('error', reject)\n            .on('end', () => resolve(true))\n            .addOutputOptions([\n                '-vf', 'scale=512:512:force_original_aspect_ratio=decrease',\n                '-loop', '0',\n                '-preset', 'default',\n                '-an', '-vsync', '0'\n            ])\n            .toFormat('webp')\n            .save(tmpFileOut)\n    });\n    const buff = fs.readFileSync(tmpFileOut);\n    fs.unlinkSync(tmpFileOut);\n    fs.unlinkSync(tmpFileIn);\n    return buff;\n}\n\nasync function imageToWebp(media) {\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`);\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.jpg`);\n    fs.writeFileSync(tmpFileIn, media);\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on('error', reject)\n            .on('end', () => resolve(true))\n            .addOutputOptions([\n                '-vcodec', 'libwebp', '-vf',\n                'scale=500:500:force_original_aspect_ratio=decrease,setsar=1, pad=500:500:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse',\n                '-loop', '0', '-preset', 'default'\n            ])\n            .toFormat('webp')\n            .save(tmpFileOut)\n    });\n    const buff = fs.readFileSync(tmpFileOut);\n    fs.unlinkSync(tmpFileOut);\n    fs.unlinkSync(tmpFileIn);\n    return buff;\n}\n\nasync function videoToWebp(media) {\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`);\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.mp4`);\n    fs.writeFileSync(tmpFileIn, media);\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on('error', reject)\n            .on('end', () => resolve(true))\n            .addOutputOptions([\n                '-vcodec', 'libwebp',\n                '-vf', \"scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse\",\n                '-loop', '0',\n                '-ss', '00:00:00',\n                '-t', '00:00:05',\n                '-preset', 'default',\n                '-an', '-vsync', '0'\n            ])\n            .toFormat('webp')\n            .save(tmpFileOut)\n    });\n    const buff = fs.readFileSync(tmpFileOut);\n    fs.unlinkSync(tmpFileOut);\n    fs.unlinkSync(tmpFileIn);\n    return buff;\n}\n\nasync function writeExif(media, data) {\n    const anu = await FileType.fromBuffer(media);\n    const wMedia = /webp/.test(anu.mime) ? media : /image\\/gif/.test(anu.mime) ? await gifToWebp(media) : /jpeg|jpg|png/.test(anu.mime) ? await imageToWebp(media) : /video/.test(anu.mime) ? await videoToWebp(media) : '';\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`);\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`);\n    fs.writeFileSync(tmpFileIn, wMedia);\n    if (data) {\n        const img = new webp.Image();\n        const { wra = data.pack_id ? data.pack_id : globalAuthor ? globalAuthor : 'naze-dev', \n               wrb = data.packname ? data.packname : globalPackname ? globalPackname : 'Bot WhatsApp', \n               wrc = data.author ? data.author : globalAuthor ? globalAuthor : 'Nazedev', \n               wrd = data.categories ? data.categories : [''], \n               wre = data.isAvatar ? data.isAvatar : 0, ...wrf } = data;\n        const json = { \n            'sticker-pack-id': wra, \n            'sticker-pack-name': wrb, \n            'sticker-pack-publisher': wrc, \n            'emojis': wrd, \n            'is-avatar-sticker': wre, \n            ...wrf \n        };\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);\n        const jsonBuff = Buffer.from(JSON.stringify(json), 'utf-8');\n        const exif = Buffer.concat([exifAttr, jsonBuff]);\n        exif.writeUIntLE(jsonBuff.length, 14, 4);\n        await img.load(tmpFileIn);\n        fs.unlinkSync(tmpFileIn);\n        img.exif = exif;\n        await img.save(tmpFileOut);\n        return tmpFileOut;\n    }\n}\n\nmodule.exports = {\n    gifToWebp,\n    imageToWebp,\n    videoToWebp,\n    writeExif\n};","path":null,"size_bytes":5162,"size_tokens":null},"source-2/config.js":{"content":"module.exports = {\n    authFolder: './auth',\n    timezone: 'Asia/Jakarta',\n    globalPackname: 'MyBot Stickers',\n    globalAuthor: 'MyBot',\n    tiktokRegex: /(?<!\\S)https?:\\/\\/(?:www\\.|vm\\.|vt\\.)?tiktok\\.com\\/[^\\s]+/gi,\n    douyinRegex: /(?<!\\S)https?:\\/\\/(?:www\\.)?douyin\\.com\\/[^\\s]+|https?:\\/\\/v\\.douyin\\.com\\/[^\\s]+/gi,\n    browser: ['Ubuntu', 'Chrome', '20.0.04'],\n    prefixes: ['!', '.', '/', ''], \n     botInfo: {\n        name: \"Kirara\",\n        owner: [\"628xxxxx@s.whatsapp.net\"],\n        public: true,\n        version: \"1.0.0\"\n    },\n    monitorInterval: 60000,\n    commands: {\n        sticker: ['sticker', 's', 'stiker', 'stik'],\n        tiktok: ['tiktok', 'tt', 'tik'],\n        douyin: ['douyin', 'dy'],\n        ping: ['ping', 'speed'],\n        info: ['info', 'botinfo', 'status']\n    }\n};\n","path":null,"size_bytes":802,"size_tokens":null},"source-1/lib/function.js":{"content":"const fs = require('fs');\nconst util = require('util');\nconst Jimp = require('jimp');\nconst axios = require('axios');\nconst https = require('https');\nconst chalk = require('chalk');\nconst crypto = require('crypto');\nconst fetch = require('node-fetch');\nconst FileType = require('file-type');\nconst moment = require('moment-timezone');\nconst { defaultMaxListeners } = require('stream');\nconst { sizeFormatter } = require('human-readable');\nconst { exec, spawn, execSync } = require('child_process');\nconst { proto, areJidsSameUser, extractMessageContent, downloadContentFromMessage, getContentType, getDevice } = require('baileys');\nconst pool = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'.split('');\n\nconst unsafeAgent = new https.Agent({\n\trejectUnauthorized: false\n});\n\nconst unixTimestampSeconds = (date = new Date()) => Math.floor(date.getTime() / 1000)\n\nconst generateMessageTag = (epoch) => {\n    let tag = (0, unixTimestampSeconds)().toString();\n    if (epoch)\n        tag += '.--' + epoch;\n    return tag;\n}\n\nconst processTime = (timestamp, now) => {\n\treturn moment.duration(now - moment(timestamp * 1000)).asSeconds()\n}\n\nconst webApi = (a, b, c, d, e, f) => {\n\tconst hasil = a + b + c + d + e + f;\n\treturn hasil;\n}\n\nconst getRandom = (ext) => {\n    return `${Math.floor(Math.random() * 10000)}${ext}`\n}\n\nconst getBuffer = async (url, options = {}) => {\n\ttry {\n\t\tconst { data } = await axios.get(url, {\n\t\t\theaders: {\n\t\t\t\t'DNT': 1,\n\t\t\t\t'Upgrade-Insecure-Request': 1\n\t\t\t},\n\t\t\tresponseType: 'arraybuffer',\n\t\t\thttpsAgent: unsafeAgent,\n\t\t\t...options\n\t\t})\n\t\treturn data\n\t} catch (e) {\n\t\ttry {\n\t\t\tconst res = await fetch(url, { agent: unsafeAgent });\n\t\t\tconst anu = await res.buffer()\n\t\t\treturn anu\n\t\t} catch (e) {\n\t\t\treturn e\n\t\t}\n\t}\n}\n\nconst fetchJson = async (url, options = {}) => {\n\ttry {\n\t\tconst { data } = await axios.get(url, {\n\t\t\theaders: {\n\t\t\t\t'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'\n\t\t\t},\n\t\t\thttpsAgent: unsafeAgent,\n\t\t\t...options\n\t\t})\n\t\treturn data\n\t} catch (e) {\n\t\ttry {\n\t\t\tconst res = await fetch(url, { agent: unsafeAgent });\n\t\t\tconst anu = await res.json()\n\t\t\treturn anu\n\t\t} catch (e) {\n\t\t\treturn e\n\t\t}\n\t}\n}\n\nconst runtime = function(seconds) {\n\tseconds = Number(seconds);\n\tvar d = Math.floor(seconds / (3600 * 24));\n\tvar h = Math.floor(seconds % (3600 * 24) / 3600);\n\tvar m = Math.floor(seconds % 3600 / 60);\n\tvar s = Math.floor(seconds % 60);\n\tvar dDisplay = d > 0 ? d + (d == 1 ? \" day, \" : \" days, \") : \"\";\n\tvar hDisplay = h > 0 ? h + (h == 1 ? \" hour, \" : \" hours, \") : \"\";\n\tvar mDisplay = m > 0 ? m + (m == 1 ? \" minute, \" : \" minutes, \") : \"\";\n\tvar sDisplay = s > 0 ? s + (s == 1 ? \" second\" : \" seconds\") : \"\";\n\treturn dDisplay + hDisplay + mDisplay + sDisplay;\n}\n\nconst clockString = (ms) => {\n    let h = isNaN(ms) ? '--' : Math.floor(ms / 3600000)\n    let m = isNaN(ms) ? '--' : Math.floor(ms / 60000) % 60\n    let s = isNaN(ms) ? '--' : Math.floor(ms / 1000) % 60\n    return [h, m, s].map(v => v.toString().padStart(2, 0)).join(':')\n}\n\nconst sleep = async (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nconst isUrl = (url) => {\n    return url.match(new RegExp(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)/, 'gi'))\n}\n\nconst getTime = (format, date) => {\n\tif (date) {\n\t\treturn moment(date).locale('id').format(format)\n\t} else {\n\t\treturn moment.tz('Asia/Jakarta').locale('id').format(format)\n\t}\n}\n\nconst formatDate = (n, locale = 'id') => {\n\tlet d = new Date(n)\n\treturn d.toLocaleDateString(locale, {\n\t\tweekday: 'long',\n\t\tday: 'numeric',\n\t\tmonth: 'long',\n\t\tyear: 'numeric',\n\t\thour: 'numeric',\n\t\tminute: 'numeric',\n\t\tsecond: 'numeric'\n\t})\n}\n\nconst tanggal = (numer) => {\n\tmyMonths = [\"Januari\",\"Februari\",\"Maret\",\"April\",\"Mei\",\"Juni\",\"Juli\",\"Agustus\",\"September\",\"Oktober\",\"November\",\"Desember\"];\n\tmyDays = ['Minggu','Senin','Selasa','Rabu','Kamis','Jum‚Äôat','Sabtu']; \n\tvar tgl = new Date(numer);\n\tvar day = tgl.getDate()\n\tbulan = tgl.getMonth()\n\tvar thisDay = tgl.getDay(),\n\tthisDay = myDays[thisDay];\n\tvar yy = tgl.getYear()\n\tvar year = (yy < 1000) ? yy + 1900 : yy; \n\tconst time = moment.tz('Asia/Jakarta').format('DD/MM HH:mm:ss')\n\tlet d = new Date\n\tlet locale = 'id'\n\tlet gmt = new Date(0).getTime() - new Date('1 January 1970').getTime()\n\tlet weton = ['Pahing', 'Pon','Wage','Kliwon','Legi'][Math.floor(((d * 1) + gmt) / 84600000) % 5]\n\treturn`${thisDay}, ${day} - ${myMonths[bulan]} - ${year}`\n}\n\nconst formatp = sizeFormatter({\n    std: 'JEDEC', //'SI' = default | 'IEC' | 'JEDEC'\n    decimalPlaces: 2,\n    keepTrailingZeroes: false,\n    render: (literal, symbol) => `${literal} ${symbol}B`,\n})\n\nconst jsonformat = (string) => {\n    return JSON.stringify(string, null, 2)\n}\n\nconst reSize = async (image, ukur1 = 100, ukur2 = 100) => {\n\treturn new Promise(async(resolve, reject) => {\n\t\ttry {\n\t\t\tconst read = await Jimp.read(image);\n\t\t\tconst result = await read.resize(ukur1, ukur2).getBufferAsync(Jimp.MIME_JPEG)\n\t\t\tresolve(result)\n\t\t} catch (e) {\n\t\t\treject(e)\n\t\t}\n\t})\n}\n\nconst toHD = async (image) => {\n\treturn new Promise(async(resolve, reject) => {\n\t\ttry {\n\t\t\tconst read = await Jimp.read(image);\n\t\t\tconst newWidth = read.bitmap.width * 4;\n\t\t\tconst newHeight = read.bitmap.height * 4;\n\t\t\tconst result = await read.resize(newWidth, newHeight).getBufferAsync(Jimp.MIME_JPEG)\n\t\t\tresolve(result)\n\t\t} catch (e) {\n\t\t\treject(e)\n\t\t}\n\t})\n}\n\nconst logic = (check, inp, out) => {\n\tif (inp.length !== out.length) throw new Error('Input and Output must have same length')\n\tfor (let i in inp)\n\t\tif (util.isDeepStrictEqual(check, inp[i])) return out[i]\n\treturn null\n}\n\nconst generateProfilePicture = async (buffer) => {\n\tconst jimp = await Jimp.read(buffer)\n\tconst min = jimp.getWidth()\n\tconst max = jimp.getHeight()\n\tconst cropped = jimp.crop(0, 0, min, max)\n\treturn {\n\t\timg: await cropped.scaleToFit(720, 720).getBufferAsync(Jimp.MIME_JPEG),\n\t\tpreview: await cropped.scaleToFit(720, 720).getBufferAsync(Jimp.MIME_JPEG)\n\t}\n}\n\nconst bytesToSize = (bytes, decimals = 2) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\nconst normalize = s => s.replace(/\\s+/g, '').split('').sort().join('');\n\nconst errorCache = {};\n\nconst getSizeMedia = async (path) => {\n    return new Promise((resolve, reject) => {\n        if (typeof path === 'string' && /http/.test(path)) {\n            axios.get(path).then((res) => {\n                let length = parseInt(res.headers['content-length'])\n                if(!isNaN(length)) resolve(bytesToSize(length, 3))\n            })\n        } else if (Buffer.isBuffer(path)) {\n            let length = Buffer.byteLength(path)\n            if(!isNaN(length)) resolve(bytesToSize(length, 3))\n        } else {\n            reject(0)\n        }\n    })\n}\n\nconst parseMention = (text = '') => {\n    return [...text.matchAll(/@([0-9]{5,16}|0)/g)].map(v => v[1] + '@s.whatsapp.net')\n}\n\nconst getGroupAdmins = (participants) => {\n        let admins = []\n        for (let i of participants) {\n            i.admin === \"superadmin\" ? admins.push(i.id) :  i.admin === \"admin\" ? admins.push(i.id) : ''\n        }\n        return admins || []\n}\n\nconst getHashedPassword = (password) => {\n    const sha256 = crypto.createHash('sha256');\n    const hash = sha256.update(password).digest('base64');\n    return hash;\n}\n\nconst generateAuthToken = (size) => {\n    return crypto.randomBytes(size).toString('hex').slice(0, size);\n}\n\nconst cekMenfes = (tag, nomer, db_menfes) => {\n\tlet x1 = false\n\tObject.keys(db_menfes).forEach((i) => {\n\t\tif (db_menfes[i].id == nomer){\n\t\t\tx1 = i\n\t\t}\n\t})\n\tif (x1 !== false) {\n\t\tif (tag == 'id'){\n\t\t\treturn db_menfes[x1].id\n\t\t}\n\t\tif (tag == 'teman'){\n\t\t\treturn db_menfes[x1].teman\n\t\t}\n\t}\n\tif (x1 == false) {\n\t\treturn null\n\t}\n}\n\nfunction assertInstalled(cmd, name, code) {\n\ttry {\n\t\texecSync(cmd, { stdio: 'ignore' });\n\t} catch (e) {\n\t\tconsole.error(chalk.redBright(`‚ùå  ${name} is not installed or not in PATH.`) +`\\nPlease install it first and run the script again.\\n`);\n\t\tprocess.exit(code);\n\t}\n}\n\nfunction format(...args) {\n\treturn util.format(...args)\n}\n\nfunction generateToken() {\n  let characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*';\n  let token = '';\n  for (let i = 0; i < 8; i++) {\n    let randomIndex = Math.floor(Math.random() * characters.length);\n    token += characters.charAt(randomIndex);\n  }\n  return token;\n}\n\nfunction batasiTeks(teks, batas) {\n  if (teks.length <= batas) {\n    return teks;\n  } else {\n    return teks.substring(0, batas) + '...';\n  }\n}\n\nfunction randomText(len) {\n    const result = [];\n    for (let i = 0; i < len; i++) result.push(pool[Math.floor(Math.random() * pool.length)]);\n    return result.join('');\n}\n\nfunction isEmoji(str) {\n  const emojiRegex = /[\\u{1F000}-\\u{1F6FF}\\u{1F900}-\\u{1F9FF}\\u{2600}-\\u{26FF}\\u{2700}-\\u{27BF}\\u{1F100}-\\u{1F1FF}]/u;\n  return emojiRegex.test(str);\n}\n\nfunction readFileTxt(file) {\n    return new Promise((resolve, reject) => {\n        const data = fs.readFileSync(file, 'utf8');\n        const array = data.toString().split('\\n') ;\n        const random = array[Math.floor(Math.random() * array.length)];\n        resolve(random.replace('\\r', ''));\n    })\n}\n\nfunction readFileJson(file) {\n    return new Promise((resolve, reject) => {\n        const jsonData = JSON.parse(fs.readFileSync(file));\n        const index = Math.floor(Math.random() * jsonData.length);\n        const random = jsonData[index];\n        resolve(random);\n    })\n}\n\nasync function getTypeUrlMedia(url) {\n\treturn new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tconst buffer = await axios.get(url, { responseType: 'arraybuffer' });\n\t\t\tconst type = buffer.headers['content-type'] || (await FileType.fromBuffer(buffer.data)).mime\n\t\t\tresolve({ type, url })\n\t\t} catch (e) {\n\t\t\treject(e)\n\t\t}\n\t})\n}\n\nfunction pickRandom(list) {\n\treturn list[Math.floor(list.length * Math.random())]\n}\n\nfunction convertTimestampToDate(timestamp) {\n\treturn timestamp ? new Date(timestamp * 1000).toISOString().replace(\"T\", \" \").split(\".\")[0] : 'N/A'\n}\n\nfunction isCommandAvailable(command) {\n    try {\n        execSync(`command -v ${command}`);\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function getAllHTML(urls) {\n  try {\n    const htmlArr = [];\n    for (const url of urls) {\n      const response = await axios.get(url);\n      htmlArr.push(response.data);\n    }\n    return htmlArr;\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction tarBackup(source, output) {\n\treturn new Promise((resolve, reject) => {\n\t\texec(`tar -czf ${output} --exclude=${output} --exclude='./node_modules' ${source}`, (err, stdout, stderr) => {\n\t\t\tif (err) return reject(err);\n\t\t\tresolve(output);\n\t\t})\n\t})\n}\n\nmodule.exports = { unixTimestampSeconds, generateMessageTag, processTime, webApi, getRandom, getBuffer, fetchJson, runtime, clockString, sleep, isUrl, getTime, formatDate, tanggal, formatp, jsonformat, reSize, toHD, logic, generateProfilePicture, assertInstalled, bytesToSize, errorCache, normalize, getSizeMedia, parseMention, getGroupAdmins, readFileTxt, readFileJson, isCommandAvailable, getHashedPassword, generateAuthToken, cekMenfes, generateToken, batasiTeks, randomText, isEmoji, getTypeUrlMedia, pickRandom, convertTimestampToDate, getAllHTML, tarBackup };\n\nlet file = require.resolve(__filename)\nfs.watchFile(file, () => {\n\tfs.unwatchFile(file)\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\n\tdelete require.cache[file]\n\trequire(file)\n})","path":null,"size_bytes":11754,"size_tokens":null},"ciel/src/handlers/commands/info.js":{"content":"const os = require('os');\nconst settings = require('../../../config/settings');\nconst { runtime, getGreeting, getTime, formatMoney } = require('../../utils/functions');\nconst { getHitStats, isPremium, listPremium, listSewa } = require('../../services/database');\nconst pkg = require('../../../package.json');\n\nconst menu = async (conn, m, ctx) => {\n    const { prefix, user, isOwner } = ctx;\n    const greeting = getGreeting();\n    const userType = isOwner ? 'Owner' : user.vip ? 'VIP' : await isPremium(m.sender) ? 'Premium' : 'Free';\n    \n    const menuText = `\n${greeting}, ${m.pushName}!\n\n‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[ *CIEL BOT* ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚îÇ üë§ User: ${m.pushName}\n‚îÇ üè∑Ô∏è Status: ${userType}\n‚îÇ üí∞ Money: ${formatMoney(user.money)}\n‚îÇ üìä Limit: ${user.limit}\n‚îÇ ‚è∞ Waktu: ${getTime('HH:mm:ss')}\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ï≠‚îÅ‚îÅ‚îÅ[ *INFO* ]‚îÅ‚îÅ‚îÅ\n‚îÇ .ping - Cek bot\n‚îÇ .speed - Tes kecepatan\n‚îÇ .runtime - Waktu aktif\n‚îÇ .owner - Info owner\n‚îÇ .info - Info bot\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ï≠‚îÅ‚îÅ‚îÅ[ *TOOLS* ]‚îÅ‚îÅ‚îÅ\n‚îÇ .sticker - Buat sticker\n‚îÇ .toimg - Sticker ke gambar\n‚îÇ .tomp3 - Video ke audio\n‚îÇ .translate - Terjemahkan\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ï≠‚îÅ‚îÅ‚îÅ[ *DOWNLOAD* ]‚îÅ‚îÅ‚îÅ\n‚îÇ .tiktok - Download TikTok\n‚îÇ .instagram - Download IG\n‚îÇ .youtube - Download YT\n‚îÇ .spotify - Download Spotify\n‚îÇ .pinterest - Cari gambar\n‚îÇ .douyin - Download Douyin\n‚îÇ .pixiv - Download Pixiv\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ï≠‚îÅ‚îÅ‚îÅ[ *GAME* ]‚îÅ‚îÅ‚îÅ\n‚îÇ .tictactoe - Main TTT\n‚îÇ .slot - Mesin slot\n‚îÇ .casino - Casino solo\n‚îÇ .samgong - Kartu samgong\n‚îÇ .begal - Game begal\n‚îÇ .merampok - Rampok user\n‚îÇ .daily - Claim harian\n‚îÇ .weekly - Claim mingguan\n‚îÇ .transfer - Kirim uang\n‚îÇ .buylimit - Beli limit\n‚îÇ .leaderboard - Top player\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ï≠‚îÅ‚îÅ‚îÅ[ *GROUP* ]‚îÅ‚îÅ‚îÅ\n‚îÇ .kick - Kick member\n‚îÇ .add - Tambah member\n‚îÇ .promote - Jadikan admin\n‚îÇ .demote - Hapus admin\n‚îÇ .welcome - Toggle welcome\n‚îÇ .antilink - Toggle antilink\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n‚ï≠‚îÅ‚îÅ‚îÅ[ *OWNER* ]‚îÅ‚îÅ‚îÅ\n‚îÇ .addprem - Tambah premium\n‚îÇ .delprem - Hapus premium\n‚îÇ .addsewa - Tambah sewa\n‚îÇ .ban - Ban user\n‚îÇ .broadcast - Broadcast\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n> *${settings.botInfo.name} v${pkg.version}*\n    `.trim();\n    \n    await m.reply(menuText);\n};\n\nconst ping = async (conn, m) => {\n    const start = Date.now();\n    await m.reply('Pinging...');\n    const end = Date.now();\n    await m.reply(`üèì *Pong!*\\n‚è±Ô∏è Response: ${end - start}ms`);\n};\n\nconst speed = async (conn, m) => {\n    const start = Date.now();\n    await m.reply('Testing speed...');\n    const end = Date.now();\n    \n    const usedMem = process.memoryUsage();\n    const speedText = `\n*‚ö° Speed Test*\n\nüì∂ Response: ${end - start}ms\nüíæ RAM Usage: ${(usedMem.heapUsed / 1024 / 1024).toFixed(2)} MB\nüì¶ Total RAM: ${(usedMem.heapTotal / 1024 / 1024).toFixed(2)} MB\n‚è∞ Uptime: ${runtime(process.uptime())}\n    `.trim();\n    \n    await m.reply(speedText);\n};\n\nconst runtimeCmd = async (conn, m) => {\n    await m.reply(`‚è∞ *Runtime*: ${runtime(process.uptime())}`);\n};\n\nconst owner = async (conn, m) => {\n    const ownerNumbers = settings.owner;\n    await conn.sendContact(m.chat, ownerNumbers, m.key);\n    await m.reply('Diatas adalah kontak owner bot.');\n};\n\nconst info = async (conn, m) => {\n    const stats = await getHitStats();\n    \n    const infoText = `\n*üìä Bot Information*\n\nü§ñ Nama: ${settings.botInfo.name}\nüìå Versi: ${pkg.version}\nüë®‚Äçüíª Author: ${settings.botInfo.author}\n\nüíª *System*\n‚îú Platform: ${os.platform()}\n‚îú Arch: ${os.arch()}\n‚îú Node: ${process.version}\n‚îú Memory: ${(os.freemem() / 1024 / 1024).toFixed(0)}MB / ${(os.totalmem() / 1024 / 1024).toFixed(0)}MB\n‚îî Uptime: ${runtime(process.uptime())}\n\nüìà *Stats*\n‚îú Total CMD: ${stats.total?.totalCmd || 0}\n‚îî Today CMD: ${stats.total?.todayCmd || 0}\n    `.trim();\n    \n    await m.reply(infoText);\n};\n\nconst profile = async (conn, m, ctx) => {\n    const { user, isOwner } = ctx;\n    const userType = isOwner ? 'Owner' : user.vip ? 'VIP' : await isPremium(m.sender) ? 'Premium' : 'Free';\n    \n    const profileText = `\n*üë§ Profile*\n\nüìõ Nama: ${m.pushName}\nüî¢ Nomor: ${m.sender.split('@')[0]}\nüè∑Ô∏è Status: ${userType}\nüí∞ Money: ${formatMoney(user.money)}\nüìä Limit: ${user.limit}\nüìÖ Terdaftar: ${user.createdAt ? getTime('DD/MM/YYYY', user.createdAt) : '-'}\n    `.trim();\n    \n    await m.reply(profileText);\n};\n\nconst listpremium = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const premiums = await listPremium();\n    \n    if (premiums.length === 0) {\n        return m.reply('Tidak ada user premium.');\n    }\n    \n    let text = '*üìã Daftar Premium*\\n\\n';\n    for (const prem of premiums) {\n        text += `‚Ä¢ ${prem.userJid.split('@')[0]}\\n`;\n        text += `  Expired: ${getTime('DD/MM/YYYY HH:mm', prem.expiredAt)}\\n\\n`;\n    }\n    \n    await m.reply(text.trim());\n};\n\nconst listsewa = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const sewas = await listSewa();\n    \n    if (sewas.length === 0) {\n        return m.reply('Tidak ada grup sewa.');\n    }\n    \n    let text = '*üìã Daftar Sewa*\\n\\n';\n    for (const sewa of sewas) {\n        text += `‚Ä¢ ${sewa.groupJid}\\n`;\n        text += `  Expired: ${getTime('DD/MM/YYYY HH:mm', sewa.expiredAt)}\\n\\n`;\n    }\n    \n    await m.reply(text.trim());\n};\n\nmodule.exports = {\n    menu,\n    help: menu,\n    ping,\n    speed,\n    runtime: runtimeCmd,\n    owner,\n    info,\n    botinfo: info,\n    profile,\n    me: profile,\n    listpremium,\n    listprem: listpremium,\n    listsewa\n};\n","path":null,"size_bytes":5864,"size_tokens":null},"source-1/lib/tictactoe.js":{"content":"class TicTacToe {\n    constructor(playerX = 'x', playerO = 'o') {\n        this.playerX = playerX\n        this.playerO = playerO\n        this._currentTurn = false\n        this._x = 0\n        this._o = 0\n        this.turns = 0\n    }\n\n    get board() {\n        return this._x | this._o\n    }\n\n    get currentTurn() {\n        return this._currentTurn ? this.playerO : this.playerX\n    }\n\n    get enemyTurn() {\n        return this._currentTurn ? this.playerX : this.playerO\n    }\n\n    static check(state) {\n        for (let combo of [7, 56, 73, 84, 146, 273, 292, 448])\n            if ((state & combo) === combo)\n                return !0\n        return !1\n    }\n\n    /**\n     * ```js\n     * TicTacToe.toBinary(1, 2) // 0b010000000\n     * ```\n     */\n    static toBinary(x = 0, y = 0) {\n        if (x < 0 || x > 2 || y < 0 || y > 2) throw new Error('invalid position')\n        return 1 << x + (3 * y)\n    }\n\n    /**\n     * @param player `0` is `X`, `1` is `O`\n     * \n     * - `-3` `Game Ended`\n     * - `-2` `Invalid`\n     * - `-1` `Invalid Position`\n     * - ` 0` `Position Occupied`\n     * - ` 1` `Sucess`\n     * @returns {-3|-2|-1|0|1}\n     */\n    turn(player = 0, x = 0, y) {\n        if (this.board === 511) return -3\n        let pos = 0\n        if (y == null) {\n            if (x < 0 || x > 8) return -1\n            pos = 1 << x\n        } else {\n            if (x < 0 || x > 2 || y < 0 || y > 2) return -1\n            pos = TicTacToe.toBinary(x, y)\n        }\n        if (this._currentTurn ^ player) return -2\n        if (this.board & pos) return 0\n        this[this._currentTurn ? '_o' : '_x'] |= pos\n        this._currentTurn = !this._currentTurn\n        this.turns++\n        return 1\n    }\n\n    /**\n     * @returns {('X'|'O'|1|2|3|4|5|6|7|8|9)[]}\n     */\n    static render(boardX = 0, boardO = 0) {\n        let x = parseInt(boardX.toString(2), 4)\n        let y = parseInt(boardO.toString(2), 4) * 2\n        return [...(x + y).toString(4).padStart(9, '0')].reverse().map((value, index) => value == 1 ? 'X' : value == 2 ? 'O' : ++index)\n    }\n    \n    /**\n     * @returns {('X'|'O'|1|2|3|4|5|6|7|8|9)[]}\n     */\n    render() {\n        return TicTacToe.render(this._x, this._o)\n    }\n\n    get winner() {\n        let x = TicTacToe.check(this._x)\n        let o = TicTacToe.check(this._o)\n        return x ? this.playerX : o ? this.playerO : false\n    }\n}\n\nnew TicTacToe().turn\n\nmodule.exports = TicTacToe","path":null,"size_bytes":2402,"size_tokens":null},"ciel/lib/pixiv.js":{"content":"const axios = require('axios');\n\nasync function pixivdl(query) {\n    const isUrl = /https:\\/\\/(www\\.)?pixiv\\.net\\/(en\\/)?artworks\\/[0-9]+/i.test(query);\n    \n    if (isUrl) {\n        const id = query.replace(/\\D/g, '');\n        \n        try {\n            const response = await axios.get(`https://api.lolhuman.xyz/api/pixiv/${id}`, {\n                headers: { 'User-Agent': 'Mozilla/5.0' },\n                timeout: 30000\n            });\n            \n            if (response.data?.status === 200 && response.data?.result) {\n                const data = response.data.result;\n                return {\n                    artist: data.user?.name || 'Unknown',\n                    caption: data.title || 'No title',\n                    tags: data.tags || [],\n                    media: data.image || []\n                };\n            }\n        } catch (e) {\n            console.error('Pixiv API error:', e.message);\n        }\n        \n        try {\n            const fallback = await axios.get(`https://api.agatz.xyz/api/pixiv?id=${id}`, {\n                timeout: 30000\n            });\n            \n            if (fallback.data?.data) {\n                const data = fallback.data.data;\n                return {\n                    artist: data.artist || 'Unknown',\n                    caption: data.title || 'No title',\n                    tags: data.tags || [],\n                    media: Array.isArray(data.images) ? data.images : [data.image]\n                };\n            }\n        } catch (e2) {\n            console.error('Pixiv fallback error:', e2.message);\n        }\n        \n        throw new Error(`ID \"${id}\" tidak ditemukan!`);\n        \n    } else {\n        try {\n            const searchResponse = await axios.get(`https://api.lolhuman.xyz/api/pixivsearch?query=${encodeURIComponent(query)}`, {\n                headers: { 'User-Agent': 'Mozilla/5.0' },\n                timeout: 30000\n            });\n            \n            if (searchResponse.data?.status === 200 && searchResponse.data?.result?.length) {\n                const results = searchResponse.data.result;\n                const random = results[Math.floor(Math.random() * results.length)];\n                \n                return {\n                    artist: random.user?.name || 'Unknown',\n                    caption: random.title || 'No title',\n                    tags: random.tags || [],\n                    media: random.image || []\n                };\n            }\n        } catch (e) {\n            console.error('Pixiv search error:', e.message);\n        }\n        \n        try {\n            const fallback = await axios.get(`https://api.agatz.xyz/api/pixivsearch?q=${encodeURIComponent(query)}`, {\n                timeout: 30000\n            });\n            \n            if (fallback.data?.data?.length) {\n                const results = fallback.data.data;\n                const random = results[Math.floor(Math.random() * results.length)];\n                \n                return {\n                    artist: random.artist || 'Unknown',\n                    caption: random.title || 'No title',\n                    tags: random.tags || [],\n                    media: Array.isArray(random.images) ? random.images : [random.image]\n                };\n            }\n        } catch (e2) {\n            console.error('Pixiv search fallback error:', e2.message);\n        }\n        \n        throw new Error(`Tag \"${query}\" tidak ditemukan!`);\n    }\n}\n\nmodule.exports = { pixivdl };\n","path":null,"size_bytes":3461,"size_tokens":null},"ciel/src/handlers/commands/owner.js":{"content":"const settings = require('../../../config/settings');\nconst { \n    addPremium, \n    removePremium, \n    updateUser, \n    updateBotSettings,\n    addSewa,\n    removeSewa,\n    getUser\n} = require('../../services/database');\nconst { isUrl } = require('../../utils/functions');\n\nconst addprem = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) {\n        return m.reply(`Penggunaan: ${ctx.prefix}addprem @user|hari\\nContoh: ${ctx.prefix}addprem @628xxx|30`);\n    }\n    \n    const [target, days] = text.split('|').map(x => x.trim());\n    if (!target || !days) {\n        return m.reply('Format: @user|hari');\n    }\n    \n    const userJid = target.replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    const daysNum = parseInt(days.replace(/[^0-9]/g, ''));\n    \n    if (isNaN(daysNum) || daysNum <= 0) {\n        return m.reply('Jumlah hari tidak valid!');\n    }\n    \n    const [onWa] = await conn.onWhatsApp(userJid);\n    if (!onWa?.exists) {\n        return m.reply('Nomor tidak terdaftar di WhatsApp!');\n    }\n    \n    const success = await addPremium(userJid, daysNum);\n    if (success) {\n        await m.reply(`Berhasil menambahkan premium untuk @${userJid.split('@')[0]} selama ${daysNum} hari!`, { mentions: [userJid] });\n    } else {\n        await m.reply('Gagal menambahkan premium!');\n    }\n};\n\nconst delprem = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) {\n        return m.reply(`Penggunaan: ${ctx.prefix}delprem @user`);\n    }\n    \n    const userJid = text.replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    \n    const success = await removePremium(userJid);\n    if (success) {\n        await m.reply(`Berhasil menghapus premium @${userJid.split('@')[0]}!`, { mentions: [userJid] });\n    } else {\n        await m.reply('User tidak memiliki premium atau gagal menghapus!');\n    }\n};\n\nconst ban = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    let userJid;\n    \n    if (m.quoted) {\n        userJid = m.quoted.sender;\n    } else if (text) {\n        userJid = text.replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    } else {\n        return m.reply(`Penggunaan: ${ctx.prefix}ban @user atau reply pesan`);\n    }\n    \n    await updateUser(userJid, { banned: true });\n    await m.reply(`@${userJid.split('@')[0]} telah di-ban!`, { mentions: [userJid] });\n};\n\nconst unban = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    let userJid;\n    \n    if (m.quoted) {\n        userJid = m.quoted.sender;\n    } else if (text) {\n        userJid = text.replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    } else {\n        return m.reply(`Penggunaan: ${ctx.prefix}unban @user atau reply pesan`);\n    }\n    \n    await updateUser(userJid, { banned: false });\n    await m.reply(`@${userJid.split('@')[0]} telah di-unban!`, { mentions: [userJid] });\n};\n\nconst addsewa = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) {\n        return m.reply(`Penggunaan: ${ctx.prefix}addsewa link|hari\\nContoh: ${ctx.prefix}addsewa https://chat.whatsapp.com/xxx|30`);\n    }\n    \n    const [link, days] = text.split('|').map(x => x.trim());\n    if (!link || !days) {\n        return m.reply('Format: link|hari');\n    }\n    \n    if (!isUrl(link) || !link.includes('chat.whatsapp.com/')) {\n        return m.reply('Link grup tidak valid!');\n    }\n    \n    const daysNum = parseInt(days.replace(/[^0-9]/g, '')) || 30;\n    const inviteCode = link.split('chat.whatsapp.com/')[1];\n    \n    try {\n        const groupInfo = await conn.groupGetInviteInfo(inviteCode);\n        await conn.groupAcceptInvite(inviteCode);\n        \n        await addSewa(groupInfo.id, inviteCode, daysNum);\n        await m.reply(`Berhasil menambahkan sewa grup *${groupInfo.subject}* selama ${daysNum} hari!`);\n    } catch (e) {\n        if (e.data === 400) return m.reply('Grup tidak ditemukan!');\n        if (e.data === 401) return m.reply('Bot diblokir dari grup!');\n        if (e.data === 410) return m.reply('Link grup telah diubah!');\n        if (e.data === 500) return m.reply('Grup penuh!');\n        return m.reply(`Gagal: ${e.message}`);\n    }\n};\n\nconst delsewa = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) {\n        return m.reply(`Penggunaan: ${ctx.prefix}delsewa groupJid`);\n    }\n    \n    const groupJid = text.includes('@g.us') ? text : text.split('chat.whatsapp.com/')[1];\n    \n    const success = await removeSewa(groupJid);\n    if (success) {\n        try {\n            await conn.groupLeave(groupJid);\n        } catch (e) {}\n        await m.reply('Berhasil menghapus sewa grup!');\n    } else {\n        await m.reply('Grup tidak ditemukan di database sewa!');\n    }\n};\n\nconst setname = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text, botSettings } = ctx;\n    if (!text) return m.reply('Masukkan nama bot baru!');\n    \n    const { jidNormalizedUser } = require('@whiskeysockets/baileys');\n    await updateBotSettings(jidNormalizedUser(conn.user.id), { botName: text });\n    await m.reply(`Nama bot diubah menjadi: ${text}`);\n};\n\nconst setauthor = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) return m.reply('Masukkan nama author baru!');\n    \n    const { jidNormalizedUser } = require('@whiskeysockets/baileys');\n    await updateBotSettings(jidNormalizedUser(conn.user.id), { author: text });\n    await m.reply(`Author diubah menjadi: ${text}`);\n};\n\nconst setpackname = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) return m.reply('Masukkan packname sticker baru!');\n    \n    const { jidNormalizedUser } = require('@whiskeysockets/baileys');\n    await updateBotSettings(jidNormalizedUser(conn.user.id), { packname: text });\n    await m.reply(`Packname diubah menjadi: ${text}`);\n};\n\nconst setpublic = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { jidNormalizedUser } = require('@whiskeysockets/baileys');\n    await updateBotSettings(jidNormalizedUser(conn.user.id), { public: true });\n    conn.public = true;\n    await m.reply('Bot sekarang dalam mode Public!');\n};\n\nconst setself = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { jidNormalizedUser } = require('@whiskeysockets/baileys');\n    await updateBotSettings(jidNormalizedUser(conn.user.id), { public: false });\n    conn.public = false;\n    await m.reply('Bot sekarang dalam mode Self!');\n};\n\nconst broadcast = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { text } = ctx;\n    if (!text) return m.reply('Masukkan pesan broadcast!');\n    \n    const groups = Object.keys(ctx.store.groupMetadata || {});\n    let success = 0;\n    let failed = 0;\n    \n    for (const jid of groups) {\n        try {\n            await conn.sendMessage(jid, { text: `*[ BROADCAST ]*\\n\\n${text}` });\n            success++;\n            await new Promise(r => setTimeout(r, 1000));\n        } catch (e) {\n            failed++;\n        }\n    }\n    \n    await m.reply(`Broadcast selesai!\\n‚úÖ Berhasil: ${success}\\n‚ùå Gagal: ${failed}`);\n};\n\nconst addmoney = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { args } = ctx;\n    if (args.length < 2) {\n        return m.reply(`Penggunaan: ${ctx.prefix}addmoney @user jumlah`);\n    }\n    \n    const userJid = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    const amount = parseInt(args[1]);\n    \n    if (isNaN(amount)) {\n        return m.reply('Jumlah tidak valid!');\n    }\n    \n    const user = await getUser(userJid);\n    if (!user) {\n        return m.reply('User tidak ditemukan!');\n    }\n    \n    await updateUser(userJid, { money: user.money + amount });\n    await m.reply(`Berhasil menambahkan ${amount} money ke @${userJid.split('@')[0]}!`, { mentions: [userJid] });\n};\n\nconst addlimit = async (conn, m, ctx) => {\n    if (!ctx.isOwner) return m.reply(settings.messages.owner);\n    \n    const { args } = ctx;\n    if (args.length < 2) {\n        return m.reply(`Penggunaan: ${ctx.prefix}addlimit @user jumlah`);\n    }\n    \n    const userJid = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    const amount = parseInt(args[1]);\n    \n    if (isNaN(amount)) {\n        return m.reply('Jumlah tidak valid!');\n    }\n    \n    const user = await getUser(userJid);\n    if (!user) {\n        return m.reply('User tidak ditemukan!');\n    }\n    \n    await updateUser(userJid, { limit: user.limit + amount });\n    await m.reply(`Berhasil menambahkan ${amount} limit ke @${userJid.split('@')[0]}!`, { mentions: [userJid] });\n};\n\nmodule.exports = {\n    addprem,\n    addpremium: addprem,\n    delprem,\n    delpremium: delprem,\n    ban,\n    unban,\n    addsewa,\n    sewa: addsewa,\n    delsewa,\n    setname,\n    setbotname: setname,\n    setauthor,\n    setbotauthor: setauthor,\n    setpackname,\n    setbotpackname: setpackname,\n    'public': setpublic,\n    setpublic,\n    self: setself,\n    setself,\n    broadcast,\n    bc: broadcast,\n    addmoney,\n    addlimit\n};\n","path":null,"size_bytes":9541,"size_tokens":null},"source-2/lib/utils/performanceMonitor.js":{"content":"const os = require('os');\nconst { logger } = require('./logger');\nconst { time } = require('./logger');\nconst { monitorInterval } = require('../../config');\n\nclass PerformanceMonitor {\n    constructor() {\n        this.startTime = Date.now();\n        this.ramUsage = 0;\n        this.uptime = 0;\n        this.nodeVersion = process.version;\n        this.startMonitoring();\n    }\n\n    startMonitoring() {\n        setInterval(() => {\n            this.ramUsage = (process.memoryUsage().rss / 1024 / 1024).toFixed(2);\n            this.uptime = this.formatUptime(process.uptime());\n        }, monitorInterval);\n    }\n\n    formatUptime(seconds) {\n        const days = Math.floor(seconds / (3600 * 24));\n        seconds %= 3600 * 24;\n        const hours = Math.floor(seconds / 3600);\n        seconds %= 3600;\n        const minutes = Math.floor(seconds / 60);\n        seconds %= 60;\n        return `${days}d ${hours}h ${minutes}m ${Math.floor(seconds)}s`;\n    }\n\n    getPerformanceData() {\n        return {\n            ram: this.ramUsage,\n            uptime: this.uptime,\n            nodeVersion: this.nodeVersion,\n            os: os.platform(),\n            cpu: os.cpus()[0].model,\n            speedTest: this.speedTest()\n        };\n    }\n\n    speedTest() {\n        const start = process.hrtime();\n        // Simple calculation for speed test\n        let result = 0;\n        for (let i = 0; i < 1000000; i++) {\n            result += Math.random();\n        }\n        const diff = process.hrtime(start);\n        return (diff[0] * 1e9 + diff[1]) / 1e6; // in milliseconds\n    }\n}\n\nmodule.exports = new PerformanceMonitor();","path":null,"size_bytes":1610,"size_tokens":null},"ciel/lib/tts.js":{"content":"const { join } = require('path');\nconst fs = require('fs-extra');\nconst axios = require('axios');\n\nasync function tts(text, lang = 'id') {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const tempDir = join(process.cwd(), 'temp');\n            await fs.ensureDir(tempDir);\n            \n            const url = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(text)}&tl=${lang}&client=tw-ob`;\n            \n            const response = await axios.get(url, {\n                responseType: 'arraybuffer',\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                }\n            });\n            \n            resolve(Buffer.from(response.data));\n        } catch (e) {\n            try {\n                const altUrl = `https://api.voicerss.org/?key=free&hl=${lang}&src=${encodeURIComponent(text)}`;\n                const response = await axios.get(altUrl, { responseType: 'arraybuffer' });\n                resolve(Buffer.from(response.data));\n            } catch (e2) {\n                reject(e2);\n            }\n        }\n    });\n}\n\nasync function ttsGoogle(text, lang = 'id') {\n    const maxLength = 200;\n    const chunks = [];\n    \n    for (let i = 0; i < text.length; i += maxLength) {\n        chunks.push(text.substring(i, i + maxLength));\n    }\n    \n    const audioBuffers = [];\n    \n    for (const chunk of chunks) {\n        try {\n            const buffer = await tts(chunk, lang);\n            audioBuffers.push(buffer);\n        } catch (e) {\n            console.error('TTS chunk error:', e.message);\n        }\n    }\n    \n    return Buffer.concat(audioBuffers);\n}\n\nmodule.exports = { tts, ttsGoogle };\n","path":null,"size_bytes":1740,"size_tokens":null},"source-2/lib/tmate.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\nconst FormData = require('form-data');\n\nconst tmate = {\n getToken: async () => {\n let config = {\n method: 'GET',\n url: 'https://tmate.cc/id',\n headers: {\n 'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',\n 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8',\n 'accept-language': 'id-ID',\n 'upgrade-insecure-requests': '1',\n 'sec-fetch-dest': 'document',\n 'sec-fetch-mode': 'navigate',\n 'sec-fetch-site': 'none',\n 'sec-fetch-user': '?1',\n 'alt-used': 'tmate.cc',\n 'priority': 'u=0, i',\n 'te': 'trailers',\n 'Cookie': 'session_data=e05d085a6bde39f39b0a6cb3f36cf239; _ga_P0RY16G4PC=GS1.1.1732243100.2.0.1732243100.60.0.0; _ga=GA1.1.518115277.1732232414'\n }\n };\n\n const response = await axios.request(config);\n const html = response.data;\n const $ = cheerio.load(html);\n return $('input[name=\"token\"]').val();\n },\n\n getData: async (url) => {\n const token = await tmate.getToken();\n let data = new FormData();\n data.append('url', url);\n data.append('token', token);\n\n let postConfig = {\n method: 'POST',\n url: 'https://tmate.cc/action',\n headers: {\n 'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',\n 'accept-language': 'id-ID',\n 'content-type': `multipart/form-data; boundary=${data.getBoundary()}`,\n 'referer': 'https://tmate.cc/id',\n 'origin': 'https://tmate.cc',\n 'sec-fetch-dest': 'empty',\n 'sec-fetch-mode': 'cors',\n 'sec-fetch-site': 'same-origin',\n 'priority': 'u=0',\n 'te': 'trailers',\n 'Cookie': 'session_data=e05d085a6bde39f39b0a6cb3f36cf239; _ga_P0RY16G4PC=GS1.1.1732243100.2.1.1732243198.60.0.0; _ga=GA1.1.518115277.1732232414'\n },\n data: data\n };\n\n const postResponse = await axios.request(postConfig);\n return postResponse.data;\n },\n download: async (url) => {\n  const data = await tmate.getData(url);\n  const result = data.data;\n  const $ = cheerio.load(result);\n  const mediaUrls = [];\n  let isSlide = true;\n  const downloadLinks = [];\n  $('.abuttons a').each((index, element) => {\n    const link = $(element).attr('href');\n    const linkText = $(element).text().trim();\n    if (linkText === 'Download without Watermark') {\n      isSlide = false; \n    }\n    downloadLinks.push({ linkText, link });\n  });\n  if (isSlide) {\n    mediaUrls.push(...extractImageUrls(result));\n  }\n  const title = $('h1[itemprop=\"name\"] a').text().trim();\n  const username = $('p span').text().trim();\n  const results = {\n    title,\n    username,\n    downloadLinks,\n    mediaUrls, \n    isSlide, \n  };\n\n  return results;\n}\n\n};\n\nfunction extractImageUrls(html) {\n  const $ = cheerio.load(html);\n  const images = [];\n  $('img').each((index, element) => {\n    const src = $(element).attr('src');\n    if (src) {\n      images.push(src);\n    }\n  });\n\n  return images;\n}\n\nmodule.exports = { tmate };\n","path":null,"size_bytes":2889,"size_tokens":null},"ciel/lib/uploader.js":{"content":"const fs = require('fs');\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst FormData = require('form-data');\n\nasync function getFileType(buffer) {\n    const { fileTypeFromBuffer } = await import('file-type');\n    return await fileTypeFromBuffer(buffer);\n}\n\nasync function TelegraPh(buffer) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const form = new FormData();\n            const input = Buffer.from(buffer);\n            const fileType = await getFileType(buffer);\n            const ext = fileType?.ext || 'bin';\n            form.append('file', input, { filename: 'data.' + ext });\n            const { data } = await axios.post('https://telegra.ph/upload', form, {\n                headers: {\n                    ...form.getHeaders()\n                }\n            });\n            resolve('https://telegra.ph' + data[0].src);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function UguuSe(buffer) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const form = new FormData();\n            const input = Buffer.from(buffer);\n            const fileType = await getFileType(buffer);\n            const ext = fileType?.ext || 'bin';\n            form.append('files[]', input, { filename: 'data.' + ext });\n            const { data } = await axios.post('https://uguu.se/upload.php', form, {\n                headers: {\n                    ...form.getHeaders()\n                }\n            });\n            resolve(data.files[0]);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function Catbox(buffer) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const form = new FormData();\n            const input = Buffer.from(buffer);\n            const fileType = await getFileType(buffer);\n            const ext = fileType?.ext || 'bin';\n            form.append('reqtype', 'fileupload');\n            form.append('fileToUpload', input, { filename: 'data.' + ext });\n            const { data } = await axios.post('https://catbox.moe/user/api.php', form, {\n                headers: {\n                    ...form.getHeaders()\n                }\n            });\n            resolve(data);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function webp2mp4(buffer) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const form = new FormData();\n            form.append('new-image-url', '');\n            form.append('new-image', buffer, { filename: 'image.webp' });\n            \n            const { data } = await axios.post('https://s6.ezgif.com/webp-to-mp4', form, {\n                headers: {\n                    'Content-Type': `multipart/form-data; boundary=${form.getBoundary()}`\n                }\n            });\n            \n            const $ = cheerio.load(data);\n            const file = $('input[name=\"file\"]').attr('value');\n            \n            const formConvert = new FormData();\n            formConvert.append('file', file);\n            formConvert.append('convert', 'Convert WebP to MP4!');\n            \n            const { data: convertData } = await axios.post('https://ezgif.com/webp-to-mp4/' + file, formConvert, {\n                headers: {\n                    'Content-Type': `multipart/form-data; boundary=${formConvert.getBoundary()}`\n                }\n            });\n            \n            const $2 = cheerio.load(convertData);\n            const result = 'https:' + $2('div#output > p.outfile > video > source').attr('src');\n            \n            resolve({\n                status: true,\n                result: result\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nmodule.exports = { TelegraPh, UguuSe, Catbox, webp2mp4, getFileType };\n","path":null,"size_bytes":3805,"size_tokens":null},"source-1/lib/tts.js":{"content":"const { join } = require('path');\r\nconst gtts = require('node-gtts');\r\nconst { readFileSync, unlinkSync } = require('fs');\r\n\r\nfunction tts(text, lang = 'id') {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      let tts = gtts(lang)\r\n      let filePath = join(__dirname, '../database/sampah', (1 * new Date) + '.wav')\r\n      tts.save(filePath, text, () => {\r\n        resolve(readFileSync(filePath))\r\n        unlinkSync(filePath)\r\n      })\r\n    } catch (e) { reject(e) }\r\n  })\r\n}\r\n\r\nmodule.exports = { tts }","path":null,"size_bytes":517,"size_tokens":null},"ciel/start.sh":{"content":"#!/bin/bash\n\necho \"==========================================\"\necho \"       Ciel Bot - WhatsApp Bot\"\necho \"==========================================\"\n\ncd \"$(dirname \"$0\")\"\n\nif ! command -v node &> /dev/null; then\n    echo \"[ERROR] Node.js tidak ditemukan!\"\n    echo \"Install Node.js terlebih dahulu (v18+)\"\n    exit 1\nfi\n\nNODE_VERSION=$(node -v | cut -d'v' -f2 | cut -d'.' -f1)\nif [ \"$NODE_VERSION\" -lt 18 ]; then\n    echo \"[ERROR] Node.js versi $NODE_VERSION terdeteksi\"\n    echo \"Diperlukan Node.js v18 atau lebih tinggi\"\n    exit 1\nfi\n\necho \"[INFO] Node.js $(node -v) terdeteksi\"\n\nif [ ! -d \"node_modules\" ]; then\n    echo \"[INFO] Installing dependencies...\"\n    npm install\n    if [ $? -ne 0 ]; then\n        echo \"[ERROR] Gagal install dependencies\"\n        exit 1\n    fi\nfi\n\necho \"[INFO] Generating Prisma client...\"\nnpx prisma generate\nif [ $? -ne 0 ]; then\n    echo \"[ERROR] Gagal generate Prisma client\"\n    exit 1\nfi\n\nmkdir -p logs\nmkdir -p ciel_session\n\necho \"[INFO] Starting Ciel Bot...\"\necho \"==========================================\"\n\nif command -v pm2 &> /dev/null; then\n    echo \"[INFO] PM2 terdeteksi, menggunakan PM2...\"\n    pm2 start ecosystem.config.js\n    pm2 logs ciel-bot\nelse\n    echo \"[INFO] Menjalankan dengan Node.js...\"\n    node src/index.js\nfi\n","path":null,"size_bytes":1275,"size_tokens":null},"ciel/lib/tmate.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\nconst FormData = require('form-data');\n\nconst tmate = {\n    getToken: async () => {\n        const config = {\n            method: 'GET',\n            url: 'https://tmate.cc/id',\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',\n                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8',\n                'accept-language': 'id-ID',\n                'upgrade-insecure-requests': '1',\n                'sec-fetch-dest': 'document',\n                'sec-fetch-mode': 'navigate',\n                'sec-fetch-site': 'none',\n                'sec-fetch-user': '?1',\n                'alt-used': 'tmate.cc',\n                'priority': 'u=0, i',\n                'te': 'trailers'\n            }\n        };\n\n        const response = await axios.request(config);\n        const html = response.data;\n        const $ = cheerio.load(html);\n        return $('input[name=\"token\"]').val();\n    },\n\n    getData: async (url) => {\n        const token = await tmate.getToken();\n        const data = new FormData();\n        data.append('url', url);\n        data.append('token', token);\n\n        const postConfig = {\n            method: 'POST',\n            url: 'https://tmate.cc/action',\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Android 10; Mobile; rv:131.0) Gecko/131.0 Firefox/131.0',\n                'accept-language': 'id-ID',\n                'content-type': `multipart/form-data; boundary=${data.getBoundary()}`,\n                'referer': 'https://tmate.cc/id',\n                'origin': 'https://tmate.cc',\n                'sec-fetch-dest': 'empty',\n                'sec-fetch-mode': 'cors',\n                'sec-fetch-site': 'same-origin',\n                'priority': 'u=0',\n                'te': 'trailers'\n            },\n            data: data\n        };\n\n        const postResponse = await axios.request(postConfig);\n        return postResponse.data;\n    },\n\n    download: async (url) => {\n        const data = await tmate.getData(url);\n        const result = data.data;\n        const $ = cheerio.load(result);\n        const mediaUrls = [];\n        let isSlide = true;\n        const downloadLinks = [];\n\n        $('.abuttons a').each((index, element) => {\n            const link = $(element).attr('href');\n            const linkText = $(element).text().trim();\n            if (linkText === 'Download without Watermark') {\n                isSlide = false;\n            }\n            downloadLinks.push({ linkText, link });\n        });\n\n        if (isSlide) {\n            mediaUrls.push(...extractImageUrls(result));\n        }\n\n        const title = $('h1[itemprop=\"name\"] a').text().trim();\n        const username = $('p span').text().trim();\n\n        return {\n            title,\n            username,\n            downloadLinks,\n            mediaUrls,\n            isSlide\n        };\n    }\n};\n\nfunction extractImageUrls(html) {\n    const $ = cheerio.load(html);\n    const images = [];\n    $('img').each((index, element) => {\n        const src = $(element).attr('src');\n        if (src) {\n            images.push(src);\n        }\n    });\n    return images;\n}\n\nmodule.exports = { tmate };\n","path":null,"size_bytes":3313,"size_tokens":null},"source-2/index.js":{"content":"const { makeWASocket, useMultiFileAuthState } = require('@naruyaizumi/baileys');\nconst P = require('pino');\nconst { authFolder, browser } = require('./config.js');\nconst { logger } = require('./lib/utils/logger.js');\nconst { handleConnectionUpdate } = require('./lib/handlers/connectionHandler.js');\nconst { handleMessages } = require('./lib/handlers/messageHandler.js');\nconst performanceMonitor = require('./lib/utils/performanceMonitor');\n\nasync function startBot() {\n    logger.info(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);\n    logger.info(`‚ïë   TIKTOK/DOUYIN DOWNLOADER BOT   ‚ïë`);\n    logger.info(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);\n    \n    const { state, saveCreds } = await useMultiFileAuthState(authFolder);\n    \n    const conn = makeWASocket({\n        printQRInTerminal: true,\n        auth: state,\n        logger: P({ level: 'silent' }),\n        browser,\n        markOnlineOnConnect: true,\n        syncFullHistory: false\n    });\n\n    require('./lib/utils/stickerSender')(conn);\n\n    // Event handlers\n    conn.ev.on('creds.update', saveCreds);\n    conn.ev.on('connection.update', (update) => handleConnectionUpdate(conn, update));\n    conn.ev.on('messages.upsert', async ({ messages }) => handleMessages(conn, messages));\n\n    process.on('SIGINT', () => {\n        logger.info(`üõë Shutting down...`);\n        conn.end();\n        process.exit(0);\n    });\n\n    return conn;\n}\n\nstartBot().catch(err => {\n    logger.error(`üö® Startup error: ${err.message}`);\n    process.exit(1);\n});","path":null,"size_bytes":1644,"size_tokens":null},"source-1/naze.js":{"content":"process.on('uncaughtException', console.error)\r\nprocess.on('unhandledRejection', console.error)\r\n\r\n/*\r\n\t* Create By Naze\r\n\t* Follow https://github.com/nazedev\r\n\t* Whatsapp : https://whatsapp.com/channel/0029VaWOkNm7DAWtkvkJBK43\r\n*/\r\n\r\nrequire('./settings');\r\nconst fs = require('fs');\r\nconst os = require('os');\r\nconst qs = require('qs');\r\nconst util = require('util');\r\nconst jimp = require('jimp');\r\nconst path = require('path');\r\nconst https = require('https');\r\nconst axios = require('axios');\r\nconst chalk = require('chalk');\r\nconst yts = require('yt-search');\r\nconst ytdl = require('ytdl-core');\r\nconst cron = require('node-cron');\r\nconst cheerio = require('cheerio');\r\nconst fetch = require('node-fetch');\r\nconst FileType = require('file-type');\r\nconst { Chess } = require('chess.js');\r\nconst google = require('googlethis');\r\nconst similarity = require('similarity');\r\nconst PDFDocument = require('pdfkit');\r\nconst webp = require('node-webpmux');\r\nconst ffmpeg = require('fluent-ffmpeg');\r\nconst speed = require('performance-now');\r\nconst didYouMean = require('didyoumean');\r\nconst { performance } = require('perf_hooks');\r\nconst moment = require('moment-timezone');\r\nconst translate = require('translate-google-api');\r\nconst { Akinator, AkinatorAnswer } = require('aki-api');\r\nconst PhoneNum = require('awesome-phonenumber');\r\nconst { exec, spawn, execSync } = require('child_process');\r\nconst { BufferJSON, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, getBinaryNodeChildren, generateWAMessageContent, generateWAMessage, prepareWAMessageMedia, areJidsSameUser, getContentType } = require('baileys');\r\n\r\nconst menfesTimeouts = new Map();\r\nconst TicTacToe = require('./lib/tictactoe');\r\nconst { antiSpam } = require('./src/antispam');\r\nconst templateMenu = require('./lib/template_menu');\r\nconst { TelegraPh, UguuSe } = require('./lib/uploader');\r\nconst { toAudio, toPTT, toVideo } = require('./lib/converter');\r\nconst { GroupUpdate, LoadDataBase } = require('./src/message');\r\nconst { JadiBot, StopJadiBot, ListJadiBot } = require('./src/jadibot');\r\nconst { imageToWebp, videoToWebp, gifToWebp, writeExif } = require('./lib/exif');\r\nconst { cmdAdd, cmdDel, cmdAddHit, addExpired, getPosition, getExpired, getStatus, checkStatus, getAllExpired, checkExpired } = require('./src/database');\r\nconst { rdGame, iGame, tGame, gameSlot, gameCasinoSolo, gameSamgongSolo, gameMerampok, gameBegal, daily, buy, setLimit, addLimit, addMoney, setMoney, transfer, Blackjack, SnakeLadder } = require('./lib/game');\r\nconst { pinterest, wallpaper, remini, wikimedia, hitamkan, yanzGpt, mediafireDl, ringtone, styletext, instagramDl, tiktokDl, facebookDl, instaStalk, telegramStalk, tiktokStalk, genshinStalk, instaStory, bk9Ai, spotifyDl, ytMp4, ytMp3, NvlGroup, quotedLyo, youSearch, gptLogic, savetube, simi, geminiAi } = require('./lib/screaper');\r\nconst { unixTimestampSeconds, generateMessageTag, processTime, webApi, getRandom, getBuffer, fetchJson, runtime, clockString, sleep, isUrl, getTime, formatDate, formatp, jsonformat, reSize, toHD, logic, generateProfilePicture, bytesToSize, errorCache, normalize, getSizeMedia, parseMention, getGroupAdmins, readFileTxt, readFileJson, getHashedPassword, generateAuthToken, cekMenfes, generateToken, batasiTeks, randomText, isEmoji, getTypeUrlMedia, pickRandom, convertTimestampToDate, getAllHTML, tarBackup } = require('./lib/function');\r\n\r\nmodule.exports = naze = async (naze, m, msg, store) => {\r\n\tconst botNumber = naze.decodeJid(naze.user.id);\r\n\tconst ownerNumber = db?.set?.[botNumber]?.owner?.map(x => x.id) || owner;\r\n\t\r\n\ttry {\r\n\t\t\r\n\t\tawait LoadDataBase(naze, m);\r\n\t\tawait GroupUpdate(naze, m, store);\r\n\t\t\r\n\t\tconst body = ((m.type === 'conversation') ? m.message.conversation :\r\n\t\t(m.type == 'imageMessage') ? m.message.imageMessage.caption :\r\n\t\t(m.type == 'videoMessage') ? m.message.videoMessage.caption :\r\n\t\t(m.type == 'extendedTextMessage') ? m.message.extendedTextMessage.text :\r\n\t\t(m.type == 'reactionMessage') ? m.message.reactionMessage.text :\r\n\t\t(m.type == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId :\r\n\t\t(m.type == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId :\r\n\t\t(m.type == 'templateButtonReplyMessage') ? m.message.templateButtonReplyMessage.selectedId :\r\n\t\t(m.type == 'interactiveResponseMessage'  && m.quoted) ? (m.message.interactiveResponseMessage?.nativeFlowResponseMessage ? JSON.parse(m.message.interactiveResponseMessage.nativeFlowResponseMessage.paramsJson).id : '') :\r\n\t\t(m.type == 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectReply.selectedRowId || '') :\r\n\t\t(m.type == 'editedMessage') ? (m.message.editedMessage?.message?.protocolMessage?.editedMessage?.extendedTextMessage?.text || m.message.editedMessage?.message?.protocolMessage?.editedMessage?.conversation || '') :\r\n\t\t(m.type == 'protocolMessage') ? (m.message.protocolMessage?.editedMessage?.extendedTextMessage?.text || m.message.protocolMessage?.editedMessage?.conversation || m.message.protocolMessage?.editedMessage?.imageMessage?.caption || m.message.protocolMessage?.editedMessage?.videoMessage?.caption || '') : '') || '';\r\n\t\t\r\n\t\tconst budy = (typeof m.text == 'string' ? m.text : '')\r\n\t\tconst isCreator = isOwner = [botNumber, ...ownerNumber].filter(v => typeof v === 'string').map(v => v.replace(/[^0-9]/g, '')).includes(m.sender.split('@')[0])\r\n\t\tconst cases = db.cases ? db.cases : (db.cases = [...fs.readFileSync('./naze.js', 'utf-8').matchAll(/case\\s+['\"]([^'\"]+)['\"]/g)].map(match => match[1]));\r\n\t\tconst prefix = isCreator ? (/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@()#,'\"*+√∑/\\%^&.¬©^]/gi.test(body) ? body.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@()#,'\"*+√∑/\\%^&.¬©^]/gi)[0] : /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi.test(body) ? body.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi)[0] : listprefix.find(a => body?.startsWith(a)) || '') : db.set[botNumber].multiprefix ? (/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@()#,'\"*+√∑/\\%^&.¬©^]/gi.test(body) ? body.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@()#,'\"*+√∑/\\%^&.¬©^]/gi)[0] : /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi.test(body) ? body.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi)[0] : listprefix.find(a => body?.startsWith(a)) || '¬ø') : listprefix.find(a => body?.startsWith(a)) || '¬ø'\r\n\t\tconst isCmd = body.startsWith(prefix)\r\n\t\tconst args = body.trim().split(/ +/).slice(1)\r\n\t\tconst quoted = m.quoted ? m.quoted : m\r\n\t\tconst command = isCreator ? body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase() : isCmd ? body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase() : ''\r\n\t\tconst text = q = args.join(' ')\r\n\t\tconst mime = (quoted.msg || quoted).mimetype || ''\r\n\t\tconst qmsg = (quoted.msg || quoted)\r\n\t\tconst author = db?.set?.[botNumber]?.author || 'Nazedev';\r\n\t\tconst packname = db?.set?.[botNumber]?.packname || 'Bot WhatsApp';\r\n\t\tconst hari = moment.tz('Asia/Jakarta').locale('id').format('dddd');\r\n\t\tconst tanggal = moment.tz('Asia/Jakarta').locale('id').format('DD/MM/YYYY');\r\n\t\tconst jam = moment.tz('Asia/Jakarta').locale('id').format('HH:mm:ss');\r\n\t\tconst ucapanWaktu = jam < '05:00:00' ? 'Selamat Pagi üåâ' : jam < '11:00:00' ? 'Selamat Pagi üåÑ' : jam < '15:00:00' ? 'Selamat Siang üèô' : jam < '18:00:00' ? 'Selamat Sore üåÖ' : jam < '19:00:00' ? 'Selamat Sore üåÉ' : jam < '23:59:00' ? 'Selamat Malam üåå' : 'Selamat Malam üåå';\r\n\t\tconst almost = 0.72\r\n\t\tconst time = Date.now()\r\n\t\tconst time_now = new Date()\r\n\t\tconst time_end = 60000 - (time_now.getSeconds() * 1000 + time_now.getMilliseconds());\r\n\t\tconst readmore = String.fromCharCode(8206).repeat(999)\r\n\t\tconst setv = pickRandom(listv)\r\n\t\t\r\n\t\t// Read Database\r\n\t\tconst sewa = db.sewa\r\n\t\tconst premium = db.premium\r\n\t\tconst set = db.set[botNumber]\r\n\t\t\r\n\t\t// Database Game\r\n\t\tlet suit = db.game.suit\r\n\t\tlet chess = db.game.chess\r\n\t\tlet chat_ai = db.game.chat_ai\r\n\t\tlet menfes = db.game.menfes\r\n\t\tlet tekateki = db.game.tekateki\r\n\t\tlet akinator = db.game.akinator\r\n\t\tlet tictactoe = db.game.tictactoe\r\n\t\tlet tebaklirik = db.game.tebaklirik\r\n\t\tlet kuismath = db.game.kuismath\r\n\t\tlet blackjack = db.game.blackjack\r\n\t\tlet tebaklagu = db.game.tebaklagu\r\n\t\tlet tebakkata = db.game.tebakkata\r\n\t\tlet family100 = db.game.family100\r\n\t\tlet susunkata = db.game.susunkata\r\n\t\tlet tebakbom = db.game.tebakbom\r\n\t\tlet ulartangga = db.game.ulartangga\r\n\t\tlet tebakkimia = db.game.tebakkimia\r\n\t\tlet caklontong = db.game.caklontong\r\n\t\tlet tebakangka = db.game.tebakangka\r\n\t\tlet tebaknegara = db.game.tebaknegara\r\n\t\tlet tebakgambar = db.game.tebakgambar\r\n\t\tlet tebakbendera = db.game.tebakbendera\r\n\t\t\r\n\t\tconst isVip = db.users[m.sender] ? db.users[m.sender].vip : false\r\n\t\tconst isBan = db.users[m.sender] ? db.users[m.sender].ban : false\r\n\t\tconst isLimit = db.users[m.sender] ? (db.users[m.sender].limit > 0) : false\r\n\t\tconst isPremium = isCreator || checkStatus(m.sender, premium) || false\r\n\t\tconst isNsfw = m.isGroup ? db.groups[m.chat].nsfw : false\r\n\t\t\r\n\t\t// Fake\r\n\t\tconst fkontak = {\r\n\t\t\tkey: {\r\n\t\t\t\tremoteJid: '0@s.whatsapp.net',\r\n\t\t\t\tparticipant: '0@s.whatsapp.net',\r\n\t\t\t\tfromMe: false,\r\n\t\t\t\tid: 'Naze'\r\n\t\t\t},\r\n\t\t\tmessage: {\r\n\t\t\t\tcontactMessage: {\r\n\t\t\t\t\tdisplayName: (m.pushName || author),\r\n\t\t\t\t\tvcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:XL;${m.pushName || author},;;;\\nFN:${m.pushName || author}\\nitem1.TEL;waid=${m.sender.split('@')[0]}:${m.sender.split('@')[0]}\\nitem1.X-ABLabel:Ponsel\\nEND:VCARD`,\r\n\t\t\t\t\tsendEphemeral: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Reset Limit\r\n\t\tcron.schedule('00 00 * * *', async () => {\r\n\t\t\tcmdDel(db.hit);\r\n\t\t\tconsole.log('Reseted Limit Users')\r\n\t\t\tlet user = Object.keys(db.users)\r\n\t\t\tfor (let jid of user) {\r\n\t\t\t\tconst limitUser = db.users[jid].vip ? limit.vip : checkStatus(jid, premium) ? limit.premium : limit.free\r\n\t\t\t\tif (db.users[jid].limit < limitUser) db.users[jid].limit = limitUser\r\n\t\t\t}\r\n\t\t\tif (set?.autobackup) {\r\n\t\t\t\tlet datanya = './database/' + tempatDB;\r\n\t\t\t\tif (tempatDB.startsWith('mongodb')) {\r\n\t\t\t\t\tdatanya = './database/backup_database.json';\r\n\t\t\t\t\tfs.writeFileSync(datanya, JSON.stringify(global.db, null, 2), 'utf-8');\r\n\t\t\t\t}\r\n\t\t\t\tlet tglnya = new Date().toISOString().replace(/[:.]/g, '-');\r\n\t\t\t\tfor (let o of ownerNumber) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait naze.sendMessage(o, { document: fs.readFileSync(datanya), mimetype: 'application/json', fileName: tglnya + '_database.json' })\r\n\t\t\t\t\t\tconsole.log(`[AUTO BACKUP] Backup berhasil dikirim ke ${o}`);\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tconsole.error(`[AUTO BACKUP] Gagal mengirim backup ke ${o}:`, error);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tscheduled: true,\r\n\t\t\ttimezone: 'Asia/Jakarta'\r\n\t\t});\r\n\t\t\r\n\t\t// Auto Set Bio\r\n\t\tif (set.autobio) {\r\n\t\t\tif (new Date() * 1 - set.status > 60000) {\r\n\t\t\t\tawait naze.updateProfileStatus(`${naze.user.name} | üéØ Runtime : ${runtime(process.uptime())}`).catch(e => {})\r\n\t\t\t\tset.status = new Date() * 1\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Set Mode\r\n\t\tif (!isCreator) {\r\n\t\t\tif ((set.grouponly === set.privateonly)) {\r\n\t\t\t\tif (!naze.public && !m.key.fromMe) return\r\n\t\t\t} else if (set.grouponly) {\r\n\t\t\t\tif (!m.isGroup) return\r\n\t\t\t} else if (set.privateonly) {\r\n\t\t\t\tif (m.isGroup) return\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Group Settings\r\n\t\tif (m.isGroup) {\r\n\t\t\t// Mute\r\n\t\t\tif (db.groups[m.chat].mute && !isCreator) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Anti Hidetag\r\n\t\t\tif (!m.key.fromMe && m.mentionedJid?.length === m.metadata.participanis?.length && db.groups[m.chat].antihidetag && !isCreator && m.isBotAdmin && !m.isAdmin) {\r\n\t\t\t\tawait naze.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.id, participant: m.sender }})\r\n\t\t\t\tawait m.reply('*Anti Hidetag Sedang Aktif‚ùó*')\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Anti Tag Sw\r\n\t\t\tif (!m.key.fromMe && db.groups[m.chat].antitagsw && !isCreator && m.isBotAdmin && !m.isAdmin) {\r\n\t\t\t\tif (m.type === 'groupStatusMentionMessage' || m.message?.groupStatusMentionMessage || m.message?.protocolMessage?.type === 25 || Object.keys(m.message).length === 1 && Object.keys(m.message)[0] === 'messageContextInfo') {\r\n\t\t\t\t\tif (!db.groups[m.chat].tagsw[m.sender]) {\r\n\t\t\t\t\t\tdb.groups[m.chat].tagsw[m.sender] = 1\r\n\t\t\t\t\t\tawait m.reply(`Grup ini terdeteksi ditandai dalam Status WhatsApp\\n@${m.sender.split('@')[0]}, mohon untuk tidak menandai grup dalam status WhatsApp\\nPeringatan ${db.groups[m.chat].tagsw[m.sender]}/5, akan dikick sewaktu waktu‚ùó`)\r\n\t\t\t\t\t} else if (db.groups[m.chat].tagsw[m.sender] >= 5) {\r\n\t\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [m.sender], 'remove').catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t\t\tawait m.reply(`@${m.sender.split(\"@\")[0]} telah dikeluarkan dari grup\\nKarena menandai grup dalam status WhatsApp sebanyak 5x`)\r\n\t\t\t\t\t\tdelete db.groups[m.chat].tagsw[m.sender]\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdb.groups[m.chat].tagsw[m.sender] += 1\r\n\t\t\t\t\t\tawait m.reply(`Grup ini terdeteksi ditandai dalam Status WhatsApp\\n@${m.sender.split('@')[0]}, mohon untuk tidak menandai grup dalam status WhatsApp\\nPeringatan ${db.groups[m.chat].tagsw[m.sender]}/5, akan dikick sewaktu waktu‚ùó`)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Anti Toxic\r\n\t\t\tif (!m.key.fromMe && db.groups[m.chat].antitoxic && !isCreator && m.isBotAdmin && !m.isAdmin) {\r\n\t\t\t\tif (budy.toLowerCase().split(/\\s+/).some(word => badWords.includes(word))) {\r\n\t\t\t\t\tawait naze.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.id, participant: m.sender }})\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, { extendedTextMessage: { text: `Terdeteksi @${m.sender.split('@')[0]} Berkata Toxic\\nMohon gunakan bahasa yang sopan.`, contextInfo: { mentionedJid: [m.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Toxic‚ùó*'}, ...m.key }}}, {})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Anti Delete\r\n\t\t\tif (m.type == 'protocolMessage' && db.groups[m.chat].antidelete && !isCreator && m.isBotAdmin && !m.isAdmin) {\r\n\t\t\t\tconst mess = msg.message.protocolMessage\r\n\t\t\t\tif (store?.messages?.[m.chat]?.array) {\r\n\t\t\t\t\tconst chats = store.messages[m.chat].array.find(a => a.id === mess.key.id);\r\n\t\t\t\t\tif (!chats?.msg) return\r\n\t\t\t\t\tchats.msg.contextInfo = { mentionedJid: [chats.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Delete‚ùó*'}, ...chats.key }\r\n\t\t\t\t\tconst pesan = chats.type === 'conversation' ? { extendedTextMessage: { text: chats.msg, contextInfo: { mentionedJid: [chats.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Delete‚ùó*'}, ...chats.key }}} : { [chats.type]: chats.msg }\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, pesan, {})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Anti Link Group\r\n\t\t\tif (db.groups[m.chat].antilink && !isCreator && m.isBotAdmin && !m.isAdmin) {\r\n\t\t\t\tif (budy.match('chat.whatsapp.com/')) {\r\n\t\t\t\t\tawait naze.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.id, participant: m.sender }})\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, { extendedTextMessage: { text: `Terdeteksi @${m.sender.split('@')[0]} Mengirim Link Group\\nMaaf Link Harus Di Hapus..`, contextInfo: { mentionedJid: [m.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Link‚ùó*'}, ...m.key }}}, {})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Anti Virtex Group\r\n\t\t\tif (db.groups[m.chat].antivirtex && !isCreator && m.isBotAdmin && !m.isAdmin) {\r\n\t\t\t\tif (budy.length > 4000) {\r\n\t\t\t\t\tawait naze.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.id, participant: m.sender }})\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, { extendedTextMessage: { text: `Terdeteksi @${m.sender.split('@')[0]} Mengirim Virtex..`, contextInfo: { mentionedJid: [m.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Virtex‚ùó*'}, ...m.key }}}, {})\r\n\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [m.sender], 'remove')\r\n\t\t\t\t}\r\n\t\t\t\tif (m.msg?.nativeFlowMessage?.messageParamsJson?.length > 3500) {\r\n\t\t\t\t\tawait naze.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.id, participant: m.sender }})\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, { extendedTextMessage: { text: `Terdeteksi @${m.sender.split('@')[0]} Mengirim Bug..`, contextInfo: { mentionedJid: [m.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Bug‚ùó*'}, ...m.key }}}, {})\r\n\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [m.sender], 'remove')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// Auto Read\r\n\t\tif (m.message && m.key.remoteJid !== 'status@broadcast') {\r\n\t\t\tif ((set.autoread && naze.public) || isCreator) {\r\n\t\t\t\tnaze.readMessages([m.key]);\r\n\t\t\t\tconsole.log(chalk.black(chalk.bgWhite('[ PESAN ]:'), chalk.bgGreen(new Date), chalk.bgHex('#00EAD3')(budy || m.type), chalk.bgHex('#AF26EB')(m.key.id) + '\\n' + chalk.bgCyanBright('[ DARI ] :'), chalk.bgYellow(m.pushName || (isCreator ? 'Bot' : 'Anonim')), chalk.bgHex('#FF449F')(m.sender), chalk.bgHex('#FF5700')(m.isGroup ? m.metadata.subject : m.chat.endsWith('@newsletter') ? 'Newsletter' : 'Private Chat'), chalk.bgBlue('(' + m.chat + ')')));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Filter Bot & Ban\r\n\t\tif (m.isBot) return\r\n\t\tif (db.users[m.sender]?.ban && !isCreator) return\r\n\t\t\r\n\t\t// Mengetik & Anti Spam & Hit\r\n\t\tif (naze.public && isCmd) {\r\n\t\t\tif (set.autotyping) {\r\n\t\t\t\tawait naze.sendPresenceUpdate('composing', m.chat)\r\n\t\t\t}\r\n\t\t\tif (cases.includes(command)) {\r\n\t\t\t\tcmdAdd(db.hit);\r\n\t\t\t\tcmdAddHit(db.hit, command);\r\n\t\t\t}\r\n\t\t\tif (set.antispam && antiSpam.isFiltered(m.sender)) {\r\n\t\t\t\tconsole.log(chalk.bgRed('[ SPAM ] : '), chalk.black(chalk.bgHex('#1CFFF7')(`From -> ${m.sender}`), chalk.bgHex('#E015FF')(` In ${m.isGroup ? m.chat : 'Private Chat'}`)))\r\n\t\t\t\treturn m.reply('„Äå ‚ùó „ÄçBeri Jeda 5 Detik Per Command Kak')\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (isCmd && !isCreator) antiSpam.addFilter(m.sender)\r\n\t\t\r\n\t\t// Cmd Media\r\n\t\tlet fileSha256;\r\n\t\tif (m.isMedia && m.msg.fileSha256 && db.cmd && (m.msg.fileSha256.toString('base64') in db.cmd)) {\r\n\t\t\tlet hash = db.cmd[m.msg.fileSha256.toString('base64')]\r\n\t\t\tfileSha256 = hash.text\r\n\t\t}\r\n\t\t\r\n\t\t// Salam\r\n\t\tif (/^a(s|ss)alamu('|)alaikum(| )(wr|)( |)(wb|)$/.test(budy?.toLowerCase())) {\r\n\t\t\tconst jwb_salam = ['Wa\\'alaikumusalam','Wa\\'alaikumusalam wr wb','Wa\\'alaikumusalam Warohmatulahi Wabarokatuh']\r\n\t\t\tm.reply(pickRandom(jwb_salam))\r\n\t\t}\r\n\t\t\r\n\t\t// Waktu Sholat\r\n\t\tconst jadwalSholat = {\r\n\t\t\tSubuh: '04:30',\r\n\t\t\tDzuhur: '12:06',\r\n\t\t\tAshar: '15:21',\r\n\t\t\tMaghrib: '18:08',\r\n\t\t\tIsya: '19:00'\r\n\t\t}\r\n\t\tif (!this.intervalSholat) this.intervalSholat = null;\r\n\t\tif (!this.waktusholat) this.waktusholat = {};\r\n\t\tif (this.intervalSholat) clearInterval(this.intervalSholat); \r\n\t\tsetTimeout(() => {\r\n\t\t\tthis.intervalSholat = setInterval(async() => {\r\n\t\t\t\tconst sekarang = moment.tz('Asia/Jakarta');\r\n\t\t\t\tconst jamSholat = sekarang.format('HH:mm');\r\n\t\t\t\tconst hariIni = sekarang.format('YYYY-MM-DD');\r\n\t\t\t\tconst detik = sekarang.format('ss');\r\n\t\t\t\tif (detik !== '00') return;\r\n\t\t\t\tfor (const [sholat, waktu] of Object.entries(jadwalSholat)) {\r\n\t\t\t\t\tif (jamSholat === waktu && this.waktusholat[sholat] !== hariIni) {\r\n\t\t\t\t\t\tthis.waktusholat[sholat] = hariIni\r\n\t\t\t\t\t\tfor (const [idnya, settings] of Object.entries(db.groups)) {\r\n\t\t\t\t\t\t\tif (settings.waktusholat) {\r\n\t\t\t\t\t\t\t\tawait naze.sendMessage(idnya, { text: `Waktu *${sholat}* telah tiba, ambilah air wudhu dan segeralah shalatüôÇ.\\n\\n*${waktu.slice(0, 5)}*\\n_untuk wilayah Jakarta dan sekitarnya._` }, { ephemeralExpiration: m.expiration || store?.messages[idnya]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 }).catch(e => {})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, 60000)\r\n\t\t}, time_end);\r\n\t\t\r\n\t\t// Cek Expired\r\n\t\tcheckExpired(premium);\r\n\t\tcheckExpired(sewa, naze);\r\n\t\t\r\n\t\t// TicTacToe\r\n\t\tlet room = Object.values(tictactoe).find(room => room.id && room.game && room.state && room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender) && room.state == 'PLAYING')\r\n\t\tif (room) {\r\n\t\t\tlet now = Date.now();\r\n\t\t\tif (now - (room.lastMove || now) > 5 * 60 * 1000) {\r\n\t\t\t\tm.reply('Game Tic-Tac-Toe dibatalkan karena tidak ada aktivitas selama 5 menit.');\r\n\t\t\t\tdelete tictactoe[room.id];\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\troom.lastMove = now;\r\n\t\t\tlet ok, isWin = false, isTie = false, isSurrender = false;\r\n\t\t\tif (!/^([1-9]|(me)?nyerah|surr?ender|off|skip)$/i.test(m.text)) return\r\n\t\t\tisSurrender = !/^[1-9]$/.test(m.text)\r\n\t\t\tif (m.sender !== room.game.currentTurn) {\r\n\t\t\t\tif (!isSurrender) return true\r\n\t\t\t}\r\n\t\t\tif (!isSurrender && 1 > (ok = room.game.turn(m.sender === room.game.playerO, parseInt(m.text) - 1))) {\r\n\t\t\t\tm.reply({'-3': 'Game telah berakhir','-2': 'Invalid','-1': 'Posisi Invalid',0: 'Posisi Invalid'}[ok])\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tif (m.sender === room.game.winner) isWin = true\r\n\t\t\telse if (room.game.board === 511) isTie = true\r\n\t\t\tif (!(room.game instanceof TicTacToe)) {\r\n\t\t\t\troom.game = Object.assign(new TicTacToe(room.game.playerX, room.game.playerO), room.game)\r\n\t\t\t}\r\n\t\t\tlet arr = room.game.render().map(v => ({X: '‚ùå',O: '‚≠ï',1: '1Ô∏è‚É£',2: '2Ô∏è‚É£',3: '3Ô∏è‚É£',4: '4Ô∏è‚É£',5: '5Ô∏è‚É£',6: '6Ô∏è‚É£',7: '7Ô∏è‚É£',8: '8Ô∏è‚É£',9: '9Ô∏è‚É£'}[v]))\r\n\t\t\tif (isSurrender) {\r\n\t\t\t\troom.game._currentTurn = m.sender === room.game.playerX\r\n\t\t\t\tisWin = true\r\n\t\t\t}\r\n\t\t\tlet winner = isSurrender ? room.game.currentTurn : room.game.winner\r\n\t\t\tif (isWin) {\r\n\t\t\t\tdb.users[m.sender].limit += 3\r\n\t\t\t\tdb.users[m.sender].money += 3000\r\n\t\t\t}\r\n\t\t\tlet str = `Room ID: ${room.id}\\n\\n${arr.slice(0, 3).join('')}\\n${arr.slice(3, 6).join('')}\\n${arr.slice(6).join('')}\\n\\n${isWin ? `@${winner.split('@')[0]} Menang!` : isTie ? `Game berakhir` : `Giliran ${['‚ùå', '‚≠ï'][1 * room.game._currentTurn]} (@${room.game.currentTurn.split('@')[0]})`}\\n‚ùå: @${room.game.playerX.split('@')[0]}\\n‚≠ï: @${room.game.playerO.split('@')[0]}\\n\\nKetik *nyerah* untuk menyerah dan mengakui kekalahan`\r\n\t\t\tif ((room.game._currentTurn ^ isSurrender ? room.x : room.o) !== m.chat)\r\n\t\t\troom[room.game._currentTurn ^ isSurrender ? 'x' : 'o'] = m.chat\r\n\t\t\tif (room.x !== room.o) await naze.sendMessage(room.x, { text: str, mentions: parseMention(str) }, { quoted: m })\r\n\t\t\tawait naze.sendMessage(room.o, { text: str, mentions: parseMention(str) }, { quoted: m })\r\n\t\t\tif (isTie || isWin) delete tictactoe[room.id]\r\n\t\t}\r\n\t\t\r\n\t\t// Suit PvP\r\n\t\tlet roof = Object.values(suit).find(roof => roof.id && roof.status && [roof.p, roof.p2].includes(m.sender))\r\n\t\tif (roof) {\r\n\t\t\tlet now = Date.now();\r\n\t\t\tlet win = '', tie = false;\r\n\t\t\tif (now - (roof.lastMove || now) > 3 * 60 * 1000) {\r\n\t\t\t\tm.reply('Game Suit dibatalkan karena tidak ada aktivitas selama 3 menit.');\r\n\t\t\t\tdelete suit[roof.id];\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\troof.lastMove = now;\r\n\t\t\tif (m.sender == roof.p2 && /^(acc(ept)?|terima|gas|oke?|tolak|gamau|nanti|ga(k.)?bisa|y)/i.test(m.text) && m.isGroup && roof.status == 'wait') {\r\n\t\t\t\tif (/^(tolak|gamau|nanti|n|ga(k.)?bisa)/i.test(m.text)) {\r\n\t\t\t\t\tm.reply(`@${roof.p2.split`@`[0]} menolak suit,\\nsuit dibatalkan`)\r\n\t\t\t\t\tdelete suit[roof.id]\r\n\t\t\t\t\treturn !0\r\n\t\t\t\t}\r\n\t\t\t\troof.status = 'play';\r\n\t\t\t\troof.asal = m.chat;\r\n\t\t\t\tm.reply(`Suit telah dikirimkan ke chat\\n\\n@${roof.p.split`@`[0]} dan @${roof.p2.split`@`[0]}\\n\\nSilahkan pilih suit di chat masing-masing klik https://wa.me/${botNumber.split`@`[0]}`)\r\n\t\t\t\tif (!roof.pilih) naze.sendMessage(roof.p, { text: `Silahkan pilih \\n\\nBatuüóø\\nKertasüìÑ\\nGunting‚úÇÔ∏è` }, { quoted: m })\r\n\t\t\t\tif (!roof.pilih2) naze.sendMessage(roof.p2, { text: `Silahkan pilih \\n\\nBatuüóø\\nKertasüìÑ\\nGunting‚úÇÔ∏è` }, { quoted: m })\r\n\t\t\t}\r\n\t\t\tlet jwb = m.sender == roof.p, jwb2 = m.sender == roof.p2;\r\n\t\t\tlet g = /gunting/i, b = /batu/i, k = /kertas/i, reg = /^(gunting|batu|kertas)/i;\r\n\t\t\t\r\n\t\t\tif (jwb && reg.test(m.text) && !roof.pilih && !m.isGroup) {\r\n\t\t\t\troof.pilih = reg.exec(m.text.toLowerCase())[0];\r\n\t\t\t\troof.text = m.text;\r\n\t\t\t\tm.reply(`Kamu telah memilih ${m.text} ${!roof.pilih2 ? `\\n\\nMenunggu lawan memilih` : ''}`);\r\n\t\t\t\tif (!roof.pilih2) naze.sendMessage(roof.p2, { text: '_Lawan sudah memilih_\\nSekarang giliran kamu' })\r\n\t\t\t}\r\n\t\t\tif (jwb2 && reg.test(m.text) && !roof.pilih2 && !m.isGroup) {\r\n\t\t\t\troof.pilih2 = reg.exec(m.text.toLowerCase())[0]\r\n\t\t\t\troof.text2 = m.text\r\n\t\t\t\tm.reply(`Kamu telah memilih ${m.text} ${!roof.pilih ? `\\n\\nMenunggu lawan memilih` : ''}`)\r\n\t\t\t\tif (!roof.pilih) naze.sendMessage(roof.p, { text: '_Lawan sudah memilih_\\nSekarang giliran kamu' })\r\n\t\t\t}\r\n\t\t\tlet stage = roof.pilih\r\n\t\t\tlet stage2 = roof.pilih2\r\n\t\t\tif (roof.pilih && roof.pilih2) {\r\n\t\t\t\tif (b.test(stage) && g.test(stage2)) win = roof.p\r\n\t\t\t\telse if (b.test(stage) && k.test(stage2)) win = roof.p2\r\n\t\t\t\telse if (g.test(stage) && k.test(stage2)) win = roof.p\r\n\t\t\t\telse if (g.test(stage) && b.test(stage2)) win = roof.p2\r\n\t\t\t\telse if (k.test(stage) && b.test(stage2)) win = roof.p\r\n\t\t\t\telse if (k.test(stage) && g.test(stage2)) win = roof.p2\r\n\t\t\t\telse if (stage == stage2) tie = true\r\n\t\t\t\tdb.users[roof.p == win ? roof.p : roof.p2].limit += tie ? 0 : 3\r\n\t\t\t\tdb.users[roof.p == win ? roof.p : roof.p2].money += tie ? 0 : 3000\r\n\t\t\t\tnaze.sendMessage(roof.asal, { text: `_*Hasil Suit*_${tie ? '\\nSERI' : ''}\\n\\n@${roof.p.split`@`[0]} (${roof.text}) ${tie ? '' : roof.p == win ? ` Menang \\n` : ` Kalah \\n`}\\n@${roof.p2.split`@`[0]} (${roof.text2}) ${tie ? '' : roof.p2 == win ? ` Menang \\n` : ` Kalah \\n`}\\n\\nPemenang Mendapatkan\\n*Hadiah :* Uang(3000) & Limit(3)`.trim(), mentions: [roof.p, roof.p2] }, { quoted: m })\r\n\t\t\t\tdelete suit[roof.id]\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Tebak Bomb\r\n\t\tlet pilih = 'üåÄ', bomb = 'üí£';\r\n\t\tif (m.sender in tebakbom) {\r\n\t\t\tif (!/^[1-9]|10$/i.test(body) && !isCmd && !isCreator) return !0;\r\n\t\t\tif (tebakbom[m.sender].petak[parseInt(body) - 1] === 1) return !0;\r\n\t\t\tif (tebakbom[m.sender].petak[parseInt(body) - 1] === 2) {\r\n\t\t\t\ttebakbom[m.sender].board[parseInt(body) - 1] = bomb;\r\n\t\t\t\ttebakbom[m.sender].pick++;\r\n\t\t\t\tm.react('‚ùå')\r\n\t\t\t\ttebakbom[m.sender].bomb--;\r\n\t\t\t\ttebakbom[m.sender].nyawa.pop();\r\n\t\t\t\tlet brd = tebakbom[m.sender].board;\r\n\t\t\t\tif (tebakbom[m.sender].nyawa.length < 1) {\r\n\t\t\t\t\tawait m.reply(`*GAME TELAH BERAKHIR*\\nKamu terkena bomb\\n\\n ${brd.join('')}\\n\\n*Terpilih :* ${tebakbom[m.sender].pick}\\n_Pengurangan Limit : 1_`);\r\n\t\t\t\t\tm.react('üòÇ')\r\n\t\t\t\t\tdelete tebakbom[m.sender];\r\n\t\t\t\t} else m.reply(`*PILIH ANGKA*\\n\\nKamu terkena bomb\\n ${brd.join('')}\\n\\nTerpilih: ${tebakbom[m.sender].pick}\\nSisa nyawa: ${tebakbom[m.sender].nyawa}`);\r\n\t\t\t\treturn !0;\r\n\t\t\t}\r\n\t\t\tif (tebakbom[m.sender].petak[parseInt(body) - 1] === 0) {\r\n\t\t\t\ttebakbom[m.sender].petak[parseInt(body) - 1] = 1;\r\n\t\t\t\ttebakbom[m.sender].board[parseInt(body) - 1] = pilih;\r\n\t\t\t\ttebakbom[m.sender].pick++;\r\n\t\t\t\ttebakbom[m.sender].lolos--;\r\n\t\t\t\tlet brd = tebakbom[m.sender].board;\r\n\t\t\t\tif (tebakbom[m.sender].lolos < 1) {\r\n\t\t\t\t\tdb.users[m.sender].money += 6000\r\n\t\t\t\t\tawait m.reply(`*KAMU HEBAT ‡≤†‚Å†·¥•‚Å†‡≤†*\\n\\n${brd.join('')}\\n\\n*Terpilih :* ${tebakbom[m.sender].pick}\\n*Sisa nyawa :* ${tebakbom[m.sender].nyawa}\\n*Bomb :* ${tebakbom[m.sender].bomb}\\nBonus Money üí∞ *+6000*`);\r\n\t\t\t\t\tdelete tebakbom[m.sender];\r\n\t\t\t\t} else m.reply(`*PILIH ANGKA*\\n\\n${brd.join('')}\\n\\nTerpilih : ${tebakbom[m.sender].pick}\\nSisa nyawa : ${tebakbom[m.sender].nyawa}\\nBomb : ${tebakbom[m.sender].bomb}`)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Akinator\r\n\t\tif (m.sender in akinator) {\r\n\t\t\tif (m.quoted && akinator[m.sender].key == m.quoted.id) {\r\n\t\t\t\tif (budy == '5') {\r\n\t\t\t\t\tif (akinator[m.sender]?.progress?.toFixed(0) == 0) {\r\n\t\t\t\t\t\tdelete akinator[m.sender]\r\n\t\t\t\t\t\treturn m.reply(`üéÆ Akinator Game End!\\nWith *0* Progress`)\r\n\t\t\t\t\t}\r\n\t\t\t\t\takinator[m.sender].isWin = false\r\n\t\t\t\t\tawait akinator[m.sender].cancelAnswer()\r\n\t\t\t\t\tlet { key } = await m.reply(`üéÆ Akinator Game Back :\\n\\n@${m.sender.split('@')[0]} (${akinator[m.sender].progress.toFixed(2)}) %\\n${akinator[m.sender].question}\\n\\n- 0 - Ya\\n- 1 - Tidak\\n- 2 - Tidak Tau\\n- 3 - Mungkin\\n- 4 - Mungkin Tidak\\n- 5 - ${akinator[m.sender]?.progress?.toFixed(0) == 0 ? 'End' : 'Back'}`)\r\n\t\t\t\t\takinator[m.sender].key = key.id\r\n\t\t\t\t} else if (akinator[m.sender].isWin && ['benar', 'ya'].includes(budy.toLowerCase())) {\r\n\t\t\t\t\tm.react('üéä')\r\n\t\t\t\t\tdelete akinator[m.sender]\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!isNaN(budy) && budy.match(/^[0-4]$/) && budy) {\r\n\t\t\t\t\t\tif (akinator[m.sender].isWin) {\r\n\t\t\t\t\t\t\tlet { key } = await m.reply({ image: { url: akinator[m.sender].sugestion_photo }, caption: `üéÆ Akinator Answer :\\n\\n@${m.sender.split('@')[0]}\\nDia adalah *${akinator[m.sender].sugestion_name}*\\n_${akinator[m.sender].sugestion_desc}_\\n\\n- 5 - Back\\n- *Ya* (untuk keluar dari sesi)`, contextInfo: { mentionedJid: [m.sender] }});\r\n\t\t\t\t\t\t\takinator[m.sender].key = key.id\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tawait akinator[m.sender].answer(budy)\r\n\t\t\t\t\t\t\tif (akinator[m.sender].isWin) {\r\n\t\t\t\t\t\t\t\tlet { key } = await m.reply({ image: { url: akinator[m.sender].sugestion_photo }, caption: `üéÆ Akinator Answer :\\n\\n@${m.sender.split('@')[0]}\\nDia adalah *${akinator[m.sender].sugestion_name}*\\n_${akinator[m.sender].sugestion_desc}_\\n\\n- 5 - Back\\n- *Ya* (untuk keluar dari sesi)`, contextInfo: { mentionedJid: [m.sender] }});\r\n\t\t\t\t\t\t\t\takinator[m.sender].key = key.id\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlet { key } = await m.reply(`üéÆ Akinator Game :\\n\\n@${m.sender.split('@')[0]} (${akinator[m.sender].progress.toFixed(2)}) %\\n${akinator[m.sender].question}\\n\\n- 0 - Ya\\n- 1 - Tidak\\n- 2 - Tidak Tau\\n- 3 - Mungkin\\n- 4 - Mungkin Tidak\\n- 5 - Back`)\r\n\t\t\t\t\t\t\t\takinator[m.sender].key = key.id\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Game\r\n\t\tconst games = { tebaklirik, tekateki, tebaklagu, tebakkata, kuismath, susunkata, tebakkimia, caklontong, tebakangka, tebaknegara, tebakgambar, tebakbendera }\r\n\t\tfor (let gameName in games) {\r\n\t\t\tlet game = games[gameName];\r\n\t\t\tlet id = iGame(game, m.chat);\r\n\t\t\tif ((!isCmd || isCreator) && m.quoted && id == m.quoted.id) {\r\n\t\t\t\tif (game[m.chat + id]?.jawaban) {\r\n\t\t\t\t\tif (gameName == 'kuismath') {\r\n\t\t\t\t\t\tjawaban = game[m.chat + id].jawaban\r\n\t\t\t\t\t\tconst difficultyMap = { 'noob': 1, 'easy': 1.5, 'medium': 2.5, 'hard': 4, 'extreme': 5, 'impossible': 6, 'impossible2': 7 };\r\n\t\t\t\t\t\tlet randMoney = difficultyMap[kuismath[m.chat + id].mode]\r\n\t\t\t\t\t\tif (!isNaN(budy)) {\r\n\t\t\t\t\t\t\tif (budy.toLowerCase() == jawaban) {\r\n\t\t\t\t\t\t\t\tdb.users[m.sender].money += randMoney * 1000\r\n\t\t\t\t\t\t\t\tawait m.reply(`Jawaban Benar üéâ\\nBonus Money üí∞ *+${randMoney * 1000}*`)\r\n\t\t\t\t\t\t\t\tdelete kuismath[m.chat + id]\r\n\t\t\t\t\t\t\t} else m.reply('*Jawaban Salah!*')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tjawaban = game[m.chat + id].jawaban\r\n\t\t\t\t\t\tlet jawabBenar = /tekateki|tebaklirik|tebaklagu|tebakkata|tebaknegara|tebakbendera/.test(gameName) ? (similarity(budy.toLowerCase(), jawaban) >= almost) : (budy.toLowerCase() == jawaban)\r\n\t\t\t\t\t\tlet bonus = gameName == 'caklontong' ? 9999 : gameName == 'tebaklirik' ? 4299 : gameName == 'susunkata' ? 2989 : 3499\r\n\t\t\t\t\t\tif (jawabBenar) {\r\n\t\t\t\t\t\t\tdb.users[m.sender].money += bonus * 1\r\n\t\t\t\t\t\t\tawait m.reply(`Jawaban Benar üéâ\\nBonus Money üí∞ *+${bonus}*`)\r\n\t\t\t\t\t\t\tdelete game[m.chat + id]\r\n\t\t\t\t\t\t} else m.reply('*Jawaban Salah!*')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Family 100\r\n\t\tif (m.chat in family100) {\r\n\t\t\tif (m.quoted && m.quoted.id == family100[m.chat].id && !isCmd) {\r\n\t\t\t\tlet room = family100[m.chat]\r\n\t\t\t\tlet teks = budy.toLowerCase().replace(/[^\\w\\s\\-]+/, '')\r\n\t\t\t\tlet isSurender = /^((me)?nyerah|surr?ender)$/i.test(teks)\r\n\t\t\t\tif (!isSurender) {\r\n\t\t\t\t\tlet index = room.jawaban.findIndex(v => v.toLowerCase().replace(/[^\\w\\s\\-]+/, '') === teks)\r\n\t\t\t\t\tif (room.terjawab[index]) return !0\r\n\t\t\t\t\troom.terjawab[index] = m.sender\r\n\t\t\t\t}\r\n\t\t\t\tlet isWin = room.terjawab.length === room.terjawab.filter(v => v).length\r\n\t\t\t\tlet caption = `Jawablah Pertanyaan Berikut :\\n${room.soal}\\n\\n\\nTerdapat ${room.jawaban.length} Jawaban ${room.jawaban.find(v => v.includes(' ')) ? `(beberapa Jawaban Terdapat Spasi)` : ''}\\n${isWin ? `Semua Jawaban Terjawab` : isSurender ? 'Menyerah!' : ''}\\n${Array.from(room.jawaban, (jawaban, index) => { return isSurender || room.terjawab[index] ? `(${index + 1}) ${jawaban} ${room.terjawab[index] ? '@' + room.terjawab[index].split('@')[0] : ''}`.trim() : false }).filter(v => v).join('\\n')}\\n${isSurender ? '' : `Perfect Player`}`.trim()\r\n\t\t\t\tm.reply(caption)\r\n\t\t\t\tif (isWin || isSurender) delete family100[m.chat]\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Chess\r\n\t\tif ((!isCmd || isCreator) && (m.sender in chess)) {\r\n\t\t\tconst game = chess[m.sender];\r\n\t\t\tif (m.quoted && game.id == m.quoted.id && game.turn == m.sender && game.botMode) {\r\n\t\t\t\tif (!(game instanceof Chess)) {\r\n\t\t\t\t\tchess[m.sender] = Object.assign(new Chess(game.fen), game);\r\n\t\t\t\t}\r\n\t\t\t\tif (game.isCheckmate() || game.isDraw() || game.isGameOver()) {\r\n\t\t\t\t\tconst status = game.isCheckmate() ? 'Checkmate' : game.isDraw() ? 'Draw' : 'Game Over';\r\n\t\t\t\t\tdelete chess[m.sender];\r\n\t\t\t\t\treturn m.reply(`‚ôüGame ${status}\\nPermainan dihentikan`);\r\n\t\t\t\t}\r\n\t\t\t\tconst [from, to] = budy.toLowerCase().split(' ');\r\n\t\t\t\tif (!from || !to || from.length !== 2 || to.length !== 2) return m.reply('Format salah! Gunakan: e2 e4');\r\n\t\t\t\ttry {\r\n\t\t\t\t\tgame.move({ from, to });\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\treturn m.reply('Langkah Tidak Valid!')\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (game.isGameOver()) {\r\n\t\t\t\t\tdelete chess[m.sender];\r\n\t\t\t\t\treturn m.reply(`‚ôüPermainan Selesai\\nPemenang: @${m.sender.split('@')[0]}`);\r\n\t\t\t\t}\r\n\t\t\t\tconst moves = game.moves({ verbose: true });\r\n\t\t\t\tconst botMove = moves[Math.floor(Math.random() * moves.length)];\r\n\t\t\t\tgame.move(botMove);\r\n\t\t\t\tgame._fen = game.fen();\r\n\t\t\t\tgame.time = Date.now();\r\n\t\t\t\t\r\n\t\t\t\tif (game.isGameOver()) {\r\n\t\t\t\t\tdelete chess[m.sender];\r\n\t\t\t\t\treturn m.reply(`‚ôüPermainan Selesai\\nPemenang: BOT`);\r\n\t\t\t\t}\r\n\t\t\t\tconst encodedFen = encodeURI(game._fen);\r\n\t\t\t\tconst boardUrls = [`https://www.chess.com/dynboard?fen=${encodedFen}&size=3&coordinates=inside`,`https://www.chess.com/dynboard?fen=${encodedFen}&board=graffiti&piece=graffiti&size=3&coordinates=inside`,`https://chessboardimage.com/${encodedFen}.png`,`https://backscattering.de/web-boardimage/board.png?fen=${encodedFen}&coordinates=true&size=765`,`https://fen2image.chessvision.ai/${encodedFen}/`];\r\n\t\t\t\tfor (let url of boardUrls) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tconst { data } = await axios.get(url, { responseType: 'arraybuffer' });\r\n\t\t\t\t\t\tlet { key } = await m.reply({ image: data, caption: `‚ôüÔ∏èCHESS GAME (vs BOT)\\n\\nLangkahmu: ${from} ‚Üí ${to}\\nLangkah bot: ${botMove.from} ‚Üí ${botMove.to}\\n\\nGiliranmu berikutnya!\\nExample: e2 e4`, mentions: [m.sender] });\r\n\t\t\t\t\t\tgame.id = key.id;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} catch (e) {}\r\n\t\t\t\t}\r\n\t\t\t} else if (game.time && (Date.now() - game.time >= 3600000)) {\r\n\t\t\t\tdelete chess[m.sender];\r\n\t\t\t\treturn m.reply(`‚ôüWaktu Habis!\\nPermainan dihentikan`);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (m.isGroup && (!isCmd || isCreator) && (m.chat in chess)) {\r\n\t\t\tif (m.quoted && chess[m.chat].id == m.quoted.id && [chess[m.chat].player1, chess[m.chat].player2].includes(m.sender)) {\r\n\t\t\t\tif (!(chess[m.chat] instanceof Chess)) {\r\n\t\t\t\t\tchess[m.chat] = Object.assign(new Chess(chess[m.chat].fen), chess[m.chat]);\r\n\t\t\t\t}\r\n\t\t\t\tif (chess[m.chat].isCheckmate() || chess[m.chat].isDraw() || chess[m.chat].isGameOver()) {\r\n\t\t\t\t\tconst status = chess[m.chat].isCheckmate() ? 'Checkmate' : chess[m.chat].isDraw() ? 'Draw' : 'Game Over';\r\n\t\t\t\t\tdelete chess[m.chat];\r\n\t\t\t\t\treturn m.reply(`‚ôüGame ${status}\\nPermainan dihentikan`);\r\n\t\t\t\t}\r\n\t\t\t\tconst [from, to] = budy.toLowerCase().split(' ');\r\n\t\t\t\tif (!from || !to || from.length !== 2 || to.length !== 2) return m.reply('Format salah! Gunakan format seperti: e2 e4');\r\n\t\t\t\tif ([chess[m.chat].player1, chess[m.chat].player2].includes(m.sender) && chess[m.chat].turn === m.sender) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tchess[m.chat].move({ from, to });\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn m.reply('Langkah Tidak Valid!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchess[m.chat].time = Date.now();\r\n\t\t\t\t\tchess[m.chat]._fen = chess[m.chat].fen();\r\n\t\t\t\t\tconst isPlayer2 = chess[m.chat].player2 === m.sender\r\n\t\t\t\t\tconst nextPlayer = isPlayer2 ? chess[m.chat].player1 : chess[m.chat].player2;\r\n\t\t\t\t\tconst encodedFen = encodeURI(chess[m.chat]._fen);\r\n\t\t\t\t\tconst boardUrls = [`https://www.chess.com/dynboard?fen=${encodedFen}&size=3&coordinates=inside${!isPlayer2 ? '&flip=true' : ''}`,`https://www.chess.com/dynboard?fen=${encodedFen}&board=graffiti&piece=graffiti&size=3&coordinates=inside${!isPlayer2 ? '&flip=true' : ''}`,`https://chessboardimage.com/${encodedFen}${!isPlayer2 ? '-flip' : ''}.png`,`https://backscattering.de/web-boardimage/board.png?fen=${encodedFen}&coordinates=true&size=765${!isPlayer2 ? '&orientation=black' : ''}`,`https://fen2image.chessvision.ai/${encodedFen}/${!isPlayer2 ? '?pov=black' : ''}`];\r\n\t\t\t\t\tfor (let url of boardUrls) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tconst { data } = await axios.get(url, { responseType: 'arraybuffer' });\r\n\t\t\t\t\t\t\tlet { key } = await m.reply({ image: data, caption: `‚ôüÔ∏èCHESS GAME\\n\\nGiliran: @${nextPlayer.split('@')[0]}\\n\\nReply Pesan Ini untuk lanjut bermain!\\nExample: from to -> b1 c3`, mentions: [nextPlayer] });\r\n\t\t\t\t\t\t\tchess[m.chat].turn = nextPlayer\r\n\t\t\t\t\t\t\tchess[m.chat].id = key.id;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} catch (e) {}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (chess[m.chat].time && (Date.now() - chess[m.chat].time >= 3600000)) {\r\n\t\t\t\tdelete chess[m.chat]\r\n\t\t\t\treturn m.reply(`‚ôüWaktu Habis!\\nPermainan dihentikan`)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Ular Tangga\r\n\t\tif (m.isGroup && (!isCmd || isCreator) && (m.chat in ulartangga)) {\r\n\t\t\tif (m.quoted && ulartangga[m.chat].id == m.quoted.id) {\r\n\t\t\t\tif (!(ulartangga[m.chat] instanceof SnakeLadder)) {\r\n\t\t\t\t\tulartangga[m.chat] = Object.assign(new SnakeLadder(ulartangga[m.chat]), ulartangga[m.chat]);\r\n\t\t\t\t}\r\n\t\t\t\tif (/^(roll|kocok)/i.test(budy.toLowerCase())) {\r\n\t\t\t\t\tconst player = ulartangga[m.chat].players.findIndex(a => a.id == m.sender)\r\n\t\t\t\t\tif (ulartangga[m.chat].turn !== player) return m.reply('Bukan Giliranmu!')\r\n\t\t\t\t\tconst roll = ulartangga[m.chat].rollDice();\r\n\t\t\t\t\tawait m.reply(`https://raw.githubusercontent.com/nazedev/database/master/games/images/dice/roll-${roll}.webp`);\r\n\t\t\t\t\tulartangga[m.chat].nextTurn();\r\n\t\t\t\t\tulartangga[m.chat].players[player].move += roll\r\n\t\t\t\t\tif (ulartangga[m.chat].players[player].move > 100) ulartangga[m.chat].players[player].move = 100 - (ulartangga[m.chat].players[player].move - 100);\r\n\t\t\t\t\tlet teks = `üêçü™úWarna: ${['Merah','Biru Muda','Kuning','Hijau','Ungu','Jingga','Biru Tua','Putih'][player]} -> ${ulartangga[m.chat].players[player].move}\\n`;\r\n\t\t\t\t\tif(Object.keys(ulartangga[m.chat].map.move).includes(ulartangga[m.chat].players[player].move.toString())) {\r\n\t\t\t\t\t\tteks += ulartangga[m.chat].players[player].move > ulartangga[m.chat].map.move[ulartangga[m.chat].players[player].move] ? 'Kamu Termakan Ular!\\n' : 'Kamu Naik Tangga\\n'\r\n\t\t\t\t\t\tulartangga[m.chat].players[player].move = ulartangga[m.chat].map.move[ulartangga[m.chat].players[player].move];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst newMap = await ulartangga[m.chat].drawBoard(ulartangga[m.chat].map.url, ulartangga[m.chat].players);\r\n\t\t\t\t\tif (ulartangga[m.chat].players[player].move === 100) {\r\n\t\t\t\t\t\tteks += `@${m.sender.split('@')[0]} Menang\\nHadiah:\\n- Limit + 50\\n- Money + 100.000`;\r\n\t\t\t\t\t\taddLimit(50, m.sender, db);\r\n\t\t\t\t\t\taddMoney(100000, m.sender, db);\r\n\t\t\t\t\t\tdelete ulartangga[m.chat];\r\n\t\t\t\t\t\treturn m.reply({ image: newMap, caption: teks, mentions: [m.sender] });\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet { key } = await m.reply({ image: newMap, caption: teks + `Giliran: @${ulartangga[m.chat].players[ulartangga[m.chat].turn].id.split('@')[0]}`, mentions: [m.sender, ulartangga[m.chat].players[ulartangga[m.chat].turn].id] });\r\n\t\t\t\t\tulartangga[m.chat].id = key.id;\r\n\t\t\t\t} else m.reply('Example: roll/kocok')\r\n\t\t\t} else if (ulartangga[m.chat].time && (Date.now() - ulartangga[m.chat].time >= 7200000)) {\r\n\t\t\t\tdelete ulartangga[m.chat]\r\n\t\t\t\treturn m.reply(`üêçü™úWaktu Habis!\\nPermainan dihentikan`)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Menfes & Room Ai\r\n\t\tif (!m.isGroup && (!isCmd || isCreator)) {\r\n\t\t\tif (menfes[m.sender] && m.key.remoteJid !== 'status@broadcast' && m.msg) {\r\n\t\t\t\tm.react('‚úà');\r\n\t\t\t\tm.msg.contextInfo = { isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: `*Pesan Dari ${menfes[m.sender].nama ? menfes[m.sender].nama : 'Seseorang'}*`}, key: { remoteJid: '0@s.whatsapp.net', fromMe: false, participant: '0@s.whatsapp.net' }}\r\n\t\t\t\tconst pesan = m.type === 'conversation' ? { extendedTextMessage: { text: m.msg, contextInfo: { isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: `*Pesan Dari ${menfes[m.sender].nama ? menfes[m.sender].nama : 'Seseorang'}*`}, key: { remoteJid: '0@s.whatsapp.net', fromMe: false, participant: '0@s.whatsapp.net' }}}} : { [m.type]: m.msg }\r\n\t\t\t\tawait naze.relayMessage(menfes[m.sender].tujuan, pesan, {});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (chat_ai[m.sender] && m.key.remoteJid !== 'status@broadcast') {\r\n\t\t\t\tif (!/^(del((room|c|hat)ai)|>|<$)$/i.test(command) && budy) {\r\n\t\t\t\t\tchat_ai[m.sender].push({ role: 'user', content: budy });\r\n\t\t\t\t\tlet hasil;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\thasil = await gptLogic(chat_ai[m.sender], budy)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\thasil = await yanzGpt(chat_ai[m.sender])\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\thasil = 'Gagal Mengambil Respon, Website sedang gangguan'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst response = hasil?.choices?.[0]?.message?.content || hasil || 'Maaf, saya tidak mengerti.';\r\n\t\t\t\t\tchat_ai[m.sender].push({ role: 'assistant', content: response });\r\n\t\t\t\t\tawait m.reply(response)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Afk\r\n\t\tlet mentionUser = [...new Set([...(m.mentionedJid || []), ...(m.quoted ? [m.quoted.sender] : [])])]\r\n\t\tfor (let jid of mentionUser) {\r\n\t\t\tlet user = db.users[jid]\r\n\t\t\tif (!user) continue\r\n\t\t\tlet afkTime = user.afkTime\r\n\t\t\tif (!afkTime || afkTime < 0) continue\r\n\t\t\tlet reason = user.afkReason || ''\r\n\t\t\tm.reply(`Jangan tag dia!\\nDia sedang AFK ${reason ? 'dengan alasan ' + reason : 'tanpa alasan'}\\nSelama ${clockString(new Date - afkTime)}`.trim())\r\n\t\t}\r\n\t\tif (db.users[m.sender].afkTime > -1) {\r\n\t\t\tlet user = db.users[m.sender]\r\n\t\t\tm.reply(`@${m.sender.split('@')[0]} berhenti AFK${user.afkReason ? ' setelah ' + user.afkReason : ''}\\nSelama ${clockString(new Date - user.afkTime)}`)\r\n\t\t\tuser.afkTime = -1\r\n\t\t\tuser.afkReason = ''\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tswitch(fileSha256 || command) {\r\n\t\t\t// Tempat Add Case\r\n\t\t\tcase '19rujxl1e': {\r\n\t\t\t\tconsole.log('.')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Owner Menu\r\n\t\t\tcase 'shutdown': case 'off': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tm.reply(`*[BOT] Process Shutdown...*`).then(() => {\r\n\t\t\t\t\tprocess.exit(0)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setbio': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply('Mana text nya?')\r\n\t\t\t\tnaze.setStatus(q)\r\n\t\t\t\tm.reply(`*Bio telah di ganti menjadi ${q}*`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setppbot': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!/image/.test(quoted.type)) return m.reply(`Reply Image Dengan Caption ${prefix + command}`)\r\n\t\t\t\tlet media = await naze.downloadAndSaveMediaMessage(quoted, 'ppbot.jpeg')\r\n\t\t\t\tif (text.length > 0) {\r\n\t\t\t\t\tlet { img } = await generateProfilePicture(media)\r\n\t\t\t\t\tawait naze.query({\r\n\t\t\t\t\t\ttag: 'iq',\r\n\t\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\t\tto: '@s.whatsapp.net',\r\n\t\t\t\t\t\t\ttype: 'set',\r\n\t\t\t\t\t\t\txmlns: 'w:profile:picture'\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tcontent: [{ tag: 'picture', attrs: { type: 'image' }, content: img }]\r\n\t\t\t\t\t})\r\n\t\t\t\t\tawait fs.unlinkSync(media)\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait naze.updateProfilePicture(botNumber, { url: media })\r\n\t\t\t\t\tawait fs.unlinkSync(media)\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delppbot': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tawait naze.removeProfilePicture(naze.user.id)\r\n\t\t\t\tm.reply('Sukses')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'join': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply('Masukkan Link Group!')\r\n\t\t\t\tif (!isUrl(args[0]) && !args[0].includes('whatsapp.com')) return m.reply('Link Invalid!')\r\n\t\t\t\tconst result = args[0].split('https://chat.whatsapp.com/')[1]\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tawait naze.groupAcceptInvite(result).catch((res) => {\r\n\t\t\t\t\tif (res.data == 400) return m.reply('Grup Tidak Di Temukan‚ùó');\r\n\t\t\t\t\tif (res.data == 401) return m.reply('Bot Di Kick Dari Grup Tersebut‚ùó');\r\n\t\t\t\t\tif (res.data == 409) return m.reply('Bot Sudah Join Di Grup Tersebut‚ùó');\r\n\t\t\t\t\tif (res.data == 410) return m.reply('Url Grup Telah Di Setel Ulang‚ùó');\r\n\t\t\t\t\tif (res.data == 500) return m.reply('Grup Penuh‚ùó');\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'leave': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tawait naze.groupLeave(m.chat).then(() => naze.sendFromOwner(ownerNumber, 'Sukses Keluar Dari Grup', m, { contextInfo: { isForwarded: true }})).catch(e => {});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'clearchat': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tawait naze.chatModify({ delete: true, lastMessages: [{ key: m.key, messageTimestamp: m.timestamp }] }, m.chat).catch((e) => m.reply('Gagal Menghapus Chat!'))\r\n\t\t\t\tm.reply('Sukses Membersihkan Pesan')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'getmsgstore': case 'storemsg': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tlet [teks1, teks2] = text.split`|`\r\n\t\t\t\tif (teks1 && teks2) {\r\n\t\t\t\t\tconst msgnya = await store.loadMessage(teks1, teks2)\r\n\t\t\t\t\tif (msgnya?.message) await naze.relayMessage(m.chat, msgnya.message, {})\r\n\t\t\t\t\telse m.reply('Pesan Tidak Ditemukan!')\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 123xxx@g.us|3EB0xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'blokir': case 'block': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = m.isGroup ? (text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender) : m.chat\r\n\t\t\t\t\tawait naze.updateBlockStatus(numbersOnly, 'block').then((a) => m.reply(mess.done)).catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listblock': {\r\n\t\t\t\tlet anu = await naze.fetchBlocklist()\r\n\t\t\t\tm.reply(`Total Block : ${anu.length}\\n` + anu.map(v => '‚Ä¢ ' + v.replace(/@.+/, '')).join`\\n`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'openblokir': case 'unblokir': case 'openblock': case 'unblock': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = m.isGroup ? (text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender) : m.chat\r\n\t\t\t\t\tawait naze.updateBlockStatus(numbersOnly, 'unblock').then((a) => m.reply(mess.done)).catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ban': case 'banned': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Kirim/tag Nomernya!\\nExample:\\n${prefix + command} 62xxx`)\r\n\t\t\t\tconst nmrnya = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\tif (db.users[nmrnya] && !db.users[nmrnya].ban) {\r\n\t\t\t\t\tdb.users[nmrnya].ban = true\r\n\t\t\t\t\tm.reply('User Telah Di ban!')\r\n\t\t\t\t} else m.reply('User tidak terdaftar di database!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'unban': case 'unbanned': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Kirim/tag Nomernya!\\nExample:\\n${prefix + command} 62xxx`)\r\n\t\t\t\tconst nmrnya = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\tif (db.users[nmrnya] && db.users[nmrnya].ban) {\r\n\t\t\t\t\tdb.users[nmrnya].ban = false\r\n\t\t\t\t\tm.reply('User Telah Di unban!')\r\n\t\t\t\t} else m.reply('User tidak terdaftar di database!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'mute': case 'unmute': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (command == 'mute') {\r\n\t\t\t\t\tdb.groups[m.chat].mute = true\r\n\t\t\t\t\tm.reply('Bot Telah Di Mute Di Grup Ini!')\r\n\t\t\t\t} else if (command == 'unmute') {\r\n\t\t\t\t\tdb.groups[m.chat].mute = false\r\n\t\t\t\t\tm.reply('Sukses Unmute')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'addowner': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text || isNaN(text)) return m.reply(`Kirim/tag Nomernya!\\nExample:\\n${prefix + command} 62xxx`)\r\n\t\t\t\tconst nmrnya = text.replace(/[^0-9]/g, '')\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tif (db?.set?.[botNumber]?.owner) {\r\n\t\t\t\t\tif (db.set[botNumber].owner.find(a => a.id === nmrnya)) return m.reply('Nomer Tersebut Sudah Ada Di Owner!')\r\n\t\t\t\t\tdb.set[botNumber].owner.push({ id: nmrnya, lock: false });\r\n\t\t\t\t}\r\n\t\t\t\tm.reply('Sukses Add Owner')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delowner': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text || isNaN(text)) return m.reply(`Kirim/tag Nomernya!\\nExample:\\n${prefix + command} 62xxx`)\r\n\t\t\t\tconst nmrnya = text.replace(/[^0-9]/g, '')\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tlet list = db.set[botNumber].owner\r\n\t\t\t\tconst index = list.findIndex(o => o.id === nmrnya);\r\n\t\t\t\tif (index === -1) return m.reply('Owner tidak ditemukan di daftar!')\r\n\t\t\t\tlist.splice(index, 1)\r\n\t\t\t\tm.reply('Sukses Delete Owner')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'adduang': case 'addmoney': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!args[0] || !args[1] || isNaN(args[1])) return m.reply(`Kirim/tag Nomernya!\\nExample:\\n${prefix + command} 62xxx 1000`)\r\n\t\t\t\tif (args[1].length > 15) return m.reply('Jumlah Money Maksimal 15 digit angka!')\r\n\t\t\t\tconst nmrnya = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tif (db.users[nmrnya] && db.users[nmrnya].money >= 0) {\r\n\t\t\t\t\taddMoney(args[1], nmrnya, db)\r\n\t\t\t\t\tm.reply('Sukses Add Uang')\r\n\t\t\t\t} else m.reply('User tidak terdaftar di database!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'addlimit': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!args[0] || !args[1] || isNaN(args[1])) return m.reply(`Kirim/tag Nomernya!\\nExample:\\n${prefix + command} 62xxx 10`)\r\n\t\t\t\tif (args[1].length > 10) return m.reply('Jumlah Limit Maksimal 10 digit angka!')\r\n\t\t\t\tconst nmrnya = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tif (db.users[nmrnya] && db.users[nmrnya].limit >= 0) {\r\n\t\t\t\t\taddLimit(args[1], nmrnya, db)\r\n\t\t\t\t\tm.reply('Sukses Add limit')\r\n\t\t\t\t} else m.reply('User tidak terdaftar di database!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listpc': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tlet anu = Object.keys(store.messages).filter(a => a.endsWith('.net') || a.endsWith('lid'));\r\n\t\t\t\tlet teks = `‚óè *LIST PERSONAL CHAT*\\n\\nTotal Chat : ${anu.length} Chat\\n\\n`\r\n\t\t\t\tif (anu.length === 0) return m.reply(teks)\r\n\t\t\t\tfor (let i of anu) {\r\n\t\t\t\t\tif (store.messages?.[i]?.array?.length) {\r\n\t\t\t\t\t\tlet nama = naze.getName(m.sender)\r\n\t\t\t\t\t\tteks += `${setv} *Nama :* ${nama}\\n${setv} *User :* @${i.split('@')[0]}\\n${setv} *Chat :* https://wa.me/${i.split('@')[0]}\\n\\n=====================\\n\\n`\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tawait m.reply(teks)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listgc': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tlet anu = Object.keys(store.messages).filter(a => a.endsWith('@g.us'));\r\n\t\t\t\tlet teks = `‚óè *LIST GROUP CHAT*\\n\\nTotal Group : ${anu.length} Group\\n\\n`\r\n\t\t\t\tif (anu.length === 0) return m.reply(teks)\r\n\t\t\t\tfor (let i of anu) {\r\n\t\t\t\t\tlet metadata;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tmetadata = store.groupMetadata[i]\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tmetadata = (store.groupMetadata[i] = await naze.groupMetadata(i).catch(e => ({})))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tteks += metadata?.subject ? `${setv} *Nama :* ${metadata.subject}\\n${setv} *Admin :* ${metadata.owner ? `@${metadata.owner.split('@')[0]}` : '-' }\\n${setv} *ID :* ${metadata.id}\\n${setv} *Dibuat :* ${moment(metadata.creation * 1000).tz('Asia/Jakarta').format('DD/MM/YYYY HH:mm:ss')}\\n${setv} *Member :* ${metadata.participants.length}\\n\\n=====================\\n\\n` : ''\r\n\t\t\t\t}\r\n\t\t\t\tawait m.reply(teks)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'creategc': case 'buatgc': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Example:\\n${prefix + command} *Nama Gc*`)\r\n\t\t\t\tlet group = await naze.groupCreate(q, [m.sender])\r\n\t\t\t\tlet res = await naze.groupInviteCode(group.id)\r\n\t\t\t\tawait m.reply(`*Link Group :* *https://chat.whatsapp.com/${res}*\\n\\n*Nama Group :* *${group.subject}*\\nSegera Masuk dalam 30 detik\\nAgar menjadi Admin`, { detectLink: true })\r\n\t\t\t\tawait sleep(30000)\r\n\t\t\t\tawait naze.groupParticipantsUpdate(group.id, [m.sender], 'promote').catch(e => {});\r\n\t\t\t\tawait naze.sendMessage(group.id, { text: 'Done' })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'addsewa': case 'sewa': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Example:\\n${prefix + command} https://chat.whatsapp.com/xxx | waktu\\n${prefix + command} https://chat.whatsapp.com/xxx | 30 hari`)\r\n\t\t\t\tlet [teks1, teks2] = text.split('|')?.map(x => x.trim()) || [];\r\n\t\t\t\tif (!isUrl(teks1) && !teks1.includes('chat.whatsapp.com/')) return m.reply('Link Invalid!')\r\n\t\t\t\tconst urlny = teks1.split('chat.whatsapp.com/')[1]\r\n\t\t\t\ttry {\r\n\t\t\t\t\tawait naze.groupAcceptInvite(urlny)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tif (e.data == 400) return m.reply('Grup Tidak Di Temukan‚ùó');\r\n\t\t\t\t\tif (e.data == 401) return m.reply('Bot Di Kick Dari Grup Tersebut‚ùó');\r\n\t\t\t\t\tif (e.data == 410) return m.reply('Url Grup Telah Di Setel Ulang‚ùó');\r\n\t\t\t\t\tif (e.data == 500) return m.reply('Grup Penuh‚ùó');\r\n\t\t\t\t}\r\n\t\t\t\tawait naze.groupGetInviteInfo(urlny).then(a => {\r\n\t\t\t\t\taddExpired({ url: urlny, expired: (teks2?.replace(/[^0-9]/g, '') || 30) + 'd', ...a }, sewa)\r\n\t\t\t\t\tm.reply('Sukses Menambahkan Sewa Selama ' + (teks2?.replace(/[^0-9]/g, '') || 30) + ' hari\\nOtomatis Keluar Saat Waktu Habis!')\r\n\t\t\t\t}).catch(e => m.reply('Gagal Menambahkan Sewa!'))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delsewa': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Example:\\n${prefix + command} https://chat.whatsapp.com/xxxx\\n Or \\n${prefix + command} id_group@g.us`)\r\n\t\t\t\tconst urlny = text.split('chat.whatsapp.com/')[1].trim()\r\n\t\t\t\tif (checkStatus(urlny, sewa)) {\r\n\t\t\t\t\tawait m.reply('Sukses Menghapus Sewa')\r\n\t\t\t\t\tawait naze.groupLeave(getStatus(urlny, sewa).id).catch(e => {});\r\n\t\t\t\t\tsewa.splice(getPosition(urlny, sewa), 1);\r\n\t\t\t\t} else m.reply(`${text} Tidak Terdaftar Di Database\\nExample:\\n${prefix + command} https://chat.whatsapp.com/xxxx\\n Or \\n${prefix + command} id_group@g.us`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listsewa': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tlet txt = `*------„Äå LIST SEWA „Äç------*\\n\\n`\r\n\t\t\t\tfor (let s of sewa) {\r\n\t\t\t\t\ttxt += `‚û∏ *ID*: ${s.id}\\n‚û∏ *Url*: https://chat.whatsapp.com/${s.url}\\n‚û∏ *Expired*: ${formatDate(s.expired)}\\n\\n`\r\n\t\t\t\t}\r\n\t\t\t\tm.reply(txt)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'addpr': case 'addprem': case 'addpremium': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Example:\\n${prefix + command} @tag|waktu\\n${prefix + command} @${m.sender.split('@')[0]}|30 hari`)\r\n\t\t\t\tlet [teks1, teks2] = text.split('|').map(x => x.trim());\r\n\t\t\t\tconst nmrnya = teks1.replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tif (teks2) {\r\n\t\t\t\t\tif (db.users[nmrnya] && db.users[nmrnya].limit >= 0) {\r\n\t\t\t\t\t\taddExpired({ id: nmrnya, expired: teks2.replace(/[^0-9]/g, '') + 'd' }, premium);\r\n\t\t\t\t\t\tm.reply(`Sukses ${command} @${nmrnya.split('@')[0]} Selama ${teks2}`)\r\n\t\t\t\t\t\tdb.users[nmrnya].limit += db.users[nmrnya].vip ? limit.vip : limit.premium\r\n\t\t\t\t\t\tdb.users[nmrnya].money += db.users[nmrnya].vip ? money.vip : money.premium\r\n\t\t\t\t\t} else m.reply('Nomer tidak terdaftar di BOT !\\nPastikan Nomer Pernah Menggunakan BOT!')\r\n\t\t\t\t} else m.reply(`Masukkan waktunya!\\Example:\\n${prefix + command} @tag|waktu\\n${prefix + command} @${m.sender.split('@')[0]}|30d\\n_d = day_`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delpr': case 'delprem': case 'delpremium': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply(`Example:\\n${prefix + command} @tag`)\r\n\t\t\t\tconst nmrnya = text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\tif (db.users[nmrnya] && db.users[nmrnya].limit >= 0) {\r\n\t\t\t\t\tif (checkStatus(nmrnya, premium)) {\r\n\t\t\t\t\t\tpremium.splice(getPosition(nmrnya, premium), 1);\r\n\t\t\t\t\t\tm.reply(`Sukses ${command} @${nmrnya.split('@')[0]}`)\r\n\t\t\t\t\t\tdb.users[nmrnya].limit += db.users[nmrnya].vip ? limit.vip : limit.free\r\n\t\t\t\t\t\tdb.users[nmrnya].money += db.users[nmrnya].vip ? money.vip : money.free\r\n\t\t\t\t\t} else m.reply(`User @${nmrnya.split('@')[0]} Bukan Premium‚ùó`)\r\n\t\t\t\t} else m.reply('Nomer tidak terdaftar di BOT !')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listpr': case 'listprem': case 'listpremium': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tlet txt = `*------„Äå LIST PREMIUM „Äç------*\\n\\n`\r\n\t\t\t\tfor (let userprem of premium) {\r\n\t\t\t\t\ttxt += `‚û∏ *Nomer*: @${userprem.id.split('@')[0]}\\n‚û∏ *Limit*: ${db.users[userprem.id].limit}\\n‚û∏ *Money*: ${db.users[userprem.id].money.toLocaleString('id-ID')}\\n‚û∏ *Expired*: ${formatDate(userprem.expired)}\\n\\n`\r\n\t\t\t\t}\r\n\t\t\t\tm.reply(txt)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'upsw': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tconst statusJidList = Object.keys(db.users)\r\n\t\t\t\tconst backgroundColor = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (quoted.isMedia) {\r\n\t\t\t\t\t\tif (/image|video/.test(quoted.mime)) {\r\n\t\t\t\t\t\t\tawait naze.sendMessage('status@broadcast', {\r\n\t\t\t\t\t\t\t\t[`${quoted.mime.split('/')[0]}`]: await quoted.download(),\r\n\t\t\t\t\t\t\t\tcaption: text || m.quoted?.body || ''\r\n\t\t\t\t\t\t\t}, { statusJidList, broadcast: true })\r\n\t\t\t\t\t\t\tm.react('‚úÖ')\r\n\t\t\t\t\t\t} else if (/audio/.test(quoted.mime)) {\r\n\t\t\t\t\t\t\tawait naze.sendMessage('status@broadcast', {\r\n\t\t\t\t\t\t\t\taudio: await quoted.download(),\r\n\t\t\t\t\t\t\t\tmimetype: 'audio/mp4',\r\n\t\t\t\t\t\t\t\tptt: true\r\n\t\t\t\t\t\t\t}, { backgroundColor, statusJidList, broadcast: true })\r\n\t\t\t\t\t\t\tm.react('‚úÖ')\r\n\t\t\t\t\t\t} else m.reply('Only Support video/audio/image/text')\r\n\t\t\t\t\t} else if (quoted.text) {\r\n\t\t\t\t\t\tawait naze.sendMessage('status@broadcast', { text: text || m.quoted?.body || '' }, {\r\n\t\t\t\t\t\t\ttextArgb: 0xffffffff,\r\n\t\t\t\t\t\t\tfont: Math.floor(Math.random() * 9),\r\n\t\t\t\t\t\t\tbackgroundColor, statusJidList,\r\n\t\t\t\t\t\t\tbroadcast: true\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tm.react('‚úÖ')\r\n\t\t\t\t\t} else m.reply('Only Support video/audio/image/text')\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal Mengupload Status Whatsapp!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'addcase': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text && !text.startsWith('case')) return m.reply('Masukkan Casenya!')\r\n\t\t\t\tfs.readFile('naze.js', 'utf8', (err, data) => {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.error('Terjadi kesalahan saat membaca file:', err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst posisi = data.indexOf(\"case '19rujxl1e':\");\r\n\t\t\t\t\tif (posisi !== -1) {\r\n\t\t\t\t\t\tconst codeBaru = data.slice(0, posisi) + '\\n' + `${text}` + '\\n' + data.slice(posisi);\r\n\t\t\t\t\t\tfs.writeFile('naze.js', codeBaru, 'utf8', (err) => {\r\n\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\tm.reply('Terjadi kesalahan saat menulis file: ', err);\r\n\t\t\t\t\t\t\t} else m.reply('Case berhasil ditambahkan');\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else m.reply('Gagal Menambahkan case!');\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'getcase': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply('Masukkan Nama Casenya!')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst getCase = (cases) => {\r\n\t\t\t\t\t\treturn \"case\"+`'${cases}'`+fs.readFileSync(\"naze.js\").toString().split('case \\''+cases+'\\'')[1].split(\"break\")[0]+\"break\"\r\n\t\t\t\t\t}\r\n\t\t\t\t\tm.reply(`${getCase(text)}`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply(`case ${text} tidak ditemukan!`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delcase': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!text) return m.reply('Masukkan Nama Casenya!')\r\n\t\t\t\tfs.readFile('naze.js', 'utf8', (err, data) => {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.error('Terjadi kesalahan saat membaca file:', err);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst regex = new RegExp(`case\\\\s+'${text.toLowerCase()}':[\\\\s\\\\S]*?break`, 'g');\r\n\t\t\t\t\tconst modifiedData = data.replace(regex, '');\r\n\t\t\t\t\tfs.writeFile('naze.js', modifiedData, 'utf8', (err) => {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\tm.reply('Terjadi kesalahan saat menulis file: ', err);\r\n\t\t\t\t\t\t} else m.reply('Case berhasil dihapus dari file');\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'backup': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tswitch (args[0]) {\r\n\t\t\t\t\tcase 'all':\r\n\t\t\t\t\tlet bekup = './database/backup_all.tar.gz';\r\n\t\t\t\t\ttarBackup('./', bekup).then(() => {\r\n\t\t\t\t\t\treturn m.reply({\r\n\t\t\t\t\t\t\tdocument: fs.readFileSync(bekup),\r\n\t\t\t\t\t\t\tmimetype: 'application/gzip',\r\n\t\t\t\t\t\t\tfileName: 'backup_all.tar.gz'\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}).catch(e => m.reply('Gagal backup: ', + e))\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'auto':\r\n\t\t\t\t\tif (set.autobackup) return m.reply('Sudah Aktif Sebelumnya!')\r\n\t\t\t\t\tset.autobackup = true\r\n\t\t\t\t\tm.reply('Sukses Mengaktifkan Auto Backup')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'session':\r\n\t\t\t\t\tawait m.reply({\r\n\t\t\t\t\t\tdocument: fs.readFileSync('./nazedev/creds.json'),\r\n\t\t\t\t\t\tmimetype: 'application/json',\r\n\t\t\t\t\t\tfileName: 'creds.json'\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'database':\r\n\t\t\t\t\tlet tglnya = new Date().toISOString().replace(/[:.]/g, '-');\r\n\t\t\t\t\tlet datanya = './database/' + tempatDB;\r\n\t\t\t\t\tif (tempatDB.startsWith('mongodb')) {\r\n\t\t\t\t\t\tdatanya = './database/backup_database.json';\r\n\t\t\t\t\t\tfs.writeFileSync(datanya, JSON.stringify(global.db, null, 2), 'utf-8');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait m.reply({\r\n\t\t\t\t\t\tdocument: fs.readFileSync(datanya),\r\n\t\t\t\t\t\tmimetype: 'application/json',\r\n\t\t\t\t\t\tfileName: tglnya + '_database.json'\r\n\t\t\t\t\t})\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tm.reply('Gunakan perintah:\\n- backup all\\n- backup auto\\n- backup session\\n- backup database');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'getsession': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tawait m.reply({\r\n\t\t\t\t\tdocument: fs.readFileSync('./nazedev/creds.json'),\r\n\t\t\t\t\tmimetype: 'application/json',\r\n\t\t\t\t\tfileName: 'creds.json'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'deletesession': case 'delsession': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tfs.readdir('./nazedev', async function (err, files) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.error('Unable to scan directory: ' + err);\r\n\t\t\t\t\t\treturn m.reply('Unable to scan directory: ' + err);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet filteredArray = await files.filter(item => ['session-', 'pre-key', 'sender-key', 'app-state'].some(ext => item.startsWith(ext)));\t\t\t\t\t\r\n\t\t\t\t\tlet teks = `Terdeteksi ${filteredArray.length} Session file\\n\\n`\r\n\t\t\t\t\tif(filteredArray.length == 0) return m.reply(teks);\r\n\t\t\t\t\tfilteredArray.map(function(e, i) {\r\n\t\t\t\t\t\tteks += (i+1)+`. ${e}\\n`\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (text && text == 'true') {\r\n\t\t\t\t\t\tlet { key } = await m.reply('Menghapus Session File..')\r\n\t\t\t\t\t\tawait filteredArray.forEach(function (file) {\r\n\t\t\t\t\t\t\tfs.unlinkSync('./nazedev/' + file)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tsleep(2000)\r\n\t\t\t\t\t\tm.reply('Berhasil Menghapus Semua Sampah Session', { edit: key })\r\n\t\t\t\t\t} else m.reply(teks + `\\nKetik _${prefix + command} true_\\nUntuk Menghapus`)\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'deletesampah': case 'delsampah': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tfs.readdir('./database/sampah', async function (err, files) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tconsole.error('Unable to scan directory: ' + err);\r\n\t\t\t\t\t\treturn m.reply('Unable to scan directory: ' + err);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet filteredArray = await files.filter(item => ['gif', 'png', 'bin','mp3', 'mp4', 'jpg', 'webp', 'webm', 'opus', 'jpeg'].some(ext => item.endsWith(ext)));\r\n\t\t\t\t\tlet teks = `Terdeteksi ${filteredArray.length} Sampah file\\n\\n`\r\n\t\t\t\t\tif(filteredArray.length == 0) return m.reply(teks);\r\n\t\t\t\t\tfilteredArray.map(function(e, i) {\r\n\t\t\t\t\t\tteks += (i+1)+`. ${e}\\n`\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (text && text == 'true') {\r\n\t\t\t\t\t\tlet { key } = await m.reply('Menghapus Sampah File..')\r\n\t\t\t\t\t\tawait filteredArray.forEach(function (file) {\r\n\t\t\t\t\t\t\tfs.unlinkSync('./database/sampah/' + file)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tsleep(2000)\r\n\t\t\t\t\t\tm.reply('Berhasil Menghapus Semua Sampah', { edit: key })\r\n\t\t\t\t\t} else m.reply(teks + `\\nKetik _${prefix + command} true_\\nUntuk Menghapus`)\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setnamebot': case 'setbotname': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst teksnya = text ? text : m.quoted.text\r\n\t\t\t\t\tif (db?.set?.[botNumber]?.setbotname) db.set[botNumber].setbotname = teksnya\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} textnya`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setpacknamebot': case 'setbotpackname': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst teksnya = text ? text : m.quoted.text\r\n\t\t\t\t\tif (db?.set?.[botNumber]?.packname) db.set[botNumber].packname = teksnya\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} textnya`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setauthorbot': case 'setbotauthor': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst teksnya = text ? text : m.quoted.text\r\n\t\t\t\t\tif (db?.set?.[botNumber]?.author) db.set[botNumber].author = teksnya\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} textnya`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'sc': case 'script': {\r\n\t\t\t\tawait m.reply(`https://github.com/nazedev/hitori\\n‚¨ÜÔ∏è Itu Sc nya cuy`, {\r\n\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\tforwardingScore: 10,\r\n\t\t\t\t\t\tisForwarded: true,\r\n\t\t\t\t\t\tforwardedNewsletterMessageInfo: {\r\n\t\t\t\t\t\t\tnewsletterJid: my.ch,\r\n\t\t\t\t\t\t\tserverMessageId: null,\r\n\t\t\t\t\t\t\tnewsletterName: 'Join For More Info'\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\ttitle: author,\r\n\t\t\t\t\t\t\tbody: 'Subscribe My YouTube',\r\n\t\t\t\t\t\t\tthumbnail: fake.thumbnail,\r\n\t\t\t\t\t\t\tmediaType: 2,\r\n\t\t\t\t\t\t\tmediaUrl: my.yt,\r\n\t\t\t\t\t\t\tsourceUrl: my.yt,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'donasi': case 'donate': {\r\n\t\t\t\tm.reply('Donasi Dapat Melalui Url Dibawah Ini :\\nhttps://saweria.co/naze')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Group Menu\r\n\t\t\tcase 'add': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [numbersOnly], 'add').then(async (res) => {\r\n\t\t\t\t\t\t\tfor (let i of res) {\r\n\t\t\t\t\t\t\t\tlet invv = await naze.groupInviteCode(m.chat)\r\n\t\t\t\t\t\t\t\tconst statusMessages = {\r\n\t\t\t\t\t\t\t\t\t200: `Berhasil menambahkan @${numbersOnly.split('@')[0]} ke grup!`,\r\n\t\t\t\t\t\t\t\t\t401: 'Dia Memblokir Bot!',\r\n\t\t\t\t\t\t\t\t\t409: 'Dia Sudah Join!',\r\n\t\t\t\t\t\t\t\t\t500: 'Grup Penuh!'\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tif (statusMessages[i.status]) {\r\n\t\t\t\t\t\t\t\t\treturn m.reply(statusMessages[i.status]);\r\n\t\t\t\t\t\t\t\t} else if (i.status == 408) {\r\n\t\t\t\t\t\t\t\t\tawait m.reply(`@${numbersOnly.split('@')[0]} Baru-Baru Saja Keluar Dari Grub Ini!\\n\\nKarena Target Private\\n\\nUndangan Akan Dikirimkan Ke\\n-> wa.me/${numbersOnly.replace(/\\D/g, '')}\\nMelalui Jalur Pribadi`)\r\n\t\t\t\t\t\t\t\t\tawait m.reply(`${'https://chat.whatsapp.com/' + invv}\\n------------------------------------------------------\\n\\nAdmin: @${m.sender.split('@')[0]}\\nMengundang anda ke group ini\\nSilahkan masuk jika berkehendaküôá`, { detectLink: true, chat: numbersOnly, quoted: fkontak }).catch((err) => m.reply('Gagal Mengirim Undangan!'))\r\n\t\t\t\t\t\t\t\t} else if (i.status == 403) {\r\n\t\t\t\t\t\t\t\t\tlet a = i.content.content[0].attrs\r\n\t\t\t\t\t\t\t\t\tawait naze.sendGroupInvite(m.chat, numbersOnly, a.code, a.expiration, m.metadata.subject, `Admin: @${m.sender.split('@')[0]}\\nMengundang anda ke group ini\\nSilahkan masuk jika berkehendaküôá`, null, { mentions: [m.sender] })\r\n\t\t\t\t\t\t\t\t\tawait m.reply(`@${numbersOnly.split('@')[0]} Tidak Dapat Ditambahkan\\n\\nKarena Target Private\\n\\nUndangan Akan Dikirimkan Ke\\n-> wa.me/${numbersOnly.replace(/\\D/g, '')}\\nMelalui Jalur Pribadi`)\r\n\t\t\t\t\t\t\t\t} else m.reply('Gagal Add User\\nStatus : ' + i.status)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Terjadi Kesalahan! Gagal Add User')\r\n\t\t\t\t\t}\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'kick': case 'dor': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender\r\n\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [numbersOnly], 'remove').catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'promote': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender\r\n\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [numbersOnly], 'promote').catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'demote': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender\r\n\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [numbersOnly], 'demote').catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'warn': case 'warning': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender\r\n\t\t\t\t\tif (!db.groups[m.chat].warn[numbersOnly]) {\r\n\t\t\t\t\t\tdb.groups[m.chat].warn[numbersOnly] = 1\r\n\t\t\t\t\t\tm.reply('Peringatan 1/4, akan dikick sewaktu waktu‚ùó')\r\n\t\t\t\t\t} else if (db.groups[m.chat].warn[numbersOnly] >= 3) {\r\n\t\t\t\t\t\tawait naze.groupParticipantsUpdate(m.chat, [numbersOnly], 'remove').catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t\t\tdelete db.groups[m.chat].warn[numbersOnly]\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdb.groups[m.chat].warn[numbersOnly] += 1\r\n\t\t\t\t\t\tm.reply(`Peringatan ${db.groups[m.chat].warn[numbersOnly]}/4, akan dikick sewaktu waktu‚ùó`)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'unwarn': case 'delwarn': case 'unwarning': case 'delwarning': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst numbersOnly = text ? text.replace(/\\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender\r\n\t\t\t\t\tif (db.groups[m.chat]?.warn?.[numbersOnly]) {\r\n\t\t\t\t\t\tdelete db.groups[m.chat].warn[numbersOnly]\r\n\t\t\t\t\t\tm.reply('Berhasil Menghapus Warning!')\r\n\t\t\t\t\t}\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} 62xxx`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setname': case 'setnamegc': case 'setsubject': case 'setsubjectgc': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst teksnya = text ? text : m.quoted.text\r\n\t\t\t\t\tawait naze.groupUpdateSubject(m.chat, teksnya).catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} textnya`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setdesc': case 'setdescgc': case 'setdesk': case 'setdeskgc': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (text || m.quoted) {\r\n\t\t\t\t\tconst teksnya = text ? text : m.quoted.text\r\n\t\t\t\t\tawait naze.groupUpdateDescription(m.chat, teksnya).catch((err) => m.reply('Gagal!'))\r\n\t\t\t\t} else m.reply(`Contoh: ${prefix + command} textnya`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setppgroups': case 'setppgrup': case 'setppgc': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply Gambar yang mau dipasang di Profile Bot')\r\n\t\t\t\tif (!/image/.test(quoted.type)) return m.reply(`Reply Image Dengan Caption ${prefix + command}`)\r\n\t\t\t\tlet media = await naze.downloadAndSaveMediaMessage(quoted, 'ppgc.jpeg')\r\n\t\t\t\tif (text.length > 0) {\r\n\t\t\t\t\tlet { img } = await generateProfilePicture(media)\r\n\t\t\t\t\tawait naze.query({\r\n\t\t\t\t\t\ttag: 'iq',\r\n\t\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\t\ttarget: m.chat,\r\n\t\t\t\t\t\t\tto: '@s.whatsapp.net',\r\n\t\t\t\t\t\t\ttype: 'set',\r\n\t\t\t\t\t\t\txmlns: 'w:profile:picture'\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tcontent: [{ tag: 'picture', attrs: { type: 'image' }, content: img }]\r\n\t\t\t\t\t})\r\n\t\t\t\t\tawait fs.unlinkSync(media)\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait naze.updateProfilePicture(m.chat, { url: media })\r\n\t\t\t\t\tawait fs.unlinkSync(media)\r\n\t\t\t\t\tm.reply('Sukses')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delete': case 'del': case 'd': {\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply pesan yang mau di delete')\r\n\t\t\t\tawait naze.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: m.isBotAdmin ? false : true, id: m.quoted.id, participant: m.quoted.sender }})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'pin': case 'unpin': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tawait naze.sendMessage(m.chat, { pin: { type: command == 'pin' ? 1 : 0, time: 2592000, key: m.quoted ? m.quoted.key : m.key }})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'linkgroup': case 'linkgrup': case 'linkgc': case 'urlgroup': case 'urlgrup': case 'urlgc': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tlet response = await naze.groupInviteCode(m.chat)\r\n\t\t\t\tawait m.reply(`https://chat.whatsapp.com/${response}\\n\\nLink Group : ${(store.groupMetadata[m.chat] ? store.groupMetadata[m.chat] : (store.groupMetadata[m.chat] = await naze.groupMetadata(m.chat))).subject}`, { detectLink: true })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'revoke': case 'newlink': case 'newurl': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tawait naze.groupRevokeInvite(m.chat).then((a) => {\r\n\t\t\t\t\tm.reply(`Sukses Menyetel Ulang, Tautan Undangan Grup ${m.metadata.subject}`)\r\n\t\t\t\t}).catch((err) => m.reply('Gagal!'))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'group': case 'grup': case 'gc': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tlet set = db.groups[m.chat]\r\n\t\t\t\tswitch (args[0]?.toLowerCase()) {\r\n\t\t\t\t\tcase 'close': case 'open':\r\n\t\t\t\t\tawait naze.groupSettingUpdate(m.chat, args[0] == 'close' ? 'announcement' : 'not_announcement').then(a => m.reply(`*Sukses ${args[0] == 'open' ? 'Membuka' : 'Menutup'} Group*`))\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'join':\r\n\t\t\t\t\tconst _list = await naze.groupRequestParticipantsList(m.chat).then(a => a.map(b => b.jid))\r\n\t\t\t\t\tif (/(a(p|pp|cc)|(ept|rove))|true|ok/i.test(args[1]) && _list.length > 0) {\r\n\t\t\t\t\t\tawait naze.groupRequestParticipantsUpdate(m.chat, _list, 'approve').catch(e => m.react('‚ùå'))\r\n\t\t\t\t\t} else if (/reject|false|no/i.test(args[1]) && _list.length > 0) {\r\n\t\t\t\t\t\tawait naze.groupRequestParticipantsUpdate(m.chat, _list, 'reject').catch(e => m.react('‚ùå'))\r\n\t\t\t\t\t} else m.reply(`List Request Join :\\n${_list.length > 0 ? '- @' + _list.join('\\n- @').split('@')[0] : '*Nothing*'}\\nExample : ${prefix + command} join acc/reject`)\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'pesansementara': case 'disappearing':\r\n\t\t\t\t\tif (/90|7|1|24|on/i.test(args[1])) {\r\n\t\t\t\t\t\tnaze.sendMessage(m.chat, { disappearingMessagesInChat: /90/i.test(args[1]) ? 7776000 : /7/i.test(args[1]) ? 604800 : 86400 })\r\n\t\t\t\t\t} else if (/0|off|false/i.test(args[1])) {\r\n\t\t\t\t\t\tnaze.sendMessage(m.chat, { disappearingMessagesInChat: 0 })\r\n\t\t\t\t\t} else m.reply('Silahkan Pilih :\\n90 hari, 7 hari, 1 hari, off')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'antilink': case 'antivirtex': case 'antidelete': case 'welcome': case 'antitoxic': case 'waktusholat': case 'nsfw': case 'antihidetag': case 'setinfo': case 'antitagsw': case 'leave': case 'promote': case 'demote':\r\n\t\t\t\t\tif (/on|true/i.test(args[1])) {\r\n\t\t\t\t\t\tif (set[args[0]]) return m.reply('*Sudah Aktif Sebelumnya*')\r\n\t\t\t\t\t\tset[args[0]] = true\r\n\t\t\t\t\t\tm.reply('*Sukse Change To On*')\r\n\t\t\t\t\t} else if (/off|false/i.test(args[1])) {\r\n\t\t\t\t\t\tset[args[0]] = false\r\n\t\t\t\t\t\tm.reply('*Sukse Change To Off*')\r\n\t\t\t\t\t} else m.reply(`‚ùó${args[0].charAt(0).toUpperCase() + args[0].slice(1)} on/off`)\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'setwelcome': case 'setleave': case 'setpromote': case 'setdemote':\r\n\t\t\t\t\tif (args[1]) {\r\n\t\t\t\t\t\tset.text[args[0]] = args.slice(1).join(' ');\r\n\t\t\t\t\t\tm.reply(`Sukses Mengubah ${args[0].split('set')[1]} Menjadi:\\n${set.text[args[0]]}`)\r\n\t\t\t\t\t} else m.reply(`Example:\\n${prefix + command} ${args[0]} Isi Pesannya\\n\\nMisal Dengan tag:\\n${prefix + command} ${args[0]} Kepada @\\nMaka akan Menjadi:\\nKepada @0\\n\\nMisal dengan Tag admin:\\n${prefix + command} ${args[0]} Dari @admin untuk @\\nMaka akan Menjadi:\\nDari @${m.sender.split('@')[0]} untuk @0\\n\\nMisal dengan Nama grup:\\n${prefix + command} ${args[0]} Dari @admin untuk @ di @subject\\nMaka akan Menjadi:\\nDari @${m.sender.split('@')[0]} untuk @0 di ${m.metadata.subject}`)\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tm.reply(`Settings Group ${m.metadata.subject}\\n- open\\n- close\\n- join acc/reject\\n- disappearing 90/7/1/off\\n- antilink on/off ${set.antilink ? 'üü¢' : 'üî¥'}\\n- antivirtex on/off ${set.antivirtex ? 'üü¢' : 'üî¥'}\\n- antidelete on/off ${set.antidelete ? 'üü¢' : 'üî¥'}\\n- welcome on/off ${set.welcome ? 'üü¢' : 'üî¥'}\\n- leave on/off ${set.leave ? 'üü¢' : 'üî¥'}\\n- promote on/off ${set.promote ? 'üü¢' : 'üî¥'}\\n- demote on/off ${set.demote ? 'üü¢' : 'üî¥'}\\n- setinfo on/off ${set.setinfo ? 'üü¢' : 'üî¥'}\\n- nsfw on/off ${set.nsfw ? 'üü¢' : 'üî¥'}\\n- waktusholat on/off ${set.waktusholat ? 'üü¢' : 'üî¥'}\\n- antihidetag on/off ${set.antihidetag ? 'üü¢' : 'üî¥'}\\n- antitagsw on/off ${set.antitagsw ? 'üü¢' : 'üî¥'}\\n\\n- setwelcome _textnya_\\n- setleave _textnya_\\n- setpromote _textnya_\\n- setdemote _textnya_\\n\\nExample:\\n${prefix + command} antilink off`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tagall': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tlet setv = pickRandom(listv)\r\n\t\t\t\tlet teks = `*Tag All*\\n\\n*Pesan :* ${q ? q : ''}\\n\\n`\r\n\t\t\t\tfor (let mem of m.metadata.participants) {\r\n\t\t\t\t\tteks += `${setv} @${mem.id.split('@')[0]}\\n`\r\n\t\t\t\t}\r\n\t\t\t\tawait m.reply(teks, { mentions: m.metadata.participants.map(a => a.id) })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'hidetag': case 'h': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tawait m.reply(q ? q : '', { mentions: m.metadata.participants.map(a => a.id) })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'totag': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!m.isAdmin) return m.reply(mess.admin)\r\n\t\t\t\tif (!m.isBotAdmin) return m.reply(mess.botAdmin)\r\n\t\t\t\tif (!m.quoted) return m.reply(`Reply pesan dengan caption ${prefix + command}`)\r\n\t\t\t\tdelete m.quoted.chat\r\n\t\t\t\tawait naze.sendMessage(m.chat, { forward: m.quoted.fakeObj, mentions: m.metadata.participants.map(a => a.id) })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listonline': case 'liston': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tlet id = args && /\\d+\\-\\d+@g.us/.test(args[0]) ? args[0] : m.chat\r\n\t\t\t\tif (!store.presences || !store.presences[id]) return m.reply('Sedang Tidak ada yang online!')\r\n\t\t\t\tlet online = [...Object.keys(store.presences[id]), botNumber]\r\n\t\t\t\tawait m.reply('List Online:\\n\\n' + online.map(v => setv + ' @' + v.replace(/@.+/, '')).join`\\n`, { mentions: online }).catch((e) => m.reply('Sedang Tidak Ada Yang Online..'))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Bot Menu\r\n\t\t\tcase 'owner': case 'listowner': {\r\n\t\t\t\tawait naze.sendContact(m.chat, ownerNumber, m);\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'profile': case 'cek': {\r\n\t\t\t\tconst user = Object.keys(db.users)\r\n\t\t\t\tconst infoUser = db.users[m.sender]\r\n\t\t\t\tawait m.reply(`*üë§Profile @${m.sender.split('@')[0]}* :\\nüêãUser Bot : ${user.includes(m.sender) ? 'True' : 'False'}\\nüî•User : ${isVip ? 'VIP' : isPremium ? 'PREMIUM' : 'FREE'}${isPremium ? `\\n‚è≥Expired : ${checkStatus(m.sender, premium) ? formatDate(getExpired(m.sender, db.premium)) : '-'}` : ''}\\nüé´Limit : ${infoUser.limit}\\nüí∞Uang : ${infoUser ? infoUser.money.toLocaleString('id-ID') : '0'}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'leaderboard': {\r\n\t\t\t\tconst entries = Object.entries(db.users).sort((a, b) => b[1].money - a[1].money).slice(0, 10).map(entry => entry[0]);\r\n\t\t\t\tlet teksnya = '‚ï≠‚îÄ‚îÄ‚ùç„Äå *LEADERBOARD* „Äç‚ùç\\n'\r\n\t\t\t\tfor (let i = 0; i < entries.length; i++) {\r\n\t\t\t\t\tteksnya += `‚îÇ‚Ä¢ ${i + 1}. @${entries[i].split('@')[0]}\\n‚îÇ‚Ä¢ Balance : ${db.users[entries[i]].money.toLocaleString('id-ID')}\\n‚îÇ\\n`\r\n\t\t\t\t}\r\n\t\t\t\tm.reply(teksnya + '‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç');\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'totalpesan': {\r\n\t\t\t\tlet messageCount = {};\r\n\t\t\t\tlet messages = store?.messages[m.chat]?.array || [];\r\n\t\t\t\tlet participants = m?.metadata?.participants?.map(p => p.id) || store?.messages[m.chat]?.array?.map(p => p.key.participant) || [];\r\n\t\t\t\tmessages.forEach(mes => {\r\n\t\t\t\t\tif (mes.key?.participant && mes.message) {\r\n\t\t\t\t\t\tmessageCount[mes.key.participant] = (messageCount[mes.key.participant] || 0) + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tlet totalMessages = Object.values(messageCount).reduce((a, b) => a + b, 0);\r\n\t\t\t\tlet date = new Date().toLocaleDateString('id-ID');\r\n\t\t\t\tlet zeroMessageUsers = participants.filter(user => !messageCount[user]).map(user => `- @${user.replace(/[^0-9]/g, '')}`);\r\n\t\t\t\tlet messageList = Object.entries(messageCount).map(([sender, count], index) => `${index + 1}. @${sender.replace(/[^0-9]/g, '')}: ${count} Pesan`);\r\n\t\t\t\tlet result = `Total Pesan ${totalMessages} dari ${participants.length} anggota\\nPada tanggal ${date}:\\n${messageList.join('\\n')}\\n\\nNote: ${text.length > 0 ? `\\n${zeroMessageUsers.length > 0 ? `Sisa Anggota yang tidak mengirim pesan (Sider):\\n${zeroMessageUsers.join('\\n')}` : 'Semua anggota sudah mengirim pesan!'}` : `\\nCek Sider? ${prefix + command} --sider`}`;\r\n\t\t\t\tm.reply(result)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'req': case 'request': {\r\n\t\t\t\tif (!text) return m.reply('Mau Request apa ke Owner?')\r\n\t\t\t\tawait m.reply(`*Request Telah Terkirim Ke Owner*\\n_Terima Kasihüôè_`)\r\n\t\t\t\tawait naze.sendFromOwner(ownerNumber, `Pesan Dari : @${m.sender.split('@')[0]}\\nUntuk Owner\\n\\nRequest ${text}`, m, { contextInfo: { mentionedJid: [m.sender], isForwarded: true }})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'totalfitur': {\r\n\t\t\t\tconst total = ((fs.readFileSync('./naze.js').toString()).match(/case '/g) || []).length\r\n\t\t\t\tm.reply(`Total Fitur : ${total}`);\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'daily': case 'claim': {\r\n\t\t\t\tdaily(m, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'transfer': case 'tf': {\r\n\t\t\t\ttransfer(m, args, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'buy': {\r\n\t\t\t\tbuy(m, args, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'react': {\r\n\t\t\t\tnaze.sendMessage(m.chat, { react: { text: args[0], key: m.quoted ? m.quoted.key : m.key }})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tagme': {\r\n\t\t\t\tm.reply(`@${m.sender.split('@')[0]}`, { mentions: [m.sender] })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'runtime': case 'tes': case 'bot': {\r\n\t\t\t\tswitch(args[0]) {\r\n\t\t\t\t\tcase 'mode': case 'public': case 'self':\r\n\t\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\t\tif (args[1] == 'public' || args[1] == 'all') {\r\n\t\t\t\t\t\tif (naze.public && set.grouponly && set.privateonly) return m.reply('*Sudah Aktif Sebelumnya*')\r\n\t\t\t\t\t\tnaze.public = set.public = true\r\n\t\t\t\t\t\tset.grouponly = true\r\n\t\t\t\t\t\tset.privateonly = true\r\n\t\t\t\t\t\tm.reply('*Sukse Change To Public Usage*')\r\n\t\t\t\t\t} else if (args[1] == 'self') {\r\n\t\t\t\t\t\tset.grouponly = false\r\n\t\t\t\t\t\tset.privateonly = false\r\n\t\t\t\t\t\tnaze.public = set.public = false\r\n\t\t\t\t\t\tm.reply('*Sukse Change To Self Usage*')\r\n\t\t\t\t\t} else if (args[1] == 'group') {\r\n\t\t\t\t\t\tset.grouponly = true\r\n\t\t\t\t\t\tset.privateonly = false\r\n\t\t\t\t\t\tm.reply('*Sukse Change To Group Only*')\r\n\t\t\t\t\t} else if (args[1] == 'private') {\r\n\t\t\t\t\t\tset.grouponly = false\r\n\t\t\t\t\t\tset.privateonly = true\r\n\t\t\t\t\t\tm.reply('*Sukse Change To Private Only*')\r\n\t\t\t\t\t} else m.reply('Mode self/public/group/private/all')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'anticall': case 'autobio': case 'autoread': case 'autotyping': case 'readsw': case 'multiprefix': case 'antispam':\r\n\t\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\t\tif (args[1] == 'on') {\r\n\t\t\t\t\t\tif (set[args[0]]) return m.reply('*Sudah Aktif Sebelumnya*')\r\n\t\t\t\t\t\tset[args[0]] = true\r\n\t\t\t\t\t\tm.reply('*Sukse Change To On*')\r\n\t\t\t\t\t} else if (args[1] == 'off') {\r\n\t\t\t\t\t\tset[args[0]] = false\r\n\t\t\t\t\t\tm.reply('*Sukse Change To Off*')\r\n\t\t\t\t\t} else m.reply(`${args[0].charAt(0).toUpperCase() + args[0].slice(1)} on/off`)\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'set': case 'settings':\r\n\t\t\t\t\tlet settingsBot = Object.entries(set).map(([key, value]) => {\r\n\t\t\t\t\t\tlet list = key == 'status' ? new Date(value).toLocaleString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : (typeof value === 'boolean') ? (value ? 'onüü¢' : 'offüî¥') : value;\r\n\t\t\t\t\t\treturn `- ${key.charAt(0).toUpperCase() + key.slice(1)} : ${list}`;\r\n\t\t\t\t\t}).join('\\n');\r\n\t\t\t\t\tm.reply(`Settings Bot @${botNumber.split('@')[0]}\\n${settingsBot}\\n\\nExample: ${prefix + command} mode`);\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tif (args[0] || args[1]) m.reply(`*Please Sellect Settings :*\\n- Mode : *${prefix + command} mode self/public*\\n- Anti Call : *${prefix + command} anticall on/off*\\n- Auto Bio : *${prefix + command} autobio on/off*\\n- Auto Read : *${prefix + command} autoread on/off*\\n- Auto Typing : *${prefix + command} autotyping on/off*\\n- Read Sw : *${prefix + command} readsw on/off*\\n- Multi Prefix : *${prefix + command} multiprefix on/off*`)\r\n\t\t\t\t}\r\n\t\t\t\tif (!args[0] && !args[1]) return m.reply(`*Bot Telah Online Selama*\\n*${runtime(process.uptime())}*`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ping': case 'botstatus': case 'statusbot': {\r\n\t\t\t\tconst used = process.memoryUsage()\r\n\t\t\t\tconst cpus = os.cpus().map(cpu => {\r\n\t\t\t\t\tcpu.total = Object.keys(cpu.times).reduce((last, type) => last + cpu.times[type], 0)\r\n\t\t\t\t\treturn cpu\r\n\t\t\t\t})\r\n\t\t\t\tconst cpu = cpus.reduce((last, cpu, _, { length }) => {\r\n\t\t\t\t\tlast.total += cpu.total\r\n\t\t\t\t\tlast.speed += cpu.speed / length\r\n\t\t\t\t\tlast.times.user += cpu.times.user\r\n\t\t\t\t\tlast.times.nice += cpu.times.nice\r\n\t\t\t\t\tlast.times.sys += cpu.times.sys\r\n\t\t\t\t\tlast.times.idle += cpu.times.idle\r\n\t\t\t\t\tlast.times.irq += cpu.times.irq\r\n\t\t\t\t\treturn last\r\n\t\t\t\t}, {\r\n\t\t\t\t\tspeed: 0,\r\n\t\t\t\t\ttotal: 0,\r\n\t\t\t\t\ttimes: {\r\n\t\t\t\t\t\tuser: 0,\r\n\t\t\t\t\t\tnice: 0,\r\n\t\t\t\t\t\tsys: 0,\r\n\t\t\t\t\t\tidle: 0,\r\n\t\t\t\t\t\tirq: 0\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tlet timestamp = speed()\r\n\t\t\t\tlet latensi = speed() - timestamp\r\n\t\t\t\tneww = performance.now()\r\n\t\t\t\toldd = performance.now()\r\n\t\t\t\trespon = `Kecepatan Respon ${latensi.toFixed(4)} _Second_ \\n ${oldd - neww} _miliseconds_\\n\\nRuntime : ${runtime(process.uptime())}\\n\\nüíª Info Server\\nRAM: ${formatp(os.totalmem() - os.freemem())} / ${formatp(os.totalmem())}\\n\\n_NodeJS Memory Usaage_\\n${Object.keys(used).map((key, _, arr) => `${key.padEnd(Math.max(...arr.map(v=>v.length)),' ')}: ${formatp(used[key])}`).join('\\n')}\\n\\n${cpus[0] ? `_Total CPU Usage_\\n${cpus[0].model.trim()} (${cpu.speed} MHZ)\\n${Object.keys(cpu.times).map(type => `- *${(type + '*').padEnd(6)}: ${(100 * cpu.times[type] / cpu.total).toFixed(2)}%`).join('\\n')}\\n_CPU Core(s) Usage (${cpus.length} Core CPU)_\\n${cpus.map((cpu, i) => `${i + 1}. ${cpu.model.trim()} (${cpu.speed} MHZ)\\n${Object.keys(cpu.times).map(type => `- *${(type + '*').padEnd(6)}: ${(100 * cpu.times[type] / cpu.total).toFixed(2)}%`).join('\\n')}`).join('\\n\\n')}` : ''}`.trim()\r\n\t\t\t\tm.reply(respon)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'speedtest': case 'speed': {\r\n\t\t\t\tm.reply('Testing Speed...')\r\n\t\t\t\tlet cp = require('child_process')\r\n\t\t\t\tlet { promisify } = require('util')\r\n\t\t\t\tlet exec = promisify(cp.exec).bind(cp)\r\n\t\t\t\tlet o\r\n\t\t\t\ttry {\r\n\t\t\t\t\to = await exec('python3 speed.py --share')\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\to = e\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tlet { stdout, stderr } = o\r\n\t\t\t\t\tif (stdout.trim()) m.reply(stdout)\r\n\t\t\t\t\tif (stderr.trim()) m.reply(stderr)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'afk': {\r\n\t\t\t\tlet user = db.users[m.sender]\r\n\t\t\t\tuser.afkTime = + new Date\r\n\t\t\t\tuser.afkReason = text\r\n\t\t\t\tm.reply(`@${m.sender.split('@')[0]} Telah Afk${text ? ': ' + text : ''}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'readviewonce': case 'readviewone': case 'rvo': {\r\n\t\t\t\tif (!m.quoted) return m.reply(`Reply view once message\\nExample: ${prefix + command}`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (m.quoted.msg.viewOnce) {\r\n\t\t\t\t\t\tdelete m.quoted.chat\r\n\t\t\t\t\t\tm.quoted.msg.viewOnce = false\r\n\t\t\t\t\t\tawait m.reply({ forward: m.quoted })\r\n\t\t\t\t\t} else m.reply(`Reply view once message\\nExample: ${prefix + command}`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Media Tidak Valid!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'inspect': {\r\n\t\t\t\tif (!text) return m.reply('Masukkan Link Grup atau Saluran!')\r\n\t\t\t\tlet _grup = /chat.whatsapp.com\\/([\\w\\d]*)/;\r\n\t\t\t\tlet _saluran = /whatsapp\\.com\\/channel\\/([\\w\\d]*)/;\r\n\t\t\t\tif (_grup.test(text)) {\r\n\t\t\t\t\tawait naze.groupGetInviteInfo(text.match(_grup)[1]).then((_g) => {\r\n\t\t\t\t\t\tlet teks = `*[ INFORMATION GROUP ]*\\n\\nName Group: ${_g.subject}\\nGroup ID: ${_g.id}\\nCreate At: ${new Date(_g.creation * 1000).toLocaleString()}${_g.owner ? ('\\nCreate By: ' + _g.owner) : '' }\\nLinked Parent: ${_g.linkedParent}\\nRestrict: ${_g.restrict}\\nAnnounce: ${_g.announce}\\nIs Community: ${_g.isCommunity}\\nCommunity Announce:${_g.isCommunityAnnounce}\\nJoin Approval: ${_g.joinApprovalMode}\\nMember Add Mode: ${_g.memberAddMode}\\nDescription ID: ${'`' + _g.descId + '`'}\\nDescription: ${_g.desc}\\nParticipants:\\n`\r\n\t\t\t\t\t\t_g.participants.forEach((a) => {\r\n\t\t\t\t\t\t\tteks += a.admin ? `- Admin: @${a.id.split('@')[0]} [${a.admin}]\\n` : ''\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tm.reply(teks)\r\n\t\t\t\t\t}).catch((e) => {\r\n\t\t\t\t\t\tif ([400, 406].includes(e.data)) return m.reply('Grup Tidak Di Temukan‚ùó');\r\n\t\t\t\t\t\tif (e.data == 401) return m.reply('Bot Di Kick Dari Grup Tersebut‚ùó');\r\n\t\t\t\t\t\tif (e.data == 410) return m.reply('Url Grup Telah Di Setel Ulang‚ùó');\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if (_saluran.test(text) || text.endsWith('@newsletter') || !isNaN(text)) {\r\n\t\t\t\t\tawait naze.newsletterMsg(text.match(_saluran)[1]).then((n) => {\r\n\t\t\t\t\t\tm.reply(`*[ INFORMATION CHANNEL ]*\\n\\nID: ${n.id}\\nState: ${n.state.type}\\nName: ${n.thread_metadata.name.text}\\nCreate At: ${new Date(n.thread_metadata.creation_time * 1000).toLocaleString()}\\nSubscriber: ${n.thread_metadata.subscribers_count}\\nVerification: ${n.thread_metadata.verification}\\nDescription: ${n.thread_metadata.description.text}\\n`)\r\n\t\t\t\t\t}).catch((e) => m.reply('Saluran Tidak Di Temukan‚ùó'))\r\n\t\t\t\t} else m.reply('Hanya Support Url Grup atau Saluran!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'addmsg': {\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply Pesan Yang Ingin Disave Di Database')\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} file name`)\r\n\t\t\t\tlet msgs = db.database\r\n\t\t\t\tif (text.toLowerCase() in msgs) return m.reply(`'${text}' telah terdaftar di list pesan`)\r\n\t\t\t\tmsgs[text.toLowerCase()] = m.quoted\r\n\t\t\t\tdelete msgs[text.toLowerCase()].chat\r\n\t\t\t\tm.reply(`Berhasil menambahkan pesan di list pesan sebagai '${text}'\\nAkses dengan ${prefix}getmsg ${text}\\nLihat list Pesan Dengan ${prefix}listmsg`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delmsg': case 'deletemsg': {\r\n\t\t\t\tif (!text) return m.reply('Nama msg yg mau di delete?')\r\n\t\t\t\tlet msgs = db.database\r\n\t\t\t\tif (text == 'allmsg') {\r\n\t\t\t\t\tdb.database = {}\r\n\t\t\t\t\tm.reply('Berhasil menghapus seluruh msg dari list pesan')\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!(text.toLowerCase() in msgs)) return m.reply(`'${text}' tidak terdaftar didalam list pesan`)\r\n\t\t\t\t\tdelete msgs[text.toLowerCase()]\r\n\t\t\t\t\tm.reply(`Berhasil menghapus '${text}' dari list pesan`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'getmsg': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} file name\\n\\nLihat list pesan dengan ${prefix}listmsg`)\r\n\t\t\t\tlet msgs = db.database\r\n\t\t\t\tif (!(text.toLowerCase() in msgs)) return m.reply(`'${text}' tidak terdaftar di list pesan`)\r\n\t\t\t\tawait naze.relayMessage(m.chat, msgs[text.toLowerCase()], {})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listmsg': {\r\n\t\t\t\tlet seplit = Object.entries(db.database).map(([nama, isi]) => { return { nama, message: getContentType(isi) }})\r\n\t\t\t\tlet teks = '„Äå LIST DATABASE „Äç\\n\\n'\r\n\t\t\t\tfor (let i of seplit) {\r\n\t\t\t\t\tteks += `${setv} *Name :* ${i.nama}\\n${setv} *Type :* ${i.message?.replace(/Message/i, '')}\\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\\n`\r\n\t\t\t\t}\r\n\t\t\t\tm.reply(teks)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'setcmd': case 'addcmd': {\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply Pesannya!')\r\n\t\t\t\tif (!m.quoted.fileSha256) return m.reply('SHA256 Hash Missing!')\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} CMD Name`)\r\n\t\t\t\tlet hash = m.quoted.fileSha256.toString('base64')\r\n\t\t\t\tif (global.db.cmd[hash] && global.db.cmd[hash].locked) return m.reply('You have no permission to change this sticker command')\r\n\t\t\t\tglobal.db.cmd[hash] = {\r\n\t\t\t\t\tcreator: m.sender,\r\n\t\t\t\t\tlocked: false,\r\n\t\t\t\t\tat: + new Date,\r\n\t\t\t\t\ttext\r\n\t\t\t\t}\r\n\t\t\t\tm.reply('Done!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delcmd': {\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply Pesannya!')\r\n\t\t\t\tif (!m.quoted.fileSha256) return m.reply('SHA256 Hash Missing!')\r\n\t\t\t\tlet hash = m.quoted.fileSha256.toString('base64')\r\n\t\t\t\tif (global.db.cmd[hash] && global.db.cmd[hash].locked) return m.reply('You have no permission to change this sticker command')\r\n\t\t\t\tdelete global.db.cmd[hash];\r\n\t\t\t\tm.reply('Done')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listcmd': {\r\n\t\t\t\tlet teks = `*List Hash*\\nInfo: *bold* hash is Locked\\n${Object.entries(global.db.cmd).map(([key, value], index) => `${index + 1}. ${value.locked ? `*${key}*` : key} : ${value.text}`).join('\\n')}`.trim()\r\n\t\t\t\tnaze.sendText(m.chat, teks, m);\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'lockcmd': case 'unlockcmd': {\r\n\t\t\t\tif (!isCreator) return m.reply(mess.owner)\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply Pesannya!')\r\n\t\t\t\tif (!m.quoted.fileSha256) return m.reply('SHA256 Hash Missing!')\r\n\t\t\t\tlet hash = m.quoted.fileSha256.toString('base64')\r\n\t\t\t\tif (!(hash in global.db.cmd)) return m.reply('You have no permission to change this sticker command')\r\n\t\t\t\tglobal.db.cmd[hash].locked = !/^un/i.test(command)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'q': case 'quoted': {\r\n\t\t\t\tif (!m.quoted) return m.reply('Reply Pesannya!')\r\n\t\t\t\tif (text) {\r\n\t\t\t\t\tdelete m.quoted.chat\r\n\t\t\t\t\tawait m.reply({ forward: m.quoted })\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst anu = await m.getQuotedObj()\r\n\t\t\t\t\tif (!anu) return m.reply('Format Tidak Tersedia!')\r\n\t\t\t\t\tif (!anu.quoted) return m.reply('Pesan Yang Anda Reply Tidak Mengandung Reply')\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, { [anu.quoted.type]: anu.quoted.msg }, {})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'confes': case 'confess': case 'menfes': case 'menfess': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (m.isGroup) return m.reply(mess.private)\r\n\t\t\t\tif (menfes[m.sender]) return m.reply(`Kamu Sedang Berada Di Sesi ${command}!`)\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} 62xxxx|Nama Samaran`)\r\n\t\t\t\tlet [teks1, teks2] = text.split`|`\r\n\t\t\t\tif (teks1) {\r\n\t\t\t\t\tconst tujuan = teks1.replace(/[^0-9]/g, '') + '@s.whatsapp.net'\r\n\t\t\t\t\tconst onWa = await naze.onWhatsApp(tujuan)\r\n\t\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\t\tmenfes[m.sender] = {\r\n\t\t\t\t\t\ttujuan: tujuan,\r\n\t\t\t\t\t\tnama: teks2 ? teks2 : 'Orang'\r\n\t\t\t\t\t};\r\n\t\t\t\t\tmenfes[tujuan] = {\r\n\t\t\t\t\t\ttujuan: m.sender,\r\n\t\t\t\t\t\tnama: 'Penerima',\r\n\t\t\t\t\t};\r\n\t\t\t\t\tconst timeout = setTimeout(() => {\r\n\t\t\t\t\t\tif (menfes[m.sender]) {\r\n\t\t\t\t\t\t\tm.reply(`_Waktu ${command} habis_`);\r\n\t\t\t\t\t\t\tdelete menfes[m.sender];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (menfes[tujuan]) {\r\n\t\t\t\t\t\t\tnaze.sendMessage(tujuan, { text: `_Waktu ${command} habis_` });\r\n\t\t\t\t\t\t\tdelete menfes[tujuan];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmenfesTimeouts.delete(m.sender);\r\n\t\t\t\t\t\tmenfesTimeouts.delete(tujuan);\r\n\t\t\t\t\t}, 600000);\r\n\t\t\t\t\tmenfesTimeouts.set(m.sender, timeout);\r\n\t\t\t\t\tmenfesTimeouts.set(tujuan, timeout);\r\n\t\t\t\t\tnaze.sendMessage(tujuan, { text: `_${command} connected_\\n*Note :* jika ingin mengakhiri ketik _*${prefix}del${command}*_` });\r\n\t\t\t\t\tm.reply(`_Memulai ${command}..._\\n*Silahkan Mulai kirim pesan/media*\\n*Durasi ${command} hanya selama 10 menit*\\n*Note :* jika ingin mengakhiri ketik _*${prefix}del${command}*_`)\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} else m.reply(`Masukkan Nomernya!\\nExample : ${prefix + command} 62xxxx|Nama Samaran`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delconfes': case 'delconfess': case 'delmenfes': case 'delmenfess': {\r\n\t\t\t\tif (!menfes[m.sender]) return m.reply(`Kamu Tidak Sedang Berada Di Sesi ${command.split('del')[1]}!`)\r\n\t\t\t\tlet anu = menfes[m.sender]\r\n\t\t\t\tif (menfesTimeouts.has(m.sender)) {\r\n\t\t\t\t\tclearTimeout(menfesTimeouts.get(m.sender));\r\n\t\t\t\t\tmenfesTimeouts.delete(m.sender);\r\n\t\t\t\t}\r\n\t\t\t\tif (menfesTimeouts.has(anu.tujuan)) {\r\n\t\t\t\t\tclearTimeout(menfesTimeouts.get(anu.tujuan));\r\n\t\t\t\t\tmenfesTimeouts.delete(anu.tujuan);\r\n\t\t\t\t}\r\n\t\t\t\tnaze.sendMessage(anu.tujuan, { text: `Chat Di Akhiri Oleh ${anu.nama ? anu.nama : 'Seseorang'}` })\r\n\t\t\t\tm.reply(`Sukses Mengakhiri Sesi ${command.split('del')[1]}!`)\r\n\t\t\t\tdelete menfes[anu.tujuan];\r\n\t\t\t\tdelete menfes[m.sender];\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'cai': case 'roomai': case 'chatai': case 'autoai': {\r\n\t\t\t\tif (m.isGroup) return m.reply(mess.private)\r\n\t\t\t\tif (chat_ai[m.sender]) return m.reply(`Kamu Sedang Berada Di Sesi ${command}!`)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} halo ngab\\nWith Prompt: ${prefix + command} halo ngab|Kamu adalah assisten yang siap membantu dalam hal apapun yang ku minta.\\n\\nUntuk Menghapus room: ${prefix + 'del' + command}`)\r\n\t\t\t\tlet [teks1, teks2] = text.split`|`\r\n\t\t\t\tchat_ai[m.sender] = [{ role: 'system', content: teks2 || '' }, { role: 'user', content: text.split`|` ? teks1 : text || '' }]\r\n\t\t\t\tlet hasil;\r\n\t\t\t\ttry {\r\n\t\t\t\t\thasil = await gptLogic(chat_ai[m.sender], budy)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\thasil = await yanzGpt(chat_ai[m.sender])\r\n\t\t\t\t}\r\n\t\t\t\tconst response = hasil?.choices?.[0]?.message?.content || hasil || 'Maaf, saya tidak mengerti.';\r\n\t\t\t\tchat_ai[m.sender].push({ role: 'assistant', content: response });\r\n\t\t\t\tawait m.reply(response)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delcai': case 'delroomai': case 'delchatai': case 'delautoai': {\r\n\t\t\t\tif (!chat_ai[m.sender]) return m.reply(`Kamu Tidak Sedang Berada Di Sesi ${command.split('del')[1]}!`)\r\n\t\t\t\tm.reply(`Sukses Mengakhiri Sesi ${command.split('del')[1]}!`)\r\n\t\t\t\tdelete chat_ai[m.sender];\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'jadibot': {\r\n\t\t\t\tif (!isPremium) return m.reply(mess.prem)\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tconst nmrnya = text ? text.replace(/[^0-9]/g, '') + '@s.whatsapp.net' : m.sender\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tawait JadiBot(naze, nmrnya, m, store)\r\n\t\t\t\tm.reply(`Gunakan ${prefix}stopjadibot\\nUntuk Berhenti`)\r\n\t\t\t\tsetLimit(m, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'stopjadibot': case 'deljadibot': {\r\n\t\t\t\tconst nmrnya = text ? text.replace(/[^0-9]/g, '') + '@s.whatsapp.net' : m.sender\r\n\t\t\t\tconst onWa = await naze.onWhatsApp(nmrnya)\r\n\t\t\t\tif (!onWa.length > 0) return m.reply('Nomer Tersebut Tidak Terdaftar Di Whatsapp!')\r\n\t\t\t\tawait StopJadiBot(naze, nmrnya, m)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'listjadibot': {\r\n\t\t\t\tListJadiBot(naze, m)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Tools Menu\r\n\t\t\tcase 'fetch': case 'get': {\r\n\t\t\t\tif (!isPremium) return m.reply(mess.prem)\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!/^https?:\\/\\//.test(text)) return m.reply('Awali dengan http:// atau https://');\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await axios.get(isUrl(text) ? isUrl(text)[0] : text)\r\n\t\t\t\t\tif (!/text|json|html|plain/.test(res.headers['content-type'])) {\r\n\t\t\t\t\t\tawait m.reply(text)\r\n\t\t\t\t\t} else m.reply(util.format(res.data))\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply(String(e))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'toaud': case 'toaudio': {\r\n\t\t\t\tif (!/video|audio/.test(mime)) return m.reply(`Kirim/Reply Video/Audio Yang Ingin Dijadikan Audio Dengan Caption ${prefix + command}`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\tlet audio = await toAudio(media, 'mp4')\r\n\t\t\t\tawait m.reply({ audio: audio, mimetype: 'audio/mpeg'})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tomp3': {\r\n\t\t\t\tif (!/video|audio/.test(mime)) return m.reply(`Kirim/Reply Video/Audio Yang Ingin Dijadikan Audio Dengan Caption ${prefix + command}`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\tlet audio = await toAudio(media, 'mp4')\r\n\t\t\t\tawait m.reply({ document: audio, mimetype: 'audio/mpeg', fileName: `Convert By Naze Bot.mp3`})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tovn': case 'toptt': case 'tovoice': {\r\n\t\t\t\tif (!/video|audio/.test(mime)) return m.reply(`Kirim/Reply Video/Audio Yang Ingin Dijadikan Audio Dengan Caption ${prefix + command}`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\tlet audio = await toPTT(media, 'mp4')\r\n\t\t\t\tawait m.reply({ audio: audio, mimetype: 'audio/ogg; codecs=opus', ptt: true })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'togif': {\r\n\t\t\t\tif (!/webp|video/.test(mime)) return m.reply(`Reply Video/Stiker dengan caption *${prefix + command}*`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tlet media = await naze.downloadAndSaveMediaMessage(qmsg)\r\n\t\t\t\tlet ran = `./database/sampah/${getRandom('.gif')}`;\r\n\t\t\t\texec(`convert ${media} ${ran}`, (err) => {\r\n\t\t\t\t\tfs.unlinkSync(media)\r\n\t\t\t\t\tif (err) return m.reply('Gagal‚ùó')\r\n\t\t\t\t\tlet buffer = fs.readFileSync(ran)\r\n\t\t\t\t\tm.reply({ video: buffer, gifPlayback: true })\r\n\t\t\t\t\tfs.unlinkSync(ran)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'toimage': case 'toimg': {\r\n\t\t\t\tif (!/webp|video|image/.test(mime)) return m.reply(`Reply Video/Stiker dengan caption *${prefix + command}*`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tlet media = await naze.downloadAndSaveMediaMessage(qmsg)\r\n\t\t\t\tlet ran = `./database/sampah/${getRandom('.png')}`;\r\n\t\t\t\texec(`convert ${media}[0] ${ran}`, (err) => {\r\n\t\t\t\t\tfs.unlinkSync(media)\r\n\t\t\t\t\tif (err) return m.reply('Gagal‚ùó')\r\n\t\t\t\t\tlet buffer = fs.readFileSync(ran)\r\n\t\t\t\t\tm.reply({ image: buffer })\r\n\t\t\t\t\tfs.unlinkSync(ran)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'toptv': {\r\n\t\t\t\tif (!/video/.test(mime)) return m.reply(`Kirim/Reply Video Yang Ingin Dijadikan PTV Message Dengan Caption ${prefix + command}`)\r\n\t\t\t\tif ((m.quoted ? m.quoted.type : m.type) === 'videoMessage') {\r\n\t\t\t\t\tconst anu = await quoted.download()\r\n\t\t\t\t\tconst message = await generateWAMessageContent({ video: anu }, { upload: naze.waUploadToServer })\r\n\t\t\t\t\tawait naze.relayMessage(m.chat, { ptvMessage: message.videoMessage }, {})\r\n\t\t\t\t} else m.reply('Reply Video Yang Mau Di Ubah Ke PTV Message!')\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tourl': {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (/webp|video|sticker|audio|jpg|jpeg|png/.test(mime)) {\r\n\t\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\t\tlet anu = await UguuSe(media)\r\n\t\t\t\t\t\tm.reply('Url : ' + anu.url)\r\n\t\t\t\t\t} else m.reply('Send Media yg ingin di Upload!')\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Uploader sedang offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'texttospech': case 'tts': case 'tospech': {\r\n\t\t\t\tif (!text) return m.reply('Mana text yg mau diubah menjadi audio?')\r\n\t\t\t\tlet { tts } = require('./lib/tts')\r\n\t\t\t\tlet anu = await tts(text)\r\n\t\t\t\tm.reply({ audio: anu, ptt: true, mimetype: 'audio/mpeg' })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'translate': case 'tr': {\r\n\t\t\t\tif (text && text == 'list') {\r\n\t\t\t\t\tlet list_tr = `‚ï≠‚îÄ‚îÄ‚ùç„Äå *Kode Bahasa* „Äç‚ùç\\n‚îÇ‚Ä¢ af : Afrikaans\\n‚îÇ‚Ä¢ ar : Arab\\n‚îÇ‚Ä¢ zh : Chinese\\n‚îÇ‚Ä¢ en : English\\n‚îÇ‚Ä¢ en-us : English (United States)\\n‚îÇ‚Ä¢ fr : French\\n‚îÇ‚Ä¢ de : German\\n‚îÇ‚Ä¢ hi : Hindi\\n‚îÇ‚Ä¢ hu : Hungarian\\n‚îÇ‚Ä¢ is : Icelandic\\n‚îÇ‚Ä¢ id : Indonesian\\n‚îÇ‚Ä¢ it : Italian\\n‚îÇ‚Ä¢ ja : Japanese\\n‚îÇ‚Ä¢ ko : Korean\\n‚îÇ‚Ä¢ la : Latin\\n‚îÇ‚Ä¢ no : Norwegian\\n‚îÇ‚Ä¢ pt : Portuguese\\n‚îÇ‚Ä¢ pt : Portuguese\\n‚îÇ‚Ä¢ pt-br : Portuguese (Brazil)\\n‚îÇ‚Ä¢ ro : Romanian\\n‚îÇ‚Ä¢ ru : Russian\\n‚îÇ‚Ä¢ sr : Serbian\\n‚îÇ‚Ä¢ es : Spanish\\n‚îÇ‚Ä¢ sv : Swedish\\n‚îÇ‚Ä¢ ta : Tamil\\n‚îÇ‚Ä¢ th : Thai\\n‚îÇ‚Ä¢ tr : Turkish\\n‚îÇ‚Ä¢ vi : Vietnamese\\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`;\r\n\t\t\t\t\tm.reply(list_tr)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!m.quoted && (!text|| !args[1])) return m.reply(`Kirim/reply text dengan caption ${prefix + command}`)\r\n\t\t\t\t\tlet lang = args[0] ? args[0] : 'id'\r\n\t\t\t\t\tlet teks = args[1] ? args.slice(1).join(' ') : m.quoted.text\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet hasil = await translate(teks, { to: lang, autoCorrect: true })\r\n\t\t\t\t\t\tm.reply(`To : ${lang}\\n${hasil[0]}`)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply(`Lang *${lang}* Tidak Di temukan!\\nSilahkan lihat list, ${prefix + command} list`)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'toqr': case 'qr': {\r\n\t\t\t\tif (!text) return m.reply(`Ubah Text ke Qr dengan *${prefix + command}* textnya`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tawait m.reply({ image: { url: 'https://api.qrserver.com/v1/create-qr-code/?size=1000x1000&data=' + text }, caption: 'Nih Bro' })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tohd': case 'remini': case 'hd': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (/image/.test(mime)) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\t\tlet hasil = await remini(media, 'enhance')\r\n\t\t\t\t\t\tm.reply({ image: hasil, caption: 'Done' })\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tlet media = await naze.downloadAndSaveMediaMessage(qmsg)\r\n\t\t\t\t\t\tlet ran = `./database/sampah/${getRandom('.jpg')}`;\r\n\t\t\t\t\t\tconst scaleFactor = isNaN(parseInt(text)) ? 4 : parseInt(text) < 10 ? parseInt(text) : 4;\r\n\t\t\t\t\t\texec(`ffmpeg -i \"${media}\" -vf \"scale=iw*${scaleFactor}:ih*${scaleFactor}:flags=lanczos\" -q:v 1 \"${ran}\"`, async (err, stderr, stdout) => {\r\n\t\t\t\t\t\t\tfs.unlinkSync(media)\r\n\t\t\t\t\t\t\tif (err) return m.reply(String(err))\r\n\t\t\t\t\t\t\tlet buff = fs.readFileSync(ran)\r\n\t\t\t\t\t\t\tawait naze.sendMedia(m.chat, buff, '', 'Done', m);\r\n\t\t\t\t\t\t\tfs.unlinkSync(ran)\r\n\t\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else m.reply(`Kirim/Reply Gambar dengan format\\nExample: ${prefix + command}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'dehaze': case 'colorize': case 'colorfull': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (/image/.test(mime)) {\r\n\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\tremini(media, 'dehaze').then(a => {\r\n\t\t\t\t\t\tm.reply({ image: a, caption: 'Done' })\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t}).catch(e => m.reply('Server sedang offline!'));\r\n\t\t\t\t} else m.reply(`Kirim/Reply Gambar dengan format\\nExample: ${prefix + command}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'hitamkan': case 'toblack': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (/image/.test(mime)) {\r\n\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\thitamkan(media, 'hitam').then(a => {\r\n\t\t\t\t\t\tm.reply({ image: a, caption: 'Done' })\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t}).catch(e => m.reply('Server sedang offline!'));\r\n\t\t\t\t} else m.reply(`Kirim/Reply Gambar dengan format\\nExample: ${prefix + command}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ssweb': {\r\n\t\t\t\tif (!isPremium) return m.reply(mess.prem)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} https://github.com/nazedev/naze-md`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = 'https://' + text.replace(/^https?:\\/\\//, '')\r\n\t\t\t\t\tawait m.reply({ image: { url: 'https://image.thum.io/get/width/1900/crop/1000/fullpage/' + anu }, caption: 'Done' })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server SS web Sedang Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'readmore': {\r\n\t\t\t\tlet teks1 = text.split`|`[0] ? text.split`|`[0] : ''\r\n\t\t\t\tlet teks2 = text.split`|`[1] ? text.split`|`[1] : ''\r\n\t\t\t\tm.reply(teks1 + readmore + teks2)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'getexif': {\r\n\t\t\t\tif (!m.quoted) return m.reply(`Reply sticker\\nDengan caption ${prefix + command}`)\r\n\t\t\t\tif (!/sticker|webp/.test(quoted.type)) return m.reply(`Reply sticker\\nDengan caption ${prefix + command}`)\r\n\t\t\t\tconst img = new webp.Image()\r\n\t\t\t\tawait img.load(await m.quoted.download())\r\n\t\t\t\tm.reply(util.format(JSON.parse(img.exif.slice(22).toString())))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'cuaca': case 'weather': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} jakarta`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet data = await fetchJson(`https://api.openweathermap.org/data/2.5/weather?q=${text}&units=metric&appid=060a6bcfa19809c2cd4d97a212b19273&language=en`)\r\n\t\t\t\t\tm.reply(`*üèô Cuaca Kota ${data.name}*\\n\\n*üå§Ô∏è Cuaca :* ${data.weather[0].main}\\n*üìù Deskripsi :* ${data.weather[0].description}\\n*üå°Ô∏è Suhu Rata-rata :* ${data.main.temp} ¬∞C\\n*ü§î Terasa Seperti :* ${data.main.feels_like} ¬∞C\\n*üå¨Ô∏è Tekanan :* ${data.main.pressure} hPa\\n*üíß Kelembapan :* ${data.main.humidity}%\\n*üå™Ô∏è Kecepatan Angin :* ${data.wind.speed} Km/h\\n*üìçLokasi :*\\n- *Bujur :* ${data.coord.lat}\\n- *Lintang :* ${data.coord.lon}\\n*üåè Negara :* ${data.sys.country}`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Kota Tidak Di Temukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'sticker': case 'stiker': case 's': case 'stickergif': case 'stikergif': case 'sgif': case 'stickerwm': case 'swm': case 'curi': case 'colong': case 'take': case 'stickergifwm': case 'sgifwm': {\r\n\t\t\t\tif (!/image|video|sticker/.test(quoted.type)) return m.reply(`Kirim/reply gambar/video/gif dengan caption ${prefix + command}\\nDurasi Image/Video/Gif 1-9 Detik`)\r\n\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\tlet teks1 = text.split`|`[0] ? text.split`|`[0] : packname\r\n\t\t\t\tlet teks2 = text.split`|`[1] ? text.split`|`[1] : author\r\n\t\t\t\tif (/image|webp/.test(mime)) {\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, media, m, { packname: teks1, author: teks2 })\r\n\t\t\t\t} else if (/video/.test(mime)) {\r\n\t\t\t\t\tif ((qmsg).seconds > 11) return m.reply('Maksimal 10 detik!')\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, media, m, { packname: teks1, author: teks2 })\r\n\t\t\t\t} else m.reply(`Kirim/reply gambar/video/gif dengan caption ${prefix + command}\\nDurasi Video/Gif 1-9 Detik`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'smeme': case 'stickmeme': case 'stikmeme': case 'stickermeme': case 'stikermeme': {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t//if (!isPremium) return m.reply(mess.prem)\r\n\t\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\t\tif (!/image|webp/.test(mime)) return m.reply(`Kirim/reply image/sticker\\nDengan caption ${prefix + command} atas|bawah`)\r\n\t\t\t\t\tif (!text) return m.reply(`Kirim/reply image/sticker dengan caption ${prefix + command} atas|bawah`)\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tlet atas = text.split`|`[0] ? text.split`|`[0] : '-'\r\n\t\t\t\t\tlet bawah = text.split`|`[1] ? text.split`|`[1] : '-'\r\n\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\tlet mem = await UguuSe(media)\r\n\t\t\t\t\tlet smeme = `https://api.memegen.link/images/custom/${encodeURIComponent(atas)}/${encodeURIComponent(bawah)}.png?background=${mem.url}`\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, smeme, m, { packname, author })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Meme Sedang Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'emojimix': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} üòÖ+ü§î`)\r\n\t\t\t\tlet [emoji1, emoji2] = text.split`+`\r\n\t\t\t\tif (!emoji1 && !emoji2) return m.reply(`Example: ${prefix + command} üòÖ+ü§î`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await axios.get(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`)\r\n\t\t\t\t\tif (anu.data.results.length < 1) return m.reply(`Mix Emoji ${text} Tidak Ditemukan!`)\r\n\t\t\t\t\tfor (let res of anu.data.results) {\r\n\t\t\t\t\t\tawait naze.sendAsSticker(m.chat, res.url, m, { packname, author })\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal Mix Emoji!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'qc': case 'quote': case 'fakechat': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text && !m.quoted) return m.reply(`Kirim/reply pesan *${prefix + command}* Teksnya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet ppnya = await naze.profilePictureUrl(m.sender, 'image').catch(() => 'https://i.pinimg.com/564x/8a/e9/e9/8ae9e92fa4e69967aa61bf2bda967b7b.jpg');\r\n\t\t\t\t\tlet res = await quotedLyo(text, m.pushName, ppnya);\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, Buffer.from(res.result.image, 'base64'), m, { packname, author })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Create Sedang Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'brat': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text && (!m.quoted || !m.quoted.text)) return m.reply(`Kirim/reply pesan *${prefix + command}* Teksnya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, 'https://aqul-brat.hf.space/?text=' + encodeURIComponent(text || m.quoted.text), m)\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Brat Sedang Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'bratvid': case 'bratvideo': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text && (!m.quoted || !m.quoted.text)) return m.reply(`Kirim/reply pesan *${prefix + command}* Teksnya`)\r\n\t\t\t\tconst teks = (m.quoted ? m.quoted.text : text).split(' ');\r\n\t\t\t\tconst tempDir = path.join(process.cwd(), 'database/sampah');\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst framePaths = [];\r\n\t\t\t\t\tfor (let i = 0; i < teks.length; i++) {\r\n\t\t\t\t\t\tconst currentText = teks.slice(0, i + 1).join(' ');\r\n\t\t\t\t\t\tlet res = await getBuffer('https://aqul-brat.hf.space/?text=' + encodeURIComponent(currentText));\r\n\t\t\t\t\t\tconst framePath = path.join(tempDir, `${m.sender + i}.mp4`);\r\n\t\t\t\t\t\tfs.writeFileSync(framePath, res);\r\n\t\t\t\t\t\tframePaths.push(framePath);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst fileListPath = path.join(tempDir, `${m.sender}.txt`);\r\n\t\t\t\t\tlet fileListContent = '';\r\n\t\t\t\t\tfor (let i = 0; i < framePaths.length; i++) {\r\n\t\t\t\t\t\tfileListContent += `file '${framePaths[i]}'\\n`;\r\n\t\t\t\t\t\tfileListContent += `duration 0.5\\n`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfileListContent += `file '${framePaths[framePaths.length - 1]}'\\n`;\r\n\t\t\t\t\tfileListContent += `duration 3\\n`;\r\n\t\t\t\t\tfs.writeFileSync(fileListPath, fileListContent);\r\n\t\t\t\t\tconst outputVideoPath = path.join(tempDir, `${m.sender}-output.mp4`);\r\n\t\t\t\t\texecSync(`ffmpeg -y -f concat -safe 0 -i ${fileListPath} -vf 'fps=30' -c:v libx264 -preset veryfast -pix_fmt yuv420p -t 00:00:10 ${outputVideoPath}`);\r\n\t\t\t\t\tnaze.sendAsSticker(m.chat, outputVideoPath, m, { packname, author })\r\n\t\t\t\t\tframePaths.forEach((filePath) => fs.unlinkSync(filePath));\r\n\t\t\t\t\tfs.unlinkSync(fileListPath);\r\n\t\t\t\t\tfs.unlinkSync(outputVideoPath);\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Terjadi Kesalahan Saat Memproses Permintaan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'wasted': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (/jpg|jpeg|png/.test(mime)) {\r\n\t\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\t\tlet anu = await UguuSe(media)\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, 'https://some-random-api.com/canvas/wasted?avatar=' + anu.url, 'Nih Bro', m)\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} else m.reply('Send Media yg ingin di Upload!')\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Canvas Sedang Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'trigger': case 'triggered': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (/jpg|jpeg|png/.test(mime)) {\r\n\t\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\t\tlet media = await quoted.download()\r\n\t\t\t\t\t\tlet anu = await UguuSe(media)\r\n\t\t\t\t\t\tawait m.reply({ document: { url: 'https://some-random-api.com/canvas/triggered?avatar=' + anu.url }, fileName: 'triggered.gif', mimetype: 'image/gif' })\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} else m.reply('Send Media yg ingin di Upload!')\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Canvas Sedang Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'nulis': {\r\n\t\t\t\tm.reply(`*Example*\\n${prefix}nuliskiri\\n${prefix}nuliskanan\\n${prefix}foliokiri\\n${prefix}foliokanan`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'nuliskiri': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Kirim perintah *${prefix + command}* Teksnya`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tconst splitText = text.replace(/(\\S+\\s*){1,9}/g, '$&\\n')\r\n\t\t\t\tconst fixHeight = splitText.split('\\n').slice(0, 31).join('\\n')\r\n\t\t\t\tspawn('convert', [\r\n\t\t\t\t\t'./src/nulis/images/buku/sebelumkiri.jpg',\r\n\t\t\t\t\t'-font',\r\n\t\t\t\t\t'./src/nulis/font/Indie-Flower.ttf',\r\n\t\t\t\t\t'-size',\r\n\t\t\t\t\t'960x1280',\r\n\t\t\t\t\t'-pointsize',\r\n\t\t\t\t\t'23',\r\n\t\t\t\t\t'-interline-spacing',\r\n\t\t\t\t\t'2',\r\n\t\t\t\t\t'-annotate',\r\n\t\t\t\t\t'+140+153',\r\n\t\t\t\t\tfixHeight,\r\n\t\t\t\t\t'./src/nulis/images/buku/setelahkiri.jpg'\r\n\t\t\t\t])\r\n\t\t\t\t.on('error', () => m.reply(mess.error))\r\n\t\t\t\t.on('exit', () => {\r\n\t\t\t\t\tm.reply({ image: fs.readFileSync('./src/nulis/images/buku/setelahkiri.jpg'), caption: 'Jangan Malas Lord. Jadilah siswa yang rajin ‡≤∞_‡≤∞' })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'nuliskanan': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Kirim perintah *${prefix + command}* Teksnya`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tconst splitText = text.replace(/(\\S+\\s*){1,9}/g, '$&\\n')\r\n\t\t\t\tconst fixHeight = splitText.split('\\n').slice(0, 31).join('\\n')\r\n\t\t\t\tspawn('convert', [\r\n\t\t\t\t\t'./src/nulis/images/buku/sebelumkanan.jpg',\r\n\t\t\t\t\t'-font',\r\n\t\t\t\t\t'./src/nulis/font/Indie-Flower.ttf',\r\n\t\t\t\t\t'-size',\r\n\t\t\t\t\t'960x1280',\r\n\t\t\t\t\t'-pointsize',\r\n\t\t\t\t\t'23',\r\n\t\t\t\t\t'-interline-spacing',\r\n\t\t\t\t\t'2',\r\n\t\t\t\t\t'-annotate',\r\n\t\t\t\t\t'+128+129',\r\n\t\t\t\t\tfixHeight,\r\n\t\t\t\t\t'./src/nulis/images/buku/setelahkanan.jpg'\r\n\t\t\t\t])\r\n\t\t\t\t.on('error', () => m.reply(mess.error))\r\n\t\t\t\t.on('exit', () => {\r\n\t\t\t\t\tm.reply({ image: fs.readFileSync('./src/nulis/images/buku/setelahkanan.jpg'), caption: 'Jangan Malas Lord. Jadilah siswa yang rajin ‡≤∞_‡≤∞' })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'foliokiri': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Kirim perintah *${prefix + command}* Teksnya`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tconst splitText = text.replace(/(\\S+\\s*){1,9}/g, '$&\\n')\r\n\t\t\t\tconst fixHeight = splitText.split('\\n').slice(0, 38).join('\\n')\r\n\t\t\t\tspawn('convert', [\r\n\t\t\t\t\t'./src/nulis/images/folio/sebelumkiri.jpg',\r\n\t\t\t\t\t'-font',\r\n\t\t\t\t\t'./src/nulis/font/Indie-Flower.ttf',\r\n\t\t\t\t\t'-size',\r\n\t\t\t\t\t'1720x1280',\r\n\t\t\t\t\t'-pointsize',\r\n\t\t\t\t\t'23',\r\n\t\t\t\t\t'-interline-spacing',\r\n\t\t\t\t\t'4',\r\n\t\t\t\t\t'-annotate',\r\n\t\t\t\t\t'+48+185',\r\n\t\t\t\t\tfixHeight,\r\n\t\t\t\t\t'./src/nulis/images/folio/setelahkiri.jpg'\r\n\t\t\t\t])\r\n\t\t\t\t.on('error', () => m.reply(mess.error))\r\n\t\t\t\t.on('exit', () => {\r\n\t\t\t\t\tm.reply({ image: fs.readFileSync('./src/nulis/images/folio/setelahkiri.jpg'), caption: 'Jangan Malas Lord. Jadilah siswa yang rajin ‡≤∞_‡≤∞' })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'foliokanan': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Kirim perintah *${prefix + command}* Teksnya`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\tconst splitText = text.replace(/(\\S+\\s*){1,9}/g, '$&\\n')\r\n\t\t\t\tconst fixHeight = splitText.split('\\n').slice(0, 38).join('\\n')\r\n\t\t\t\tspawn('convert', [\r\n\t\t\t\t\t'./src/nulis/images/folio/sebelumkanan.jpg',\r\n\t\t\t\t\t'-font',\r\n\t\t\t\t\t'./src/nulis/font/Indie-Flower.ttf',\r\n\t\t\t\t\t'-size',\r\n\t\t\t\t\t'1720x1280',\r\n\t\t\t\t\t'-pointsize',\r\n\t\t\t\t\t'23',\r\n\t\t\t\t\t'-interline-spacing',\r\n\t\t\t\t\t'4',\r\n\t\t\t\t\t'-annotate',\r\n\t\t\t\t\t'+89+190',\r\n\t\t\t\t\tfixHeight,\r\n\t\t\t\t\t'./src/nulis/images/folio/setelahkanan.jpg'\r\n\t\t\t\t])\r\n\t\t\t\t.on('error', () => m.reply(mess.error))\r\n\t\t\t\t.on('exit', () => {\r\n\t\t\t\t\tm.reply({ image: fs.readFileSync('./src/nulis/images/folio/setelahkanan.jpg'), caption: 'Jangan Malas Lord. Jadilah siswa yang rajin ‡≤∞_‡≤∞' })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'bass': case 'blown': case 'deep': case 'earrape': case 'fast': case 'fat': case 'nightcore': case 'reverse': case 'robot': case 'slow': case 'smooth': case 'tupai': {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet set;\r\n\t\t\t\t\tif (/bass/.test(command)) set = '-af equalizer=f=54:width_type=o:width=2:g=20'\r\n\t\t\t\t\tif (/blown/.test(command)) set = '-af acrusher=.1:1:64:0:log'\r\n\t\t\t\t\tif (/deep/.test(command)) set = '-af atempo=4/4,asetrate=44500*2/3'\r\n\t\t\t\t\tif (/earrape/.test(command)) set = '-af volume=12'\r\n\t\t\t\t\tif (/fast/.test(command)) set = '-filter:a \"atempo=1.63,asetrate=44100\"'\r\n\t\t\t\t\tif (/fat/.test(command)) set = '-filter:a \"atempo=1.6,asetrate=22100\"'\r\n\t\t\t\t\tif (/nightcore/.test(command)) set = '-filter:a atempo=1.06,asetrate=44100*1.25'\r\n\t\t\t\t\tif (/reverse/.test(command)) set = '-filter_complex \"areverse\"'\r\n\t\t\t\t\tif (/robot/.test(command)) set = '-filter_complex \"afftfilt=real=\\'hypot(re,im)*sin(0)\\':imag=\\'hypot(re,im)*cos(0)\\':win_size=512:overlap=0.75\"'\r\n\t\t\t\t\tif (/slow/.test(command)) set = '-filter:a \"atempo=0.7,asetrate=44100\"'\r\n\t\t\t\t\tif (/smooth/.test(command)) set = '-filter:v \"minterpolate=\\'mi_mode=mci:mc_mode=aobmc:vsbmc=1:fps=120\\'\"'\r\n\t\t\t\t\tif (/tupai/.test(command)) set = '-filter:a \"atempo=0.5,asetrate=65100\"'\r\n\t\t\t\t\tif (/audio/.test(mime)) {\r\n\t\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\t\tlet media = await naze.downloadAndSaveMediaMessage(qmsg)\r\n\t\t\t\t\t\tlet ran = `./database/sampah/${getRandom('.mp3')}`;\r\n\t\t\t\t\t\texec(`ffmpeg -i ${media} ${set} ${ran}`, (err, stderr, stdout) => {\r\n\t\t\t\t\t\t\tfs.unlinkSync(media)\r\n\t\t\t\t\t\t\tif (err) return m.reply(err)\r\n\t\t\t\t\t\t\tlet buff = fs.readFileSync(ran)\r\n\t\t\t\t\t\t\tm.reply({ audio: buff, mimetype: 'audio/mpeg' })\r\n\t\t\t\t\t\t\tfs.unlinkSync(ran)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else m.reply(`Balas audio yang ingin diubah dengan caption *${prefix + command}*`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tinyurl': case 'shorturl': case 'shortlink': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text || !isUrl(text)) return m.reply(`Example: ${prefix + command} https://github.com/nazedev/hitori`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await axios.get('https://tinyurl.com/api-create.php?url=' + text)\r\n\t\t\t\t\tm.reply('Url : ' + anu.data)\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'git': case 'gitclone': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!args[0]) return m.reply(`Example: ${prefix + command} https://github.com/nazedev/hitori`)\r\n\t\t\t\tif (!isUrl(args[0]) && !args[0].includes('github.com')) return m.reply('Gunakan Url Github!')\r\n\t\t\t\tlet [, user, repo] = args[0].match(/(?:https|git)(?::\\/\\/|@)github\\.com[\\/:]([^\\/:]+)\\/(.+)/i) || []\r\n\t\t\t\ttry {\r\n\t\t\t\t\tm.reply({ document: { url: `https://api.github.com/repos/${user}/${repo}/zipball` }, fileName: repo + '.zip', mimetype: 'application/zip' }).catch((e) => m.reply(mess.error))\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Ai Menu\r\n\t\t\tcase 'ai': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} query`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet hasil = await yanzGpt([{ role: 'system', content: '' }, { role: 'user', content: text }])\r\n\t\t\t\t\tm.reply(hasil.choices[0].message.content)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet hasil = await youSearch(text)\r\n\t\t\t\t\t\tm.reply(hasil)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tlet hasil = await bk9Ai(text)\r\n\t\t\t\t\t\t\tm.reply(hasil.BK9)\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\tm.reply(pickRandom(['Fitur Ai sedang bermasalah!','Tidak dapat terhubung ke ai!','Sistem Ai sedang sibuk sekarang!','Fitur sedang tidak dapat digunakan!']))\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'simi': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} query`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await simi(text)\r\n\t\t\t\t\tm.reply(hasil.success)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server simi sedang offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'bard': case 'gemini': case 'aiedit': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} tanggal berapa sekarang?`)\r\n\t\t\t\tif (!(APIKeys.geminiApikey?.length > 0 && APIKeys.geminiApikey?.some(a => a.trim() !== ''))) return m.reply('Silahkan Ambil Apikey Terlebih dahulu di\\nhttps://aistudio.google.com/app/apikey')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet apinya = pickRandom(APIKeys.geminiApikey)\r\n\t\t\t\t\tgeminiAi(text, apinya, quoted.isMedia ? { mime: quoted.mime, media: await quoted.download() } : {}).then(a => {\r\n\t\t\t\t\t\tif (a.media) naze.sendMedia(m.chat, a.media, '', a.text || '', m)\r\n\t\t\t\t\t\telse if (a.text) m.reply(a.text)\r\n\t\t\t\t\t}).catch(e => {\r\n\t\t\t\t\t\tif (e.status === 503) m.reply('Model Gemini sedang sibuk, coba beberapa saat lagi...')\r\n\t\t\t\t\t\telse if (e.status === 400) m.reply('API key not valid. Please pass a valid API key.')\r\n\t\t\t\t\t\telse m.reply('Apikeymu limit atau terjadi error lain!')\r\n\t\t\t\t\t})\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Apikeymu limit!\\nSilahkan Ganti dengan apikey lain!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Search Menu\r\n\t\t\tcase 'google': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} query`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await youSearch(text);\r\n\t\t\t\t\tm.reply(anu)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet anu = await yanzGpt([{ role: 'system', content: 'carikan informasi tentang hal tersebut secara mendetail, dengan sumbernya juga!' }, { role: 'user', content: text }]);\r\n\t\t\t\t\t\tm.reply(hasil.choices[0].message.content)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Pencarian Tidak Ditemukan!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'gimage': case 'bingimg': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} query`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await fetchApi('/search/bing', { query: text });\r\n\t\t\t\t\tlet una = pickRandom(anu.result)\r\n\t\t\t\t\tawait m.reply({ image: { url: una }, caption: 'Hasil Pencarian ' + text })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Pencarian Tidak Ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'play': case 'ytplay': case 'yts': case 'ytsearch': case 'youtubesearch': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} dj komang`)\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await yts.search(text);\r\n\t\t\t\t\tconst hasil = pickRandom(res.all)\r\n\t\t\t\t\tconst teksnya = `*üìçTitle:* ${hasil.title || 'Tidak tersedia'}\\n*‚úèDescription:* ${hasil.description || 'Tidak tersedia'}\\n*üåüChannel:* ${hasil.author?.name || 'Tidak tersedia'}\\n*‚è≥Duration:* ${hasil.seconds || 'Tidak tersedia'} second (${hasil.timestamp || 'Tidak tersedia'})\\n*üîéSource:* ${hasil.url || 'Tidak tersedia'}\\n\\n_note : jika ingin mendownload silahkan_\\n_pilih ${prefix}ytmp3 url_video atau ${prefix}ytmp4 url_video_`;\r\n\t\t\t\t\tawait m.reply({ image: { url: hasil.thumbnail }, caption: teksnya })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tconst nvl = new NvlGroup();\r\n\t\t\t\t\t\tlet anu = await nvl.search(text);\r\n\t\t\t\t\t\tlet hasil = pickRandom(anu.videos)\r\n\t\t\t\t\t\tlet teksnya = `*üìçTitle:* ${hasil.title || 'Tidak tersedia'}\\n*‚úèUpload At:* ${hasil.uploaded || 'Tidak tersedia'}\\n*üåüChannel:* ${hasil.author || 'Tidak tersedia'}\\n*‚è≥Duration:* ${hasil.duration || 'Tidak tersedia'}\\n*üîéSource:* ${hasil.url || 'Tidak tersedia'}\\n\\n_note : jika ingin mendownload silahkan_\\n_pilih ${prefix}ytmp3 url_video atau ${prefix}ytmp4 url_video_`;\r\n\t\t\t\t\t\tawait m.reply({ image: { url: hasil.thumbnail }, caption: teksnya })\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tconst res = await fetchApi('/search/youtube', { query: text });\r\n\t\t\t\t\t\t\tconst hasil = pickRandom(res.data)\r\n\t\t\t\t\t\t\tconst teksnya = `*üìçTitle:* ${hasil.title || 'Tidak tersedia'}\\n*‚úèDescription:* ${hasil.description || 'Tidak tersedia'}\\n*üåüChannel:* ${hasil.channelTitle || 'Tidak tersedia'}\\n*‚è≥Duration:* ${hasil.duration || 'Tidak tersedia'}\\n*üîéSource:* https://youtu.be/${hasil.id || 'Tidak tersedia'}\\n\\n_note : jika ingin mendownload silahkan_\\n_pilih ${prefix}ytmp3 url_video atau ${prefix}ytmp4 url_video_`;\r\n\t\t\t\t\t\t\tawait m.reply({ image: { url: hasil.thumbMedium }, caption: teksnya })\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\tm.reply('Post not available!')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'pixiv': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} hu tao`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet { pixivdl } = require('./lib/pixiv')\r\n\t\t\t\t\tlet res = await pixivdl(text)\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tfor (let i = 0; i < res.media.length; i++) {\r\n\t\t\t\t\t\tlet caption = i == 0 ? `${res.caption}\\n\\n*By:* ${res.artist}\\n*Tags:* ${res.tags.join(', ')}` : ''\r\n\t\t\t\t\t\tlet mime = (await FileType.fromBuffer(res.media[i])).mime \r\n\t\t\t\t\t\tawait m.reply({ [mime.split('/')[0]]: res.media[i], caption, mimetype: mime })\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Post not available!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'pinterest': case 'pint': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} hu tao`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await pinterest(text)\r\n\t\t\t\t\tlet result = pickRandom(anu)\r\n\t\t\t\t\tif (anu.length < 1) {\r\n\t\t\t\t\t\tm.reply('Post not available!');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tawait m.reply({ image: { url: result.images_url }, caption: `*Media Url :* ${result.pin}${result.link ? '\\n*Source :* ' + result.link : ''}` })\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tconst res = await fetchApi('/search/pinterest', { query: text });\r\n\t\t\t\t\t\tconst hasil = pickRandom(res.data.result.pins)\r\n\t\t\t\t\t\tawait m.reply({ image: { url: hasil.media.images.orig.url }, caption: `*Media Url :* ${hasil.media.images.orig.url}${hasil.pin_url ? '\\n*Source :* ' + hasil.pin_url : ''}` })\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Pencarian tidak ditemukan!');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'wallpaper': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} hu tao`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await wallpaper(text)\r\n\t\t\t\t\tlet result = pickRandom(anu)\r\n\t\t\t\t\tif (anu.length < 1) {\r\n\t\t\t\t\t\tm.reply('Post not available!');\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tawait m.reply({ image: { url: result.image[0] }, caption: `‚≠î title : ${q}\\n‚≠î category : ${result.type}\\n‚≠î media url : ${result.image[2] || result.image[1] || result.image[0]}`})\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet anu = await pinterest('wallpaper ' + text)\r\n\t\t\t\t\t\tlet result = pickRandom(anu)\r\n\t\t\t\t\t\tif (anu.length < 1) {\r\n\t\t\t\t\t\t\tm.reply('Post not available!');\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tawait m.reply({ image: { url: result.images_url }, caption: `*Media Url :* ${result.pin}${result.link ? '\\n*Source :* ' + result.link : ''}` })\r\n\t\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Server wallpaper sedang offline!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ringtone': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} black rover`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await ringtone(text)\r\n\t\t\t\t\tlet result = pickRandom(anu)\r\n\t\t\t\t\tawait m.reply({ audio: { url: result.audio }, fileName: result.title + '.mp3', mimetype: 'audio/mpeg' })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Audio tidak ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'npm': case 'npmjs': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} axios`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet res = await fetch(`http://registry.npmjs.com/-/v1/search?text=${text}`)\r\n\t\t\t\t\tlet { objects } = await res.json()\r\n\t\t\t\t\tif (!objects.length) return m.reply('Pencarian Tidak di temukan')\r\n\t\t\t\t\tlet txt = objects.map(({ package: pkg }) => {\r\n\t\t\t\t\t\treturn `*${pkg.name}* (v${pkg.version})\\n_${pkg.links.npm}_\\n_${pkg.description}_`\r\n\t\t\t\t\t}).join`\\n\\n`\r\n\t\t\t\t\tm.reply(txt)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Pencarian Tidak di temukan')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'style': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} Naze`)\r\n\t\t\t\tlet anu = await styletext(text)\r\n\t\t\t\tlet txt = anu.map(a => `*${a.name}*\\n${a.result}`).join`\\n\\n`\r\n\t\t\t\tm.reply(txt)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'spotify': case 'spotifysearch': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} alan walker alone`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet hasil = await fetchJson('https://www.bhandarimilan.info.np/spotisearch?query=' + encodeURIComponent(text));\r\n\t\t\t\t\tlet txt = hasil.map(a => {\r\n\t\t\t\t\t\treturn `*Name : ${a.name}*\\n- Artist : ${a.artist}\\n- Url : ${a.link}`\r\n\t\t\t\t\t}).join`\\n\\n`\r\n\t\t\t\t\tm.reply(txt)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server Search Offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tenor': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} alone`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst anu = await fetchJson('https://g.tenor.com/v1/search?q=' + text + '&key=LIVDSRZULELA')\r\n\t\t\t\t\tconst hasil = pickRandom(anu.results)\r\n\t\t\t\t\tawait m.reply({ video: { url: hasil.media[0].mp4.url }, caption: `üëÄ *Media:* ${hasil.url}\\nüìã *Description:* ${hasil.content_description}\\nüîõ *Url:* ${hasil.itemurl}`, gifPlayback: true, gifAttribution: 2 })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Hasil Tidak Ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'urban': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} alone`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst anu = await fetchJson('https://api.urbandictionary.com/v0/define?term=' + text)\r\n\t\t\t\t\tconst hasil = pickRandom(anu.list)\r\n\t\t\t\t\tawait m.reply(`${hasil.definition}\\n\\nSumber: ${hasil.permalink}`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Hasil Tidak Ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Stalker Menu\r\n\t\t\tcase 'igstalk': case 'instagramstalk': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} usernamenya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet anu = await instaStalk(text)\r\n\t\t\t\t\tm.reply({ image: { url: anu.avatar }, caption: `*Username :* ${anu.username}\\n*Nickname :* ${anu.nickname}\\n*Bio :* ${anu.description}\\n*Posts :* ${anu.posts}\\n*Followers :* ${anu.followers}\\n*Following :* ${anu.following}\\n*List Post :* ${anu.list_post.map(a => `\\n*Url :* ${a.imageUrl}\\n*Description :* ${a.description}\\n*Detail :* ${a.detailUrl}`).join('\\n')}` })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet res = await fetchApi('/stalk/instagram', { username: text });\r\n\t\t\t\t\t\tm.reply({ image: { url: res.data.profile_picture_url }, caption: `*Username :*${res.data?.username || 'Tidak Ada'}\\n*Nickname :*${res.data?.full_name || 'Tidak Ada'}\\n*ID :*${res.data?.instagram_id}\\n*Followers :*${res.data?.followers || '0'}\\n*Following :*${res.data?.following || '0'}\\n*Description :*${res.data?.description || 'Tidak Ada'}\\n*Website :*${res.data?.website || 'Tidak Ada'}\\n*Add At :*${res.data?.added_date}\\n*Uploads :*${res.data?.uploads}\\n*Verified :*${res.data?.is_verified}\\n*Private :*${res.data.is_private}\\n` })\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Username Tidak ditemukan!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'wastalk': case 'whatsappstalk': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} @tag / 628xxx`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet num = m.quoted?.sender || m.mentionedJid?.[0] || text\r\n\t\t\t\t\tif (!num) return m.reply(`Example : ${prefix + command} @tag / 628xxx`)\r\n\t\t\t\t\tnum = num.replace(/\\D/g, '') + '@s.whatsapp.net'\r\n\t\t\t\t\tif (!(await naze.onWhatsApp(num))[0]?.exists) return m.reply('Nomer tidak terdaftar di WhatsApp!')\r\n\t\t\t\t\tlet img = await naze.profilePictureUrl(num, 'image').catch(_ => 'https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_960_720.png?q=60')\r\n\t\t\t\t\tlet bio = await naze.fetchStatus(num).catch(_ => { })\r\n\t\t\t\t\tlet name = await naze.getName(num)\r\n\t\t\t\t\tlet business = await naze.getBusinessProfile(num)\r\n\t\t\t\t\tlet format = PhoneNum(`+${num.split('@')[0]}`)\r\n\t\t\t\t\tlet regionNames = new Intl.DisplayNames(['en'], { type: 'region' });\r\n\t\t\t\t\tlet country = regionNames.of(format.getRegionCode('international'));\r\n\t\t\t\t\tlet wea = `WhatsApp Stalk\\n\\n*¬∞ Country :* ${country.toUpperCase()}\\n*¬∞ Name :* ${name ? name : '-'}\\n*¬∞ Format Number :* ${format.getNumber('international')}\\n*¬∞ Url Api :* wa.me/${num.split('@')[0]}\\n*¬∞ Mentions :* @${num.split('@')[0]}\\n*¬∞ Status :* ${bio?.status || '-'}\\n*¬∞ Date Status :* ${bio?.setAt ? moment(bio.setAt.toDateString()).locale('id').format('LL') : '-'}\\n\\n${business ? `*WhatsApp Business Stalk*\\n\\n*¬∞ BusinessId :* ${business.wid}\\n*¬∞ Website :* ${business.website ? business.website : '-'}\\n*¬∞ Email :* ${business.email ? business.email : '-'}\\n*¬∞ Category :* ${business.category}\\n*¬∞ Address :* ${business.address ? business.address : '-'}\\n*¬∞ Timeone :* ${business.business_hours.timezone ? business.business_hours.timezone : '-'}\\n*¬∞ Description* : ${business.description ? business.description : '-'}` : '*Standard WhatsApp Account*'}`\r\n\t\t\t\t\timg ? await naze.sendMessage(m.chat, { image: { url: img }, caption: wea, mentions: [num] }, { quoted: m }) : m.reply(wea)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Nomer Tidak ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'telestalk': case 'telegramstalk': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} usernamenya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await telegramStalk(text)\r\n\t\t\t\t\tif (!res.description || res.title.startsWith('Telegram: Contact')) throw 'Error'\r\n\t\t\t\t\tm.reply({ image: { url: res.image_url }, caption: `*Username :* ${text}\\n*Nickname :* ${res.title || 'Tidak ada'}\\n*Desc :* ${res.description || 'Tidak ada'}\\n*Url :* ${res.url}`})\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Username Tidak ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tiktokstalk': case 'ttstalk': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} usernamenya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await tiktokStalk(text)\r\n\t\t\t\t\tm.reply({ image: { url: res.avatarThumb }, caption: `*Username :* ${text}\\n*Nickname :* ${res.nickname}\\n*Followers :* ${res.followerCount}\\n*Following :* ${res.followingCount}\\n*Bio :* ${res.signature}\\n*Verified :* ${res.verified}\\n*Video Count :* ${res.videoCount}\\n*Heart Count :* ${res.heartCount}` })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Username Tidak ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'genshinstalk': case 'gistalk': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} idnya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await genshinStalk(text)\r\n\t\t\t\t\tm.reply({ image: { url: res.image }, caption: `*Genshin profile*\\n- *ID :* ${res.uid}\\n- *Nickname :* ${res.nickname}\\n- *Signature :* ${res.signature}\\n- *Level :* ${res.level}\\n- *World Level :* ${res.world_level}\\n- *Achivement :* ${res.achivement}\\n- *Spiral Abyss :* ${res.spiral_abyss}\\n- *Ttl :* ${res.ttl}` })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Username Tidak ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ghstalk': case 'githubstalk': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} usernamenya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await fetchJson('https://api.github.com/users/' + text)\r\n\t\t\t\t\tm.reply({ image: { url: res.avatar_url }, caption: `*Username :* ${res.login}\\n*Nickname :* ${res.name || 'Tidak ada'}\\n*Bio :* ${res.bio || 'Tidak ada'}\\n*ID :* ${res.id}\\n*Node ID :* ${res.node_id}\\n*Type :* ${res.type}\\n*Admin :* ${res.admin ? 'Ya' : 'Tidak'}\\n*Company :* ${res.company || 'Tidak ada'}\\n*Blog :* ${res.blog || 'Tidak ada'}\\n*Location :* ${res.location || 'Tidak ada'}\\n*Email :* ${res.email || 'Tidak ada'}\\n*Public Repo :* ${res.public_repos}\\n*Public Gists :* ${res.public_gists}\\n*Followers :* ${res.followers}\\n*Following :* ${res.following}\\n*Created At :* ${res.created_at} *Updated At :* ${res.updated_at}` })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Username Tidak ditemukan!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Downloader Menu\r\n\t\t\tcase 'ytmp3': case 'ytaudio': case 'ytplayaudio': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} url_youtube`)\r\n\t\t\t\tif (!text.includes('youtu')) return m.reply('Url Tidak Mengandung Result Dari Youtube!')\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await ytMp3(text);\r\n\t\t\t\t\tawait m.reply({\r\n\t\t\t\t\t\taudio: { url: hasil.result },\r\n\t\t\t\t\t\tmimetype: 'audio/mpeg',\r\n\t\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\t\ttitle: hasil.title,\r\n\t\t\t\t\t\t\t\tbody: hasil.channel,\r\n\t\t\t\t\t\t\t\tpreviewType: 'PHOTO',\r\n\t\t\t\t\t\t\t\tthumbnailUrl: hasil.thumb,\r\n\t\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t\t\tsourceUrl: text\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet hasil = await savetube.download(text, 'mp3')\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.result.download, hasil.result.title, m)\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tconst nvl = new NvlGroup();\r\n\t\t\t\t\t\t\tlet anu = await nvl.download(text);\r\n\t\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, anu.audio[0].url, anu.audio[0].size, m)\r\n\t\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tlet hasil = await fetchApi('/download/youtube', { url: text })\r\n\t\t\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.result.audio, hasil.result.title, m)\r\n\t\t\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\tm.reply('Gagal Mendownload Audio!')\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ytmp4': case 'ytvideo': case 'ytplayvideo': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} url_youtube`)\r\n\t\t\t\tif (!text.includes('youtu')) return m.reply('Url Tidak Mengandung Result Dari Youtube!')\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await ytMp4(text);\r\n\t\t\t\t\tawait m.reply({ video: hasil.result, caption: `*üìçTitle:* ${hasil.title}\\n*‚úèDescription:* ${hasil.desc ? hasil.desc : ''}\\n*üöÄChannel:* ${hasil.channel}\\n*üóìUpload at:* ${hasil.uploadDate}` })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet hasil = await savetube.download(text, '360')\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.result.download, hasil.result.title, m)\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tconst nvl = new NvlGroup();\r\n\t\t\t\t\t\t\tlet anu = await nvl.download(text);\r\n\t\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, anu.video.find(v => v.height === 360).url || anu.video[0].url, 'Done', m)\r\n\t\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tlet hasil = await fetchApi('/download/youtube', { url: text })\r\n\t\t\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.result.video, hasil.result.title, m)\r\n\t\t\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\tm.reply('Gagal Mendownload Audio!')\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ig': case 'instagram': case 'instadl': case 'igdown': case 'igdl': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} url_instagram`)\r\n\t\t\t\tif (!text.includes('instagram.com')) return m.reply('Url Tidak Mengandung Result Dari Instagram!')\r\n\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await instagramDl(text);\r\n\t\t\t\t\tif(hasil.length < 0) return m.reply('Postingan Tidak Tersedia atau Privat!')\r\n\t\t\t\t\tfor (let i = 0; i < hasil.length; i++) {\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil[i].url, 'Done', m)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet hasil = await fetchApi('/download/instagram', { url: text })\r\n\t\t\t\t\t\tif(hasil.result.url.length < 0) return m.reply('Postingan Tidak Tersedia atau Privat!')\r\n\t\t\t\t\t\tfor (let i = 0; i < hasil.result.url.length; i++) {\r\n\t\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.result.url[i], 'Done', m)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Postingan Tidak Tersedia atau Privat!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'igstory': case 'instagramstory': case 'instastory': case 'storyig': {\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} usernamenya`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await instaStory(text);\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tfor (let i = 0; i < hasil.results.length; i++) {\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.results[i].url, 'Done', m)\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Username tidak ditemukan atau Privat!');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tiktok': case 'tiktokdown': case 'ttdown': case 'ttdl': case 'tt': case 'ttmp4': case 'ttvideo': case 'tiktokmp4': case 'tiktokvideo': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} url_tiktok`)\r\n\t\t\t\tif (!text.includes('tiktok.com')) return m.reply('Url Tidak Mengandung Result Dari Tiktok!')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await tiktokDl(text);\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tif (hasil && hasil.size_nowm) {\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.data[1].url, `*üìçTitle:* ${hasil.title}\\n*‚è≥Duration:* ${hasil.duration}\\n*üéÉAuthor:* ${hasil.author.nickname} (@${hasil.author.fullname})`, m)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (let i = 0; i < hasil.data.length; i++) {\r\n\t\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.data[i].url, `*üöÄImage:* ${i+1}`, m)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal/Url tidak valid!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ttmp3': case 'tiktokmp3': case 'ttaudio': case 'tiktokaudio': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} url_tiktok`)\r\n\t\t\t\tif (!text.includes('tiktok.com')) return m.reply('Url Tidak Mengandung Result Dari Tiktok!')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await tiktokDl(text);\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tawait m.reply({\r\n\t\t\t\t\t\taudio: { url: hasil.music_info.url },\r\n\t\t\t\t\t\tmimetype: 'audio/mpeg',\r\n\t\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\t\ttitle: 'TikTok ‚Ä¢ ' + hasil.author.nickname,\r\n\t\t\t\t\t\t\t\tbody: hasil.stats.likes + ' suka, ' + hasil.stats.comment + ' komentar. ' + hasil.title,\r\n\t\t\t\t\t\t\t\tpreviewType: 'PHOTO',\r\n\t\t\t\t\t\t\t\tthumbnailUrl: hasil.cover,\r\n\t\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t\t\tsourceUrl: text\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Gagal/Url tidak valid!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'fb': case 'fbdl': case 'fbdown': case 'facebook': case 'facebookdl': case 'facebookdown': case 'fbdownload': case 'fbmp4': case 'fbvideo': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} url_facebook`)\r\n\t\t\t\tif (!text.includes('facebook.com')) return m.reply('Url Tidak Mengandung Result Dari Facebook!')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await facebookDl(text);\r\n\t\t\t\t\tif (hasil.results.length < 1) {\r\n\t\t\t\t\t\tm.reply('Video Tidak ditemukan!')\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, hasil.results[0].url, `*üéêTitle:* ${hasil.caption}`, m);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server downloader facebook sedang offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'mediafire': case 'mf': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} https://www.mediafire.com/file/xxxxxxxxx/xxxxx.zip/file`)\r\n\t\t\t\tif (!isUrl(args[0]) && !args[0].includes('mediafire.com')) return m.reply('Url Invalid!')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst anu = await mediafireDl(text)\r\n\t\t\t\t\tawait m.reply({ document: { url: anu.link }, caption: `*MEDIAFIRE DOWNLOADER*\\n\\n*${setv} Name* : ${anu.name}\\n*${setv} Size* : ${anu.size}\\n*${setv} Type* : ${anu.type}\\n*${setv} Upload At* : ${anu.upload_date}\\n*${setv} Link* : ${anu.link}`, fileName: anu.name, mimetype: anu.type })\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tlet anu = await fetchApi('/download/mediafire', { url: text })\r\n\t\t\t\t\t\tawait naze.sendMedia(m.chat, anu.data.url, anu.data.filename, `*MEDIAFIRE DOWNLOADER*\\n\\n*${setv} Name* : ${anu.data.filename}\\n*${setv} Size* : ${anu.data.size}`, m)\r\n\t\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Server download sedang offline!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'spotifydl': {\r\n\t\t\t\tif (!isLimit) return m.reply(mess.limit)\r\n\t\t\t\tif (!text) return m.reply(`Example: ${prefix + command} https://open.spotify.com/track/0JiVRyTJcJnmlwCZ854K4p`)\r\n\t\t\t\tif (!isUrl(args[0]) && !args[0].includes('open.spotify.com/track')) return m.reply('Url Invalid!')\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst hasil = await spotifyDl(text);\r\n\t\t\t\t\tm.reply(mess.wait)\r\n\t\t\t\t\tawait m.reply({\r\n\t\t\t\t\t\taudio: { url: hasil.download },\r\n\t\t\t\t\t\tmimetype: 'audio/mpeg',\r\n\t\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\t\ttitle: hasil.title,\r\n\t\t\t\t\t\t\t\tbody: clockString(hasil.duration),\r\n\t\t\t\t\t\t\t\tpreviewType: 'PHOTO',\r\n\t\t\t\t\t\t\t\tthumbnailUrl: hasil.cover,\r\n\t\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t\t\tsourceUrl: text\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tconsole.log(e)\r\n\t\t\t\t\tm.reply('Server download sedang offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Quotes Menu\r\n\t\t\tcase 'motivasi': {\r\n\t\t\t\tconst hasil = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/motivasi.json');\r\n\t\t\t\tm.reply(pickRandom(hasil))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'bijak': {\r\n\t\t\t\tconst hasil = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/bijak.json');\r\n\t\t\t\tm.reply(pickRandom(hasil))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'dare': {\r\n\t\t\t\tconst hasil = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/dare.json');\r\n\t\t\t\tm.reply(pickRandom(hasil))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'quotes': {\r\n\t\t\t\tconst res = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/quotes.json');\r\n\t\t\t\tconst hasil = pickRandom(res);\r\n\t\t\t\tm.reply(`_${hasil.quotes}_\\n\\n*- ${hasil.author}*`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'truth': {\r\n\t\t\t\tconst hasil = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/truth.json');\r\n\t\t\t\tm.reply(`_${pickRandom(hasil)}_`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'renungan': {\r\n\t\t\t\tconst hasil = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/renungan.json');\r\n\t\t\t\tm.reply('', {\r\n\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\tforwardingScore: 10,\r\n\t\t\t\t\t\tisForwarded: true,\r\n\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\ttitle: (m.pushName || 'Anonim'),\r\n\t\t\t\t\t\t\tthumbnailUrl: pickRandom(hasil),\r\n\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t\tpreviewType: 'PHOTO',\r\n\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'bucin': {\r\n\t\t\t\tconst hasil = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/kata-kata/bucin.json');\r\n\t\t\t\tm.reply(pickRandom(hasil))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Random Menu\r\n\t\t\tcase 'coffe': case 'kopi': {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tawait naze.sendFileUrl(m.chat, 'https://coffee.alexflipnote.dev/random', '‚òï Random Coffe', m)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tconst anu = await fetchJson('https://api.sampleapis.com/coffee/hot')\r\n\t\t\t\t\t\tawait naze.sendFileUrl(m.chat, pickRandom(anu).image, '‚òï Random Coffe', m)\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tm.reply('Server Sedang Offline!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Anime Menu\r\n\t\t\tcase 'waifu': case 'neko': {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (!isNsfw && text === 'nsfw') return m.reply('Filter Nsfw Sedang Aktif!')\r\n\t\t\t\t\tconst res = await fetchJson('https://api.waifu.pics/' + (text === 'nsfw' ? 'nsfw' : 'sfw') + '/' + command)\r\n\t\t\t\t\tawait naze.sendFileUrl(m.chat, res.url, 'Random Waifu', m)\r\n\t\t\t\t\tsetLimit(m, db)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply('Server sedang offline!')\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Fun Menu\r\n\t\t\tcase 'dadu': {\r\n\t\t\t\tlet ddsa = [{ url: 'https://telegra.ph/file/9f60e4cdbeb79fc6aff7a.png', no: 1 },{ url: 'https://telegra.ph/file/797f86e444755282374ef.png', no: 2 },{ url: 'https://telegra.ph/file/970d2a7656ada7c579b69.png', no: 3 },{ url: 'https://telegra.ph/file/0470d295e00ebe789fb4d.png', no: 4 },{ url: 'https://telegra.ph/file/a9d7332e7ba1d1d26a2be.png', no: 5 },{ url: 'https://telegra.ph/file/99dcd999991a79f9ba0c0.png', no: 6 }]\r\n\t\t\t\tlet media = pickRandom(ddsa)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, media.url, m, { packname, author, isAvatar: 1 })\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tlet anu = await fetch(media.url)\r\n\t\t\t\t\tlet una = await anu.buffer()\r\n\t\t\t\t\tawait naze.sendAsSticker(m.chat, una, m, { packname, author, isAvatar: 1 })\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'halah': case 'hilih': case 'huluh': case 'heleh': case 'holoh': {\r\n\t\t\t\tif (!m.quoted && !text) return m.reply(`Kirim/reply text dengan caption ${prefix + command}`)\r\n\t\t\t\tter = command[1].toLowerCase()\r\n\t\t\t\ttex = m.quoted ? m.quoted.text ? m.quoted.text : q ? q : m.text : q ? q : m.text\r\n\t\t\t\tm.reply(tex.replace(/[aiueo]/g, ter).replace(/[AIUEO]/g, ter.toUpperCase()))\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'bisakah': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} saya menang?`)\r\n\t\t\t\tlet bisa = ['Bisa','Coba Saja','Pasti Bisa','Mungkin Saja','Tidak Bisa','Tidak Mungkin','Coba Ulangi','Ngimpi kah?','yakin bisa?']\r\n\t\t\t\tlet keh = bisa[Math.floor(Math.random() * bisa.length)]\r\n\t\t\t\tm.reply(`*Bisakah ${text}*\\nJawab : ${keh}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'apakah': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} saya bisa menang?`)\r\n\t\t\t\tlet apa = ['Iya','Tidak','Bisa Jadi','Coba Ulangi','Mungkin Saja','Mungkin Tidak','Mungkin Iya','Ntahlah']\r\n\t\t\t\tlet kah = apa[Math.floor(Math.random() * apa.length)]\r\n\t\t\t\tm.reply(`*${command} ${text}*\\nJawab : ${kah}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'kapan': case 'kapankah': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} saya menang?`)\r\n\t\t\t\tlet kapan = ['Besok','Lusa','Nanti','4 Hari Lagi','5 Hari Lagi','6 Hari Lagi','1 Minggu Lagi','2 Minggu Lagi','3 Minggu Lagi','1 Bulan Lagi','2 Bulan Lagi','3 Bulan Lagi','4 Bulan Lagi','5 Bulan Lagi','6 Bulan Lagi','1 Tahun Lagi','2 Tahun Lagi','3 Tahun Lagi','4 Tahun Lagi','5 Tahun Lagi','6 Tahun Lagi','1 Abad lagi','3 Hari Lagi','Bulan Depan','Ntahlah','Tidak Akan Pernah']\r\n\t\t\t\tlet koh = kapan[Math.floor(Math.random() * kapan.length)]\r\n\t\t\t\tm.reply(`*${command} ${text}*\\nJawab : ${koh}`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'siapa': case 'siapakah': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} jawa?`)\r\n\t\t\t\tlet member = (store.groupMetadata[m.chat] ? store.groupMetadata[m.chat].participants : m.metadata.participants).map(a => a.id)\r\n\t\t\t\tlet siapakh = pickRandom(member)\r\n\t\t\t\tm.reply(`@${siapakh.split('@')[0]}`);\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tanyakerang': case 'kerangajaib': case 'kerang': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} boleh pinjam 100?`)\r\n\t\t\t\tlet krng = ['Mungkin suatu hari', 'Tidak juga', 'Tidak keduanya', 'Kurasa tidak', 'Ya', 'Tidak', 'Coba tanya lagi', 'Tidak ada']\r\n\t\t\t\tlet jwb = pickRandom(krng)\r\n\t\t\t\tm.reply(`*Pertanyaan : ${text}*\\n*Jawab : ${jwb}*`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'cekmati': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} nama lu`)\r\n\t\t\t\tlet teksnya = text.replace(/@|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '').replace(/\\d/g, '');\r\n\t\t\t\tlet data = await axios.get(`https://api.agify.io/?name=${teksnya ? teksnya : 'bot'}`).then(res => res.data).catch(e => ({ age: Math.floor(Math.random() * 90) + 20 }));\r\n\t\t\t\tm.reply(`Nama : ${text}\\n*Mati Pada Umur :* ${data.age == null ? (Math.floor(Math.random() * 90) + 20) : data.age} Tahun.\\n\\n_Cepet Cepet Tobat Bro_\\n_Soalnya Mati ga ada yang tau_`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ceksifat': {\r\n\t\t\t\tlet sifat_a = ['Bijak','Sabar','Kreatif','Humoris','Mudah bergaul','Mandiri','Setia','Jujur','Dermawan','Idealis','Adil','Sopan','Tekun','Rajin','Pemaaf','Murah hati','Ceria','Percaya diri','Penyayang','Disiplin','Optimis','Berani','Bersyukur','Bertanggung jawab','Bisa diandalkan','Tenang','Kalem','Logis']\r\n\t\t\t\tlet sifat_b = ['Sombong','Minder','Pendendam','Sensitif','Perfeksionis','Caper','Pelit','Egois','Pesimis','Penyendiri','Manipulatif','Labil','Penakut','Vulgar','Tidak setia','Pemalas','Kasar','Rumit','Boros','Keras kepala','Tidak bijak','Pembelot','Serakah','Tamak','Penggosip','Rasis','Ceroboh','Intoleran']\r\n\t\t\t\tlet teks = `‚ï≠‚îÄ‚îÄ‚ùç„Äå *Cek Sifat* „Äç‚ùç\\n‚îÇ‚Ä¢ Sifat ${text && m.mentionedJid ? text : '@' + m.sender.split('@')[0]}${(text && m.mentionedJid ? '' : (`\\n‚îÇ‚Ä¢ Nama : *${text ? text : m.pushName}*` || '\\n‚îÇ‚Ä¢ Nama : *Tanpa Nama*'))}\\n‚îÇ‚Ä¢ Orang yang : *${pickRandom(sifat_a)}*\\n‚îÇ‚Ä¢ Kekurangan : *${pickRandom(sifat_b)}*\\n‚îÇ‚Ä¢ Keberanian : *${Math.floor(Math.random() * 100)}%*\\n‚îÇ‚Ä¢ Kepedulian : *${Math.floor(Math.random() * 100)}%*\\n‚îÇ‚Ä¢ Kecemasan : *${Math.floor(Math.random() * 100)}%*\\n‚îÇ‚Ä¢ Ketakutan : *${Math.floor(Math.random() * 100)}%*\\n‚îÇ‚Ä¢ Akhlak Baik : *${Math.floor(Math.random() * 100)}%*\\n‚îÇ‚Ä¢ Akhlak Buruk : *${Math.floor(Math.random() * 100)}%*\\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`\r\n\t\t\t\tm.reply(teks)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'cekkhodam': {\r\n\t\t\t\tif (!text) return m.reply(`Example : ${prefix + command} nama lu`)\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst res = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/random/cekkhodam.json');\r\n\t\t\t\t\tconst hasil = pickRandom(res);\r\n\t\t\t\t\tm.reply(`Khodam dari *${text}* adalah *${hasil.nama}*\\n_${hasil.deskripsi}_`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tm.reply(pickRandom(['Dokter Indosiar','Sigit Rendang','Ustadz Sinetron','Bocil epep']))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'rate': case 'nilai': {\r\n\t\t\t\tm.reply(`Rate Bot : *${Math.floor(Math.random() * 100)}%*`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'jodohku': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tlet member = (store.groupMetadata?.[m.chat]?.participants || m.metadata?.participants || []).map(a => a.id)\r\n\t\t\t\tlet jodoh = pickRandom(member)\r\n\t\t\t\tm.reply(`üë´Jodoh mu adalah\\n@${m.sender.split('@')[0]} ‚ù§ @${jodoh ? jodoh.split('@')[0] : '0'}`);\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'jadian': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tlet member = (store.groupMetadata?.[m.chat]?.participants || m.metadata?.participants || []).map(a => a.id)\r\n\t\t\t\tlet jadian1 = pickRandom(member)\r\n\t\t\t\tlet jadian2 = pickRandom(member)\r\n\t\t\t\tm.reply(`Ciee yang Jadianüíñ Jangan lupa Donasiüóø\\n@${jadian1.split('@')[0]} ‚ù§ @${jadian2.split('@')[0]}`);\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'fitnah': {\r\n\t\t\t\tlet [teks1, teks2, teks3] = text.split`|`\r\n\t\t\t\tif (!teks1 || !teks2 || !teks3) return m.reply(`Example : ${prefix + command} pesan target|pesan mu|nomer/tag target`)\r\n\t\t\t\tlet ftelo = { key: { fromMe: false, participant: teks3.replace(/[^0-9]/g, '') + '@s.whatsapp.net', ...(m.isGroup ? { remoteJid: m.chat } : { remoteJid: teks3.replace(/[^0-9]/g, '') + '@s.whatsapp.net'})}, message: { conversation: teks1 }}\r\n\t\t\t\tnaze.sendMessage(m.chat, { text: teks2 }, { quoted: ftelo });\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'coba': {\r\n\t\t\t\tlet anu = ['Aku Monyet','Aku Kera','Aku Tolol','Aku Kaya','Aku Dewa','Aku Anjing','Aku Dongo','Aku Raja','Aku Sultan','Aku Baik','Aku Hitam','Aku Suki']\r\n\t\t\t\tawait naze.sendButtonMsg(m.chat, {\r\n\t\t\t\t\ttext: 'Semoga Hokiüòπ',\r\n\t\t\t\t\tbuttons: [{\r\n\t\t\t\t\t\tbuttonId: 'teshoki',\r\n\t\t\t\t\t\tbuttonText: { displayText: '\\n' + pickRandom(anu)},\r\n\t\t\t\t\t\ttype: 1\r\n\t\t\t\t\t},{\r\n\t\t\t\t\t\tbuttonId: 'cobacoba',\r\n\t\t\t\t\t\tbuttonText: { displayText: '\\n' + pickRandom(anu)},\r\n\t\t\t\t\t\ttype: 1\r\n\t\t\t\t\t}]\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Game Menu\r\n\t\t\tcase 'slot': {\r\n\t\t\t\tawait gameSlot(naze, m, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'casino': {\r\n\t\t\t\tawait gameCasinoSolo(naze, m, prefix, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'samgong': case 'kartu': {\r\n\t\t\t\tawait gameSamgongSolo(naze, m, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'rampok': case 'merampok': {\r\n\t\t\t\tawait gameMerampok(m, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'begal': {\r\n\t\t\t\tawait gameBegal(naze, m, db)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'suitpvp': case 'suit': {\r\n\t\t\t\tif (Object.values(suit).find(roof => roof.id.startsWith('suit') && [roof.p, roof.p2].includes(m.sender))) return m.reply(`Selesaikan suit mu yang sebelumnya`)\r\n\t\t\t\tif (m.mentionedJid[0] === m.sender) return m.reply(`Tidak bisa bermain dengan diri sendiri !`)\r\n\t\t\t\tif (!m.mentionedJid[0]) return m.reply(`_Siapa yang ingin kamu tantang?_\\nTag orangnya..\\n\\nContoh : ${prefix}suit @${ownerNumber[0]}`, m.chat, { mentions: [ownerNumber[1] + '@s.whatsapp.net'] })\r\n\t\t\t\tif (Object.values(suit).find(roof => roof.id.startsWith('suit') && [roof.p, roof.p2].includes(m.mentionedJid[0]))) return m.reply(`Orang yang kamu tantang sedang bermain suit bersama orang lain :(`)\r\n\t\t\t\tlet caption = `_*SUIT PvP*_\\n\\n@${m.sender.split`@`[0]} menantang @${m.mentionedJid[0].split`@`[0]} untuk bermain suit\\n\\nSilahkan @${m.mentionedJid[0].split`@`[0]} untuk ketik terima/tolak`\r\n\t\t\t\tlet id = 'suit_' + Date.now();\r\n\t\t\t\tsuit[id] = {\r\n\t\t\t\t\tchat: caption,\r\n\t\t\t\t\tid: id,\r\n\t\t\t\t\tp: m.sender,\r\n\t\t\t\t\tp2: m.mentionedJid[0],\r\n\t\t\t\t\tstatus: 'wait',\r\n\t\t\t\t\tpoin: 10,\r\n\t\t\t\t\tpoin_lose: 10,\r\n\t\t\t\t\ttimeout: 3 * 60 * 1000\r\n\t\t\t\t}\r\n\t\t\t\tm.reply(caption)\r\n\t\t\t\tawait sleep(3 * 60 * 1000)\r\n\t\t\t\tif (suit[id]) {\r\n\t\t\t\t\tm.reply(`_Waktu suit habis_`)\r\n\t\t\t\t\tdelete suit[id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delsuit': case 'deletesuit': {\r\n\t\t\t\tlet roomnya = Object.values(suit).find(roof => roof.id.startsWith('suit') && [roof.p, roof.p2].includes(m.sender))\r\n\t\t\t\tif (!roomnya) return m.reply(`Kamu sedang tidak berada di room suit !`)\r\n\t\t\t\tdelete suit[roomnya.id]\r\n\t\t\t\tm.reply(`Berhasil delete session room suit !`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ttc': case 'ttt': case 'tictactoe': {\r\n\t\t\t\tif (Object.values(tictactoe).find(room => room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender))) return m.reply(`Kamu masih didalam game!\\nKetik *${prefix}del${command}* Jika Ingin Mengakhiri sesi`);\r\n\t\t\t\tlet room = Object.values(tictactoe).find(room => room.state === 'WAITING' && (text ? room.name === text : true))\r\n\t\t\t\tif (room) {\r\n\t\t\t\t\tm.reply('Partner ditemukan!')\r\n\t\t\t\t\troom.o = m.chat\r\n\t\t\t\t\troom.game.playerO = m.sender\r\n\t\t\t\t\troom.state = 'PLAYING'\r\n\t\t\t\t\tif (!(room.game instanceof TicTacToe)) {\r\n\t\t\t\t\t\troom.game = Object.assign(new TicTacToe(room.game.playerX, room.game.playerO), room.game)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet arr = room.game.render().map(v => {\r\n\t\t\t\t\t\treturn {X: '‚ùå',O: '‚≠ï',1: '1Ô∏è‚É£',2: '2Ô∏è‚É£',3: '3Ô∏è‚É£',4: '4Ô∏è‚É£',5: '5Ô∏è‚É£',6: '6Ô∏è‚É£',7: '7Ô∏è‚É£',8: '8Ô∏è‚É£',9: '9Ô∏è‚É£'}[v]\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlet str = `Room ID: ${room.id}\\n\\n${arr.slice(0, 3).join('')}\\n${arr.slice(3, 6).join('')}\\n${arr.slice(6).join('')}\\n\\nMenunggu @${room.game.currentTurn.split('@')[0]}\\n\\nKetik *nyerah* untuk menyerah dan mengakui kekalahan`\r\n\t\t\t\t\tif (room.x !== room.o) await naze.sendMessage(room.x, { texr: str, mentions: parseMention(str) }, { quoted: m })\r\n\t\t\t\t\tawait naze.sendMessage(room.o, { text: str, mentions: parseMention(str) }, { quoted: m })\r\n\t\t\t\t} else {\r\n\t\t\t\t\troom = {\r\n\t\t\t\t\t\tid: 'tictactoe-' + (+new Date),\r\n\t\t\t\t\t\tx: m.chat,\r\n\t\t\t\t\t\to: '',\r\n\t\t\t\t\t\tgame: new TicTacToe(m.sender, 'o'),\r\n\t\t\t\t\t\tstate: 'WAITING',\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (text) room.name = text\r\n\t\t\t\t\tnaze.sendMessage(m.chat, { text: 'Menunggu partner' + (text ? ` mengetik command dibawah ini ${prefix}${command} ${text}` : ''), mentions: m.mentionedJid }, { quoted: m })\r\n\t\t\t\t\ttictactoe[room.id] = room\r\n\t\t\t\t\tawait sleep(300000)\r\n\t\t\t\t\tif (tictactoe[room.id]) {\r\n\t\t\t\t\t\tm.reply(`_Waktu ${command} habis_`)\r\n\t\t\t\t\t\tdelete tictactoe[room.id]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'delttc': case 'delttt': {\r\n\t\t\t\tlet roomnya = Object.values(tictactoe).find(room => room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender))\r\n\t\t\t\tif (!roomnya) return m.reply(`Kamu sedang tidak berada di room tictactoe !`)\r\n\t\t\t\tdelete tictactoe[roomnya.id]\r\n\t\t\t\tm.reply(`Berhasil delete session room tictactoe !`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'akinator': {\r\n\t\t\t\tif (text == 'start') {\r\n\t\t\t\t\tif (akinator[m.sender]) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\t\takinator[m.sender] = new Akinator({ region: 'id', childMode: false });\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait akinator[m.sender].start()\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tdelete akinator[m.sender];\r\n\t\t\t\t\t\treturn m.reply('Server Akinator Sedang Gangguan\\nSilahkan coba lagi nanti!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet { key } = await m.reply(`üéÆ Akinator Game :\\n\\n@${m.sender.split('@')[0]}\\n${akinator[m.sender].question}\\n\\n- 0 - Ya\\n- 1 - Tidak\\n- 2 - Tidak Tau\\n- 3 - Mungkin\\n- 4 - Mungkin Tidak\\n\\n${prefix + command} end (Untuk Keluar dari sesi)`)\r\n\t\t\t\t\takinator[m.sender].key = key.id\r\n\t\t\t\t\tawait sleep(3600000)\r\n\t\t\t\t\tif (akinator[m.sender]) {\r\n\t\t\t\t\t\tm.reply(`_Waktu ${command} habis_`)\r\n\t\t\t\t\t\tdelete akinator[m.sender];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (text == 'end') {\r\n\t\t\t\t\tif (!akinator[m.sender]) return m.reply('Kamu tidak Sedang bermain Akinator!')\r\n\t\t\t\t\tdelete akinator[m.sender];\r\n\t\t\t\t\tm.reply('Sukses Mengakhiri sessi Akinator')\r\n\t\t\t\t} else m.reply(`Example : ${prefix + command} start/end`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebakbom': {\r\n\t\t\t\tif (tebakbom[m.sender]) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\ttebakbom[m.sender] = {\r\n\t\t\t\t\tpetak: [0, 0, 0, 2, 0, 2, 0, 2, 0, 0].sort(() => Math.random() - 0.5),\r\n\t\t\t\t\tboard: ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü'],\r\n\t\t\t\t\tbomb: 3,\r\n\t\t\t\t\tlolos: 7,\r\n\t\t\t\t\tpick: 0,\r\n\t\t\t\t\tnyawa: ['‚ù§Ô∏è', '‚ù§Ô∏è', '‚ù§Ô∏è'],\r\n\t\t\t\t}\r\n\t\t\t\tawait m.reply(`*TEBAK BOM*\\n\\n${tebakbom[m.sender].board.join(\"\")}\\n\\nPilih lah nomor tersebut! dan jangan sampai terkena Bom!\\nBomb : ${tebakbom[m.sender].bomb}\\nNyawa : ${tebakbom[m.sender].nyawa.join(\"\")}`);\r\n\t\t\t\tawait sleep(120000)\r\n\t\t\t\tif (tebakbom[m.sender]) {\r\n\t\t\t\t\tm.reply(`_Waktu ${command} habis_`)\r\n\t\t\t\t\tdelete tebakbom[m.sender];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tekateki': {\r\n\t\t\t\tif (iGame(tekateki, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tekateki.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Teka Teki Berikut :\\n\\n${hasil.soal}\\n\\nWaktu : 60s\\nHadiah *+3499*`)\r\n\t\t\t\ttekateki[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.jawaban.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tekateki, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tekateki[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tekateki[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebaklirik': {\r\n\t\t\t\tif (iGame(tebaklirik, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tebaklirik.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Tebak Lirik Berikut :\\n\\n${hasil.soal}\\n\\nWaktu : 90s\\nHadiah *+4299*`)\r\n\t\t\t\ttebaklirik[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.jawaban.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(90000)\r\n\t\t\t\tif (rdGame(tebaklirik, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebaklirik[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebaklirik[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebakkata': {\r\n\t\t\t\tif (iGame(tebakkata, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tebakkata.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Tebak Kata Berikut :\\n\\n${hasil.soal}\\n\\nWaktu : 60s\\nHadiah *+3499*`)\r\n\t\t\t\ttebakkata[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.jawaban.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tebakkata, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebakkata[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebakkata[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'family100': {\r\n\t\t\t\tif (family100.hasOwnProperty(m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/family100.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Tebak Kata Berikut :\\n\\n${hasil.soal}\\n\\nWaktu : 5m\\nHadiah *+3499*`)\r\n\t\t\t\tfamily100[m.chat] = {\r\n\t\t\t\t\tsoal: hasil.soal,\r\n\t\t\t\t\tjawaban: hasil.jawaban,\r\n\t\t\t\t\tterjawab: Array.from(hasil.jawaban, () => false),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(300000)\r\n\t\t\t\tif (family100.hasOwnProperty(m.chat)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban:\\n- ' + family100[m.chat].jawaban.join('\\n- '))\r\n\t\t\t\t\tdelete family100[m.chat]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'susunkata': {\r\n\t\t\t\tif (iGame(susunkata, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/susunkata.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Susun Kata Berikut :\\n\\n${hasil.soal}\\nTipe : ${hasil.tipe}\\n\\nWaktu : 60s\\nHadiah *+2989*`)\r\n\t\t\t\tsusunkata[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.jawaban.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(susunkata, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + susunkata[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete susunkata[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebakkimia': {\r\n\t\t\t\tif (iGame(tebakkimia, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tebakkimia.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Tebak Kimia Berikut :\\n\\n${hasil.unsur}\\n\\nWaktu : 60s\\nHadiah *+3499*`)\r\n\t\t\t\ttebakkimia[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.lambang.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tebakkimia, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebakkimia[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebakkimia[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'caklontong': {\r\n\t\t\t\tif (iGame(caklontong, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/caklontong.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Jawab Pertanyaan Berikut :\\n\\n${hasil.soal}\\n\\nWaktu : 60s\\nHadiah *+9999*`)\r\n\t\t\t\tcaklontong[m.chat + key.id] = {\r\n\t\t\t\t\t...hasil,\r\n\t\t\t\t\tjawaban: hasil.jawaban.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(caklontong, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply(`Waktu Habis\\nJawaban: ${caklontong[m.chat + key.id].jawaban}\\n\"${caklontong[m.chat + key.id].deskripsi}\"`)\r\n\t\t\t\t\tdelete caklontong[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebaknegara': {\r\n\t\t\t\tif (iGame(tebaknegara, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tebaknegara.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Tebak Negara Dari Tempat Berikut :\\n\\n*Tempat : ${hasil.tempat}*\\n\\nWaktu : 60s\\nHadiah *+3499*`)\r\n\t\t\t\ttebaknegara[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.negara.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tebaknegara, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebaknegara[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebaknegara[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebakgambar': {\r\n\t\t\t\tif (iGame(tebakgambar, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tebakgambar.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await naze.sendFileUrl(m.chat, hasil.img, `üéÆ Tebak Gambar Berikut :\\n\\n${hasil.deskripsi}\\n\\nWaktu : 60s\\nHadiah *+3499*`, m)\r\n\t\t\t\ttebakgambar[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.jawaban.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tebakgambar, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebakgambar[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebakgambar[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebakbendera': {\r\n\t\t\t\tif (iGame(tebakbendera, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/games/tebakbendera.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply(`üéÆ Tebak Bendera Berikut :\\n\\n*Bendera : ${hasil.bendera}*\\n\\nWaktu : 60s\\nHadiah *+3499*`)\r\n\t\t\t\ttebakbendera[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.negara.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tebakbendera, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebakbendera[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebakbendera[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'tebakangka': case 'butawarna': case 'colorblind': {\r\n\t\t\t\tif (iGame(tebakangka, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tconst soal = await fetchJson('https://raw.githubusercontent.com/nazedev/database/refs/heads/master/random/color_blind.json');\r\n\t\t\t\tconst hasil = pickRandom(soal);\r\n\t\t\t\tlet { key } = await m.reply({\r\n\t\t\t\t\ttext: `Pilih Jawaban Yang Benar!\\nPilihan: ${[hasil.number, ...hasil.similar].sort(() => Math.random() - 0.5).join(', ')}`,\r\n\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t\tthumbnailUrl: hasil.color_blind[0],\r\n\t\t\t\t\t\t\tbody: `Level : ${hasil.lv}`,\r\n\t\t\t\t\t\t\tpreviewType: 0,\r\n\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\ttebakangka[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: hasil.number,\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(60000)\r\n\t\t\t\tif (rdGame(tebakangka, m.chat, key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + tebakangka[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete tebakangka[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'kuismath': case 'math': {\r\n\t\t\t\tconst { genMath, modes } = require('./lib/math');\r\n\t\t\t\tconst inputMode = ['noob', 'easy', 'medium', 'hard','extreme','impossible','impossible2'];\r\n\t\t\t\tif (iGame(kuismath, m.chat)) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\tif (!text) return m.reply(`Mode: ${Object.keys(modes).join(' | ')}\\nContoh penggunaan: ${prefix}math medium`)\r\n\t\t\t\tif (!inputMode.includes(text.toLowerCase())) return m.reply('Mode tidak ditemukan!')\r\n\t\t\t\tlet result = await genMath(text.toLowerCase())\r\n\t\t\t\tlet { key } = await m.reply(`*Berapa hasil dari: ${result.soal.toLowerCase()}*?\\n\\nWaktu : ${(result.waktu / 1000).toFixed(2)} detik`)\r\n\t\t\t\tkuismath[m.chat + key.id] = {\r\n\t\t\t\t\tjawaban: result.jawaban,\r\n\t\t\t\t\tmode: text.toLowerCase(),\r\n\t\t\t\t\tid: key.id\r\n\t\t\t\t}\r\n\t\t\t\tawait sleep(kuismath, result.waktu)\r\n\t\t\t\tif (rdGame(m.chat + key.id)) {\r\n\t\t\t\t\tm.reply('Waktu Habis\\nJawaban: ' + kuismath[m.chat + key.id].jawaban)\r\n\t\t\t\t\tdelete kuismath[m.chat + key.id]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ulartangga': case 'snakeladder': case 'ut': {\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (ulartangga[m.chat] && !(ulartangga[m.chat] instanceof SnakeLadder)) {\r\n\t\t\t\t\tulartangga[m.chat] = Object.assign(new SnakeLadder(ulartangga[m.chat]), ulartangga[m.chat]);\r\n\t\t\t\t}\r\n\t\t\t\tswitch(args[0]) {\r\n\t\t\t\t\tcase 'create': case 'join':\r\n\t\t\t\t\tif (ulartangga[m.chat]) {\r\n\t\t\t\t\t\tif (Object.keys(ulartangga[m.chat].players).length > 8) return m.reply(`Jumlah Pemain Sudah Maksimal\\nSilahkan Memulai Permainan\\n${prefix + command} start`);\r\n\t\t\t\t\t\tif (ulartangga[m.chat].players.some(a => a.id == m.sender)) return m.reply('Kamu Sudah Bergabung!')\r\n\t\t\t\t\t\tulartangga[m.chat].players.push({ id: m.sender, move: 0 });\r\n\t\t\t\t\t\tm.reply('Sukses Join Sesi Game')\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tulartangga[m.chat] = new SnakeLadder({ id: m.chat, host: m.sender });\r\n\t\t\t\t\t\tulartangga[m.chat].players.push({ id: m.sender, move: 0 });\r\n\t\t\t\t\t\tulartangga[m.chat].time = Date.now();\r\n\t\t\t\t\t\tm.reply('Sukses Membuat Sesi Game')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'start':\r\n\t\t\t\t\tif (!ulartangga[m.chat]) return m.reply('Tidak Ada Sesi Yang Sedang Berlangsung!')\r\n\t\t\t\t\tif (ulartangga[m.chat].players.length < 2) return m.reply('Jumlah Pemain Kurang!\\nMinimal 2 Pemain!')\r\n\t\t\t\t\tif (ulartangga[m.chat].start) return m.reply('Sesi Sudah dimulai Sejak Awal!')\r\n\t\t\t\t\tif (ulartangga[m.chat].host !== m.sender) return m.reply(`Hanya Pembuat Room @${ulartangga[m.chat].host.split('@')[0]} yang bisa Memulai Sessi!`)\r\n\t\t\t\t\tlet { key } = await m.reply({ image: { url: ulartangga[m.chat].map.url }, caption: `üêçü™úGAME ULAR TANGGA\\n\\n${ulartangga[m.chat].players.map((p, i) => `- @${p.id.split('@')[0]} (Pion ${['Merah', 'Biru Muda', 'Kuning', 'Hijau', 'Ungu', 'Jingga', 'Biru Tua', 'Putih'][i]})`).join('\\n')}\\n\\nGiliran: @${m.sender.split('@')[0]}\\n\\nReply Pesan Ini untuk lanjut bermain!\\nExample: roll/kocok`, mentions: ulartangga[m.chat].players.map(p => p.id)});\r\n\t\t\t\t\tulartangga[m.chat].id = key.id\r\n\t\t\t\t\tulartangga[m.chat].start = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'leave':\r\n\t\t\t\t\tif (!ulartangga[m.chat]) return m.reply('Tidak Ada Sesi Yang Sedang Berlangsung!')\r\n\t\t\t\t\tif (!ulartangga[m.chat].players.some(a => a.id == m.sender)) return m.reply('Kamu Bukan Pemain!')\r\n\t\t\t\t\tconst player = ulartangga[m.chat].players.findIndex(a => a.id == m.sender)\r\n\t\t\t\t\tif (ulartangga[m.chat].start) return m.reply('Game Sudah dimulai!\\nTidak Bisa Keluar Sekarang')\r\n\t\t\t\t\tif (ulartangga[m.chat].players.length < 1 || ulartangga[m.chat].host === m.sender) {\r\n\t\t\t\t\t\tm.reply(ulartangga[m.chat].host === m.sender ? 'Host Meninggalkan Permainan\\nPermainan dihentikan!' : 'Pemain Kurang Dari 1, Permainan dihentikan!');\r\n\t\t\t\t\t\tdelete ulartangga[m.chat];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tulartangga[m.chat].players.splice(player, 1);\r\n\t\t\t\t\tm.reply('Sukses Meninggalkan Permainan');\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'end':\r\n\t\t\t\t\tif (!ulartangga[m.chat]) return m.reply('Tidak Ada Sesi Yang Sedang Berlangsung!')\r\n\t\t\t\t\tif (ulartangga[m.chat]?.host !== m.sender) return m.reply(`Hanya Pembuat Room @${ulartangga[m.chat].host.split('@')[0]} yang bisa Menghapus Sessi!`)\r\n\t\t\t\t\tdelete ulartangga[m.chat]\r\n\t\t\t\t\tm.reply('Berhasil Menghapus Sesi Game')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tm.reply(`üêçü™úGAME ULARTANGGA\\nCommand: ${prefix + command} <command>\\n- create\\n- join\\n- start\\n- leave\\n- end`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'chess': case 'catur': case 'ct': {\r\n\t\t\t\tconst { DEFAUT_POSITION } = require('chess.js');\r\n\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\tif (chess[m.chat] && !(chess[m.chat] instanceof Chess)) {\r\n\t\t\t\t\tchess[m.chat] = Object.assign(new Chess(chess[m.chat].fen), chess[m.chat]);\r\n\t\t\t\t}\r\n\t\t\t\tswitch(args[0]) {\r\n\t\t\t\t\tcase 'start':\r\n\t\t\t\t\tif (!chess[m.chat]) return m.reply('Tidak Ada Sesi Yang Sedang Berlangsung!')\r\n\t\t\t\t\tif (!chess[m.chat].acc) return m.reply('Pemain Tidak Lengkap!')\r\n\t\t\t\t\tif (chess[m.chat].player1 !== m.sender) return m.reply('Hanya Pemain Utama Yang bisa Memulai!')\r\n\t\t\t\t\tif (chess[m.chat].turn !== m.sender && !chess[m.chat].start) {\r\n\t\t\t\t\t\tconst encodedFen = encodeURI(chess[m.chat]._fen);\r\n\t\t\t\t\t\tlet boardUrls = [`https://www.chess.com/dynboard?fen=${encodedFen}&size=3&coordinates=inside`,`https://www.chess.com/dynboard?fen=${encodedFen}&board=graffiti&piece=graffiti&size=3&coordinates=inside`,`https://chessboardimage.com/${encodedFen}.png`,`https://backscattering.de/web-boardimage/board.png?fen=${encodedFen}`,`https://fen2image.chessvision.ai/${encodedFen}`];\r\n\t\t\t\t\t\tfor (let url of boardUrls) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tconst { data } = await axios.get(url, { responseType: 'arraybuffer' });\r\n\t\t\t\t\t\t\t\tlet { key } = await m.reply({ image: data, caption: `‚ôüÔ∏è${command.toUpperCase()} GAME\\n\\nGiliran: @${m.sender.split('@')[0]}\\n\\nReply Pesan Ini untuk lanjut bermain!\\nExample: from to -> b1 c3`, mentions: [m.sender] });\r\n\t\t\t\t\t\t\t\tchess[m.chat].start = true\r\n\t\t\t\t\t\t\t\tchess[m.chat].turn = m.sender\r\n\t\t\t\t\t\t\t\tchess[m.chat].id = key.id;\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t} catch (e) {}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!chess[m.chat].key) {\r\n\t\t\t\t\t\t\tm.reply(`Gagal Memulai Permainan!\\nGagal Mengirim Papan Permainan!`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ([chess[m.chat].player1, chess[m.chat].player2].includes(m.sender)) {\r\n\t\t\t\t\t\tconst isPlayer2 = chess[m.chat].player2 === m.sender\r\n\t\t\t\t\t\tconst nextPlayer = isPlayer2 ? chess[m.chat].player1 : chess[m.chat].player2;\r\n\t\t\t\t\t\tconst encodedFen = encodeURI(chess[m.chat]._fen);\r\n\t\t\t\t\t\tconst boardUrls = [`https://www.chess.com/dynboard?fen=${encodedFen}&size=3&coordinates=inside${!isPlayer2 ? '&flip=true' : ''}`,`https://www.chess.com/dynboard?fen=${encodedFen}&board=graffiti&piece=graffiti&size=3&coordinates=inside${!isPlayer2 ? '&flip=true' : ''}`,`https://chessboardimage.com/${encodedFen}${!isPlayer2 ? '-flip' : ''}.png`,`https://backscattering.de/web-boardimage/board.png?fen=${encodedFen}&coordinates=true&size=765${!isPlayer2 ? '&orientation=black' : ''}`,`https://fen2image.chessvision.ai/${encodedFen}/${!isPlayer2 ? '?pov=black' : ''}`];\r\n\t\t\t\t\t\tfor (let url of boardUrls) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tchess[m.chat].turn = chess[m.chat].turn === m.sender ? m.sender : nextPlayer;\r\n\t\t\t\t\t\t\t\tconst { data } = await axios.get(url, { responseType: 'arraybuffer' });\r\n\t\t\t\t\t\t\t\tlet { key } = await m.reply({ image: data, caption: `‚ôüÔ∏èCHESS GAME\\n\\nGiliran: @${chess[m.chat].turn.split('@')[0]}\\n\\nReply Pesan Ini untuk lanjut bermain!\\nExample: from to -> b1 c3`, mentions: [chess[m.chat].turn] });\r\n\t\t\t\t\t\t\t\tchess[m.chat].id = key.id;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t} catch (e) {}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'join':\r\n\t\t\t\t\tif (chess[m.chat]) {\r\n\t\t\t\t\t\tif (chess[m.chat].player1 !== m.sender) {\r\n\t\t\t\t\t\t\tif (chess[m.chat].acc) return m.reply(`Pemain Sudah Terisi\\nSilahkan Coba Lagi Nanti`)\r\n\t\t\t\t\t\t\tlet teks = chess[m.chat].player2 === m.sender ? 'TerimaKasih Sudah Mau Bergabung' : `Karena @${chess[m.chat].player2.split('@')[0]} Tidak Merespon\\nAkan digantikan Oleh @${m.sender.split('@')[0]}`\r\n\t\t\t\t\t\t\tchess[m.chat].player2 = m.sender\r\n\t\t\t\t\t\t\tchess[m.chat].acc = true\r\n\t\t\t\t\t\t\tm.reply(`${teks}\\nSilahkan @${chess[m.chat].player1.split('@')[0]} Untuk Memulai Game (${prefix + command} start)`)\r\n\t\t\t\t\t\t} else m.reply(`Kamu Sudah Bergabung\\nBiarkan Orang Lain Menjadi Lawanmu!`)\r\n\t\t\t\t\t} else m.reply('Tidak Ada Sesi Yang Sedang Berlangsung!')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'end': case 'leave':\r\n\t\t\t\t\tif (chess[m.chat]) {\r\n\t\t\t\t\t\tif (![chess[m.chat].player1, chess[m.chat].player2].includes(m.sender)) return m.reply('Hanya Pemain yang Bisa Menghentikan Permainan!')\r\n\t\t\t\t\t\tdelete chess[m.chat]\r\n\t\t\t\t\t\tm.reply('Sukses Menghapus Sesi Game')\r\n\t\t\t\t\t} else m.reply('Tidak Ada Sesi Yang Sedang Berlangsung!')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'bot': case 'computer':\r\n\t\t\t\t\tif (chess[m.sender]) {\r\n\t\t\t\t\t\tdelete chess[m.sender];\r\n\t\t\t\t\t\treturn m.reply('Sukses Menghapus Sesi vs BOT')\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchess[m.sender] = new Chess(DEFAUT_POSITION);\r\n\t\t\t\t\t\tchess[m.sender]._fen = chess[m.sender].fen();\r\n\t\t\t\t\t\tchess[m.sender].turn = m.sender;\r\n\t\t\t\t\t\tchess[m.sender].botMode = true;\r\n\t\t\t\t\t\tchess[m.sender].time = Date.now();\r\n\t\t\t\t\t\tconst encodedFen = encodeURI(chess[m.sender]._fen);\r\n\t\t\t\t\t\tconst boardUrls = [`https://www.chess.com/dynboard?fen=${encodedFen}&size=3&coordinates=inside`,`https://www.chess.com/dynboard?fen=${encodedFen}&board=graffiti&piece=graffiti&size=3&coordinates=inside`,`https://chessboardimage.com/${encodedFen}.png`,`https://backscattering.de/web-boardimage/board.png?fen=${encodedFen}&coordinates=true&size=765`,`https://fen2image.chessvision.ai/${encodedFen}/`];\r\n\t\t\t\t\t\tfor (let url of boardUrls) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tconst { data } = await axios.get(url, { responseType: 'arraybuffer' });\r\n\t\t\t\t\t\t\t\tlet { key } = await m.reply({ image: data, caption: `‚ôüÔ∏èCHESS GAME\\n\\nGiliran: @${chess[m.sender].turn.split('@')[0]}\\n\\nReply Pesan Ini untuk lanjut bermain!\\nExample: from to -> b1 c3`, mentions: [chess[m.sender].turn] });\r\n\t\t\t\t\t\t\t\tchess[m.sender].id = key.id;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t} catch (e) {}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tif (/^@?\\d+$/.test(args[0])) {\r\n\t\t\t\t\t\tif (chess[m.chat]) return m.reply('Masih Ada Sesi Yang Belum Diselesaikan!')\r\n\t\t\t\t\t\tif (m.mentionedJid.length < 1) return m.reply('Tag Orang yang Mau diajak Bermain!')\r\n\t\t\t\t\t\tchess[m.chat] = new Chess(DEFAUT_POSITION);\r\n\t\t\t\t\t\tchess[m.chat]._fen = chess[m.chat].fen();\r\n\t\t\t\t\t\tchess[m.chat].player1 = m.sender\r\n\t\t\t\t\t\tchess[m.chat].player2 = m.mentionedJid ? m.mentionedJid[0] : null\r\n\t\t\t\t\t\tchess[m.chat].time = Date.now();\r\n\t\t\t\t\t\tchess[m.chat].turn = null\r\n\t\t\t\t\t\tchess[m.chat].acc = false\r\n\t\t\t\t\t\tm.reply(`‚ôüÔ∏è${command.toUpperCase()} GAME\\n\\n@${m.sender.split('@')[0]} Menantang @${m.mentionedJid[0].split('@')[0]}\\nUntuk Bergabung ${prefix + command} join`)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm.reply(`‚ôüÔ∏è${command.toUpperCase()} GAME\\n\\nExample: ${prefix + command} @tag/number\\n- start\\n- leave\\n- join\\n- computer\\n- end`)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'blackjack': case 'bj': {\r\n\t\t\t\tlet session = null;\r\n\t\t\t\tfor (let id in blackjack) {\r\n\t\t\t\t\tif (blackjack[id].players.find(p => p.id === m.sender)) {\r\n\t\t\t\t\t\tsession = blackjack[id];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (session && !(session instanceof Blackjack)) {\r\n\t\t\t\t\tsession = Object.assign(new Blackjack(session), session)\r\n\t\t\t\t}\r\n\t\t\t\tif (blackjack[m.chat] && !(blackjack[m.chat] instanceof Blackjack)) {\r\n\t\t\t\t\tblackjack[m.chat] = Object.assign(new Blackjack(blackjack[m.chat]), blackjack[m.chat])\r\n\t\t\t\t}\r\n\t\t\t\tswitch(args[0]) {\r\n\t\t\t\t\tcase 'create': case 'join':\r\n\t\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\t\tif (blackjack[m.chat] || session) {\r\n\t\t\t\t\t\tif (blackjack[m.chat]?.players?.some(a => a.id === m.sender)) return m.reply('Kamu Sudah Bergabung!')\r\n\t\t\t\t\t\tif (session) return m.reply('Kamu sudah bergabung di sesi Grup lain! Keluar dulu sebelum bergabung di sesi baru.');\r\n\t\t\t\t\t\tif (blackjack[m.chat].players.length > 10) return m.reply(`Jumlah Pemain Sudah Maksimal\\nSilahkan Memulai Permainan\\n${prefix + command} start`);\r\n\t\t\t\t\t\tblackjack[m.chat].players.push({ id: m.sender, cards: [] });\r\n\t\t\t\t\t\tm.reply('Sukses Join Game Blackjack')\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tblackjack[m.chat] = new Blackjack({ id: m.chat, host: m.sender });\r\n\t\t\t\t\t\tblackjack[m.chat].players.push({ id: m.sender, cards: [] });\r\n\t\t\t\t\t\tm.reply('Sukses Create Game Blackjack')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'start':\r\n\t\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\t\tif (!blackjack[m.chat]) return m.reply('Tidak Ada Sesi Game Blackjack yang Sedang Berjalan!')\r\n\t\t\t\t\tif (blackjack[m.chat]?.host !== m.sender) return m.reply(`Hanya Pembuat Room @${blackjack[m.chat].host.split('@')[0]} yang bisa Memulai Sessi!`)\r\n\t\t\t\t\tif (blackjack[m.chat].players.length < 2) return m.reply('Minimal 2 Pemain Untuk Memulai Permainan!');\r\n\t\t\t\t\tif (blackjack[m.chat].started) return m.reply('Game Sudah Dimulai Sejak Awal!')\r\n\t\t\t\t\tblackjack[m.chat].distributeCards();\r\n\t\t\t\t\tm.reply(`üÉèGAME BLACKJACK‚ô¶Ô∏è\\nStart Card: ${blackjack[m.chat].startCard.rank + blackjack[m.chat].startCard.suit}\\nDeck Count: ${blackjack[m.chat].deck.length}\\n${blackjack[m.chat].players.map(a => `- @${a.id.split('@')[0]} : (${a.cards.length} kartu)`).join('\\n')}\\n\\nCek Private Chat\\nwa.me/${botNumber.split('@')[0]}`);\r\n\t\t\t\t\tfor (let p of blackjack[m.chat].players) {\r\n\t\t\t\t\t\tconst startCard = blackjack[m.chat].startCard;\r\n\t\t\t\t\t\tlet buttons = p.cards.map(a => ({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: `${a.rank}${a.suit}`, id: `.${command} play ${a.rank}${a.suit}` })}));\r\n\t\t\t\t\t\tif (!blackjack[m.chat].hasMatching(p.id)) buttons.push({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: 'Minum', id: `.${command} minum` }) });\r\n\t\t\t\t\t\tawait naze.sendListMsg(p.id, { text: `Start Card: ${startCard.rank + startCard.suit}`, footer: `${p.cards.map(c => c.rank + c.suit).join(', ')}`, buttons }, { quoted: m });\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'hit': case 'minum': {\r\n\t\t\t\t\t\tif (!session) return m.reply('Tidak Ada Sesi Game Blackjack yang Sedang Berjalan!')\r\n\t\t\t\t\t\tif (!session.started) return m.reply('Game Belum Di Mulai!')\r\n\t\t\t\t\t\tif (session.players.length < 2) return m.reply('Minimal 2 Pemain Untuk Memulai Permainan!');\r\n\t\t\t\t\t\tif (!session.players?.some(a => a.id === m.sender)) return m.reply('Kamu belum bergabung!');\r\n\t\t\t\t\t\tif (!args[0]) return m.reply(`Gunakan format:\\n${prefix + command} play <kartu>\\nContoh: ${prefix + command} hit`);\r\n\t\t\t\t\t\tconst player = session.players.find(p => p.id === m.sender);\r\n\t\t\t\t\t\tconst hitIndex = player.cards.findIndex(c => (c.rank + c.suit) === (session.startCard.rank + session.startCard.suit));\r\n\t\t\t\t\t\tif (session.submitCard.some(s => s.id === m.sender) || session.skip.includes(m.sender)) {\r\n\t\t\t\t\t\t\treturn m.reply('Kamu sudah bermain di ronde ini!');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!session.hasMatching(m.sender)) {\r\n\t\t\t\t\t\t\tif (session.deck.length) {\r\n\t\t\t\t\t\t\t\tconst newCard = session.deck.shift();\r\n\t\t\t\t\t\t\t\tplayer.cards.push(newCard);\r\n\t\t\t\t\t\t\t\tawait sleep(1000);\r\n\t\t\t\t\t\t\t\tlet buttons = player.cards.map(a => ({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: `${a.rank}${a.suit}`, id: `.${command} play ${a.rank}${a.suit}` })}));\r\n\t\t\t\t\t\t\t\tif (!session.hasMatching(player.id)) buttons.push({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: 'Minum', id: `.${command} minum` }) });\r\n\t\t\t\t\t\t\t\tawait naze.sendListMsg(player.id, { text: `Start Card: ${session.startCard.rank + session.startCard.suit}`, footer: `${player.cards.map(c => c.rank + c.suit).join(', ')}`, buttons }, { quoted: m });\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tlet reuse = session.reuseSubmitCardsForDrinking()\r\n\t\t\t\t\t\t\t\tawait m.reply(reuse.msg)\r\n\t\t\t\t\t\t\t\tif (!session.skip.find(a => a.id === player.id)) session.skip.push({ id: player.id });\r\n\t\t\t\t\t\t\t\tawait m.reply('Deck sudah habis, kamu tidak bisa mengambil kartu. Dilewati.');\r\n\t\t\t\t\t\t\t\tawait naze.sendText(session.id, `@${m.sender.split('@')[0]} dilewati karena deck habis.`, m);\r\n\t\t\t\t\t\t\t\tif ((session.submitCard.length + session.skip.length) === session.players.length) {\r\n\t\t\t\t\t\t\t\t\tconst result = session.resolveRound();\r\n\t\t\t\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\t\t\t\tawait naze.sendText(session.id, result, m);\r\n\t\t\t\t\t\t\t\t\t\tif (session.players.length === 1) {\r\n\t\t\t\t\t\t\t\t\t\t\tawait naze.sendText(session.id, `Pemain Tersisa 1 (@${session.players[0].id.split('@')[0]}), sesi Blackjack selesai.`, m);\r\n\t\t\t\t\t\t\t\t\t\t\tdelete blackjack[session.id];\r\n\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tconst leaderCards = session.players.find(a => a.id === session.leader);\r\n\t\t\t\t\t\t\t\t\t\tlet buttons = leaderCards.cards.map(c => ({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: `${c.rank}${c.suit}`, id: `.${command} play ${c.rank}${c.suit}` })}));\r\n\t\t\t\t\t\t\t\t\t\tawait naze.sendListMsg(session.leader, { text: 'Pilih kartu untuk memulai ronde baru', footer: leaderCards.cards.map(c => c.rank + c.suit).join(', '), buttons }, { quoted: m });\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else m.reply(`Kamu masih punya kartu dengan suit ${session.startCard.suit}, mainkan dulu sebelum minum!`);\r\n\t\t\t\t\t\tif ((session.submitCard.length + session.skip.length) === session.players.length) {\r\n\t\t\t\t\t\t\tconst result = session.resolveRound();\r\n\t\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\t\tawait naze.sendText(session.id, result, m);\r\n\t\t\t\t\t\t\t\tif (session.players.length === 1) {\r\n\t\t\t\t\t\t\t\t\tawait naze.sendText(session.id, `Pemain Tersisa 1 (@${session.players[0].id.split('@')[0]}), sesi Blackjack selesai.`, m);\r\n\t\t\t\t\t\t\t\t\tdelete blackjack[session.id];\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst leaderCards = session.players.find(a => a.id === session.leader);\r\n\t\t\t\t\t\t\t\tlet buttons = leaderCards.cards.map(c => ({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: `${c.rank}${c.suit}`, id: `.${command} play ${c.rank}${c.suit}` })}));\r\n\t\t\t\t\t\t\t\tawait naze.sendListMsg(session.leader, { text: 'Pilih kartu untuk memulai ronde baru', footer: leaderCards.cards.map(c => c.rank + c.suit).join(', '), buttons }, { quoted: m });\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'play': {\r\n\t\t\t\t\t\tif (!session) return m.reply('Tidak Ada Sesi Game Blackjack yang Sedang Berjalan!')\r\n\t\t\t\t\t\tif (!session.started) return m.reply('Game Belum Di Mulai!')\r\n\t\t\t\t\t\tif (session.players.length < 2) return m.reply('Minimal 2 Pemain Untuk Memulai Permainan!');\r\n\t\t\t\t\t\tif (!session.players?.some(a => a.id === m.sender)) return m.reply('Kamu belum bergabung!');\r\n\t\t\t\t\t\tif (!args[1]) return m.reply(`Gunakan format:\\n${prefix + command} play <kartu>\\nContoh: ${prefix + command} play 3‚ô•Ô∏è`);\r\n\t\t\t\t\t\tconst player = session.players.find(p => p.id === m.sender);\r\n\t\t\t\t\t\tconst idx = player.cards.findIndex(c => normalize(c.rank + c.suit) === normalize(args[1]));\r\n\t\t\t\t\t\tif (idx === -1) return m.reply('Kartu tidak valid!');\r\n\t\t\t\t\t\tif (session.submitCard.some(s => s.id === m.sender) || session.skip.includes(m.sender)) return m.reply('Kamu sudah bermain di ronde ini!');\r\n\t\t\t\t\t\tconst card = player.cards[idx];\r\n\t\t\t\t\t\tif (Object.keys(session.startCard).length) {\r\n\t\t\t\t\t\t\tif (card.suit !== session.startCard.suit) return m.reply(`Kartu tidak sesuai! Harus suit ${session.startCard.suit}`);\r\n\t\t\t\t\t\t} else if (m.sender !== session.leader) return m.reply('Hanya pemimpin ronde yang boleh memulai!');\r\n\t\t\t\t\t\tplayer.cards.splice(idx, 1);\r\n\t\t\t\t\t\tsession.secondDeck.push(card);\r\n\t\t\t\t\t\tsession.submitCard.push({ id: m.sender, card: card });\r\n\t\t\t\t\t\tawait sleep(1000);\r\n\t\t\t\t\t\tif (player.cards.length === 0) {\r\n\t\t\t\t\t\t\tsession.winner.push({ id: player.id });\r\n\t\t\t\t\t\t\tsession.leader = '';\r\n\t\t\t\t\t\t\tsession.submitCard = [];\r\n\t\t\t\t\t\t\tsession.players = session.players.filter(p => p.id !== player.id);\r\n\t\t\t\t\t\t\tawait naze.sendText(session.id, `@${m.sender.split('@')[0]} memenangkan permainan!\\nSisa Kartu: 0`, m);\r\n\t\t\t\t\t\t\tif (session.players.length === 1) {\r\n\t\t\t\t\t\t\t\tawait naze.sendText(session.id, `Pemain Tersisa 1 (@${session.players[0].id.split('@')[0]}), sesi Blackjack selesai.`, m);\r\n\t\t\t\t\t\t\t\tdelete blackjack[session.id];\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (Object.keys(session.startCard).length === 0) {\r\n\t\t\t\t\t\t\tsession.startCard = card;\r\n\t\t\t\t\t\t\tawait naze.sendText(session.id, `@${m.sender.split('@')[0]} memulai putaran dengan ${card.rank}${card.suit}`, m);\r\n\t\t\t\t\t\t\tfor (let s of session.players) {\r\n\t\t\t\t\t\t\t\tif (s.id === session.leader) continue;\r\n\t\t\t\t\t\t\t\tconst startCard = session.startCard;\r\n\t\t\t\t\t\t\t\tlet buttons = s.cards.map(a => ({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: `${a.rank}${a.suit}`, id: `.${command} play ${a.rank}${a.suit}` })}));\r\n\t\t\t\t\t\t\t\tif (!session.hasMatching(s.id)) buttons.push({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: 'Minum', id: `.${command} minum` }) });\r\n\t\t\t\t\t\t\t\tawait naze.sendListMsg(s.id, { text: `Start Card: ${startCard.rank + startCard.suit}`, footer: `${s.cards.map(c => c.rank + c.suit).join(', ')}`, buttons }, { quoted: m });\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ((session.submitCard.length + session.skip.length) === session.players.length) {\r\n\t\t\t\t\t\t\tconst result = session.resolveRound();\r\n\t\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\t\tawait naze.sendText(session.id, result, m);\r\n\t\t\t\t\t\t\t\tif (session.players.length === 1) {\r\n\t\t\t\t\t\t\t\t\tawait naze.sendText(session.id, `Pemain Tersisa 1 (@${session.players[0].id.split('@')[0]}), sesi Blackjack selesai.`, m);\r\n\t\t\t\t\t\t\t\t\tdelete blackjack[session.id];\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tconst leaderCards = session.players.find(a => a.id === session.leader);\r\n\t\t\t\t\t\t\t\tlet buttons = leaderCards.cards.map(c => ({ name: 'quick_reply', buttonParamsJson: JSON.stringify({ display_text: `${c.rank}${c.suit}`, id: `.${command} play ${c.rank}${c.suit}` })}));\r\n\t\t\t\t\t\t\t\tawait naze.sendListMsg(session.leader, { text: 'Pilih kartu untuk memulai ronde baru', footer: leaderCards.cards.map(c => c.rank + c.suit).join(', '), buttons }, { quoted: m });\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tawait m.reply(`Kamu memainkan ${card.rank}${card.suit}`);\r\n\t\t\t\t\t\tawait naze.sendText(session.id, `@${m.sender.split('@')[0]} memainkan ${card.rank}${card.suit}`, m);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'info':\r\n\t\t\t\t\tif (!session) return m.reply('Tidak Ada Sesi Game Blackjack yang Sedang Berjalan!')\r\n\t\t\t\t\tif (!session.players?.some(a => a.id === m.sender)) return m.reply('Kamu belum bergabung!');\r\n\t\t\t\t\tconst players = session.players.map((p, i) => `${i + 1}. @${p.id.split('@')[0]} ${p.id === session.host ? '(HOST) ' : p.id === session.leader ? '(Leader)' : ''}`).join('\\n');\r\n\t\t\t\t\tif (m.isGroup) {\r\n\t\t\t\t\t\tm.reply(`üÉèINFO GAME BLACKJACK ‚ô¶Ô∏è\\n*Jumlah Pemain:* ${session.players.length}\\n*Host:* @${session.host.split('@')[0]}\\n*Status:* ${session.started ? 'Dimulai' : 'Belum Mulai'}${Object.keys(session.startCard).length > 1 ? `\\n*Start Card:* ${session.startCard.rank + session.startCard.suit}` : ''}\\n*Sisa Kartu Deck:* ${session.deck.length}\\n\\n*Daftar Pemain:*\\n${players}${session.secondDeck.length ? `\\n\\n*Riwayat Kartu:* ${session.secondDeck.map(c => `${c.rank}${c.suit}`).join(', ')}` : ''}`)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst player = session.players.find(p => p.id === m.sender);\r\n\t\t\t\t\t\tconst cards = player.cards?.map(c => `${c.rank}${c.suit}`).join(', ') || 'Belum ada kartu';\r\n\t\t\t\t\t\tm.reply(`üÉèINFO GAME BLACKJACK ‚ô¶Ô∏è\\n*Jumlah Pemain:* ${session.players.length}\\n*Host:* @${session.host.split('@')[0]}\\n*Status:* ${session.started ? 'Dimulai' : 'Belum Mulai'}${Object.keys(session.startCard).length > 1 ? `\\n*Start Card:* ${session.startCard.rank + session.startCard.suit}` : ''}\\n*Sisa Kartu Deck:* ${session.deck.length}\\n\\n*Daftar Pemain:*\\n${players}\\n\\n*Kartu Kamu:*\\n${cards}${session.secondDeck.length ? `\\n\\n*Riwayat Kartu:* ${session.secondDeck.map(c => `${c.rank}${c.suit}`).join(', ')}` : ''}`)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 'end':\r\n\t\t\t\t\tif (!m.isGroup) return m.reply(mess.group)\r\n\t\t\t\t\tif (!blackjack[m.chat]) return m.reply('Tidak Ada Sesi Game Blackjack yang Sedang Berjalan!')\r\n\t\t\t\t\tif (blackjack[m.chat]?.host !== m.sender) return m.reply(`Hanya Pembuat Room @${blackjack[m.chat].host.split('@')[0]} yang bisa Menghapus Sessi!`)\r\n\t\t\t\t\tdelete blackjack[m.chat]\r\n\t\t\t\t\tm.reply('Berhasil Menghapus Sesi Game Blackjack')\r\n\t\t\t\t\tbreak\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tm.reply(`üÉèGAME BLACKJACK‚ô¶Ô∏è\\nCommand: ${prefix + command} <command>\\n- create\\n- join\\n- start\\n- info\\n- hit\\n- deck\\n- end`)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t\t// Menu\r\n\t\t\tcase 'menu': {\r\n\t\t\t\tif (args[0] == 'set') {\r\n\t\t\t\t\tif (['1','2','3'].includes(args[1])) {\r\n\t\t\t\t\t\tset.template = parseInt(Number(args[1]))\r\n\t\t\t\t\t\tm.reply('Sukses Mengubah Template Menu')\r\n\t\t\t\t\t} else m.reply(`Silahkan Pilih Templat:\\n- 1 (Button Menu)\\n- 2 (List Menu)\\n- 3 (Document Menu)`)\r\n\t\t\t\t} else await templateMenu(naze, set.template, m, prefix, setv, db, { botNumber, author, packname, isVip, isPremium })\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'allmenu': {\r\n\t\t\t\tlet profile\r\n\t\t\t\ttry {\r\n\t\t\t\t\tprofile = await naze.profilePictureUrl(m.sender, 'image');\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tprofile = fake.anonim\r\n\t\t\t\t}\r\n\t\t\t\tconst menunya = `\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *USER INFO* „Äç‚ùç\r\n‚îú *Nama* : ${m.pushName ? m.pushName : 'Tanpa Nama'}\r\n‚îú *Id* : @${m.sender.split('@')[0]}\r\n‚îú *User* : ${isVip ? 'VIP' : isPremium ? 'PREMIUM' : 'FREE'}\r\n‚îú *Limit* : ${isVip ? 'VIP' : db.users[m.sender].limit }\r\n‚îú *Money* : ${db.users[m.sender] ? db.users[m.sender].money.toLocaleString('id-ID') : '0'}\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *BOT INFO* „Äç‚ùç\r\n‚îú *Nama Bot* : ${db?.set?.[botNumber]?.botname || 'Naze Bot'}\r\n‚îú *Powered* : @${'0@s.whatsapp.net'.split('@')[0]}\r\n‚îú *Owner* : @${ownerNumber[0].split('@')[0]}\r\n‚îú *Mode* : ${naze.public ? 'Public' : 'Self'}\r\n‚îú *Prefix* :${set.multiprefix ? '„Äå MULTI-PREFIX „Äç' : ' *'+prefix+'*' }\r\n‚îú *Premium Feature* : üî∏Ô∏è\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *ABOUT* „Äç‚ùç\r\n‚îú *Tanggal* : ${tanggal}\r\n‚îú *Hari* : ${hari}\r\n‚îú *Jam* : ${jam} WIB\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *BOT* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}profile\r\n‚îÇ${setv} ${prefix}claim\r\n‚îÇ${setv} ${prefix}buy [item] (nominal)\r\n‚îÇ${setv} ${prefix}transfer\r\n‚îÇ${setv} ${prefix}leaderboard\r\n‚îÇ${setv} ${prefix}request (text)\r\n‚îÇ${setv} ${prefix}react (emoji)\r\n‚îÇ${setv} ${prefix}tagme\r\n‚îÇ${setv} ${prefix}runtime\r\n‚îÇ${setv} ${prefix}totalfitur\r\n‚îÇ${setv} ${prefix}speed\r\n‚îÇ${setv} ${prefix}ping\r\n‚îÇ${setv} ${prefix}afk\r\n‚îÇ${setv} ${prefix}rvo (reply pesan viewone)\r\n‚îÇ${setv} ${prefix}inspect (url gc)\r\n‚îÇ${setv} ${prefix}addmsg\r\n‚îÇ${setv} ${prefix}delmsg\r\n‚îÇ${setv} ${prefix}getmsg\r\n‚îÇ${setv} ${prefix}listmsg\r\n‚îÇ${setv} ${prefix}setcmd\r\n‚îÇ${setv} ${prefix}delcmd\r\n‚îÇ${setv} ${prefix}listcmd\r\n‚îÇ${setv} ${prefix}lockcmd\r\n‚îÇ${setv} ${prefix}q (reply pesan)\r\n‚îÇ${setv} ${prefix}menfes (62xxx|fake name)\r\n‚îÇ${setv} ${prefix}confes (62xxx|fake name)\r\n‚îÇ${setv} ${prefix}roomai\r\n‚îÇ${setv} ${prefix}jadibot üî∏Ô∏è\r\n‚îÇ${setv} ${prefix}stopjadibot\r\n‚îÇ${setv} ${prefix}listjadibot\r\n‚îÇ${setv} ${prefix}donasi\r\n‚îÇ${setv} ${prefix}addsewa\r\n‚îÇ${setv} ${prefix}delsewa\r\n‚îÇ${setv} ${prefix}listsewa\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *GROUP* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}add (62xxx)\r\n‚îÇ${setv} ${prefix}kick (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}promote (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}demote (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}warn (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}unwarn (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}setname (nama baru gc)\r\n‚îÇ${setv} ${prefix}setdesc (desk)\r\n‚îÇ${setv} ${prefix}setppgc (reply imgnya)\r\n‚îÇ${setv} ${prefix}delete (reply pesan)\r\n‚îÇ${setv} ${prefix}linkgrup\r\n‚îÇ${setv} ${prefix}revoke\r\n‚îÇ${setv} ${prefix}tagall\r\n‚îÇ${setv} ${prefix}pin\r\n‚îÇ${setv} ${prefix}unpin\r\n‚îÇ${setv} ${prefix}hidetag\r\n‚îÇ${setv} ${prefix}totag (reply pesan)\r\n‚îÇ${setv} ${prefix}listonline\r\n‚îÇ${setv} ${prefix}group set\r\n‚îÇ${setv} ${prefix}group (khusus admin)\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *SEARCH* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}ytsearch (query)\r\n‚îÇ${setv} ${prefix}spotify (query)\r\n‚îÇ${setv} ${prefix}pixiv (query)\r\n‚îÇ${setv} ${prefix}pinterest (query)\r\n‚îÇ${setv} ${prefix}wallpaper (query)\r\n‚îÇ${setv} ${prefix}ringtone (query)\r\n‚îÇ${setv} ${prefix}google (query)\r\n‚îÇ${setv} ${prefix}gimage (query)\r\n‚îÇ${setv} ${prefix}npm (query)\r\n‚îÇ${setv} ${prefix}style (query)\r\n‚îÇ${setv} ${prefix}cuaca (kota)\r\n‚îÇ${setv} ${prefix}tenor (query)\r\n‚îÇ${setv} ${prefix}urban (query)\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *DOWNLOAD* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}ytmp3 (url)\r\n‚îÇ${setv} ${prefix}ytmp4 (url)\r\n‚îÇ${setv} ${prefix}instagram (url)\r\n‚îÇ${setv} ${prefix}tiktok (url)\r\n‚îÇ${setv} ${prefix}tiktokmp3 (url)\r\n‚îÇ${setv} ${prefix}facebook (url)\r\n‚îÇ${setv} ${prefix}spotifydl (url)\r\n‚îÇ${setv} ${prefix}mediafire (url)\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *QUOTES* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}motivasi\r\n‚îÇ${setv} ${prefix}quotes\r\n‚îÇ${setv} ${prefix}truth\r\n‚îÇ${setv} ${prefix}bijak\r\n‚îÇ${setv} ${prefix}dare\r\n‚îÇ${setv} ${prefix}bucin\r\n‚îÇ${setv} ${prefix}renungan\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *TOOLS* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}get (url) üî∏Ô∏è\r\n‚îÇ${setv} ${prefix}hd (reply pesan)\r\n‚îÇ${setv} ${prefix}toaudio (reply pesan)\r\n‚îÇ${setv} ${prefix}tomp3 (reply pesan)\r\n‚îÇ${setv} ${prefix}tovn (reply pesan)\r\n‚îÇ${setv} ${prefix}toimage (reply pesan)\r\n‚îÇ${setv} ${prefix}toptv (reply pesan)\r\n‚îÇ${setv} ${prefix}tourl (reply pesan)\r\n‚îÇ${setv} ${prefix}tts (textnya)\r\n‚îÇ${setv} ${prefix}toqr (textnya)\r\n‚îÇ${setv} ${prefix}brat (textnya)\r\n‚îÇ${setv} ${prefix}bratvid (textnya)\r\n‚îÇ${setv} ${prefix}ssweb (url) üî∏Ô∏è\r\n‚îÇ${setv} ${prefix}sticker (send/reply img)\r\n‚îÇ${setv} ${prefix}colong (reply stiker)\r\n‚îÇ${setv} ${prefix}smeme (send/reply img)\r\n‚îÇ${setv} ${prefix}dehaze (send/reply img)\r\n‚îÇ${setv} ${prefix}colorize (send/reply img)\r\n‚îÇ${setv} ${prefix}hitamkan (send/reply img)\r\n‚îÇ${setv} ${prefix}emojimix üôÉ+üíÄ\r\n‚îÇ${setv} ${prefix}nulis\r\n‚îÇ${setv} ${prefix}readmore text1|text2\r\n‚îÇ${setv} ${prefix}qc (pesannya)\r\n‚îÇ${setv} ${prefix}translate\r\n‚îÇ${setv} ${prefix}wasted (send/reply img)\r\n‚îÇ${setv} ${prefix}triggered (send/reply img)\r\n‚îÇ${setv} ${prefix}shorturl (urlnya)\r\n‚îÇ${setv} ${prefix}gitclone (urlnya)\r\n‚îÇ${setv} ${prefix}fat (reply audio)\r\n‚îÇ${setv} ${prefix}fast (reply audio)\r\n‚îÇ${setv} ${prefix}bass (reply audio)\r\n‚îÇ${setv} ${prefix}slow (reply audio)\r\n‚îÇ${setv} ${prefix}tupai (reply audio)\r\n‚îÇ${setv} ${prefix}deep (reply audio)\r\n‚îÇ${setv} ${prefix}robot (reply audio)\r\n‚îÇ${setv} ${prefix}blown (reply audio)\r\n‚îÇ${setv} ${prefix}reverse (reply audio)\r\n‚îÇ${setv} ${prefix}smooth (reply audio)\r\n‚îÇ${setv} ${prefix}earrape (reply audio)\r\n‚îÇ${setv} ${prefix}nightcore (reply audio)\r\n‚îÇ${setv} ${prefix}getexif (reply sticker)\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *AI* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}ai (query)\r\n‚îÇ${setv} ${prefix}simi (query)\r\n‚îÇ${setv} ${prefix}gemini (query)\r\n‚îÇ${setv} ${prefix}txt2img (query)\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *ANIME* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}waifu\r\n‚îÇ${setv} ${prefix}neko\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *GAME* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}tictactoe\r\n‚îÇ${setv} ${prefix}akinator\r\n‚îÇ${setv} ${prefix}suit\r\n‚îÇ${setv} ${prefix}slot\r\n‚îÇ${setv} ${prefix}math (level)\r\n‚îÇ${setv} ${prefix}begal\r\n‚îÇ${setv} ${prefix}ulartangga\r\n‚îÇ${setv} ${prefix}blackjack\r\n‚îÇ${setv} ${prefix}catur\r\n‚îÇ${setv} ${prefix}casino (nominal)\r\n‚îÇ${setv} ${prefix}samgong (nominal)\r\n‚îÇ${setv} ${prefix}rampok (@tag)\r\n‚îÇ${setv} ${prefix}tekateki\r\n‚îÇ${setv} ${prefix}tebaklirik\r\n‚îÇ${setv} ${prefix}tebakkata\r\n‚îÇ${setv} ${prefix}tebakbom\r\n‚îÇ${setv} ${prefix}susunkata\r\n‚îÇ${setv} ${prefix}colorblind\r\n‚îÇ${setv} ${prefix}tebakkimia\r\n‚îÇ${setv} ${prefix}caklontong\r\n‚îÇ${setv} ${prefix}tebakangka\r\n‚îÇ${setv} ${prefix}tebaknegara\r\n‚îÇ${setv} ${prefix}tebakgambar\r\n‚îÇ${setv} ${prefix}tebakbendera\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *FUN* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}coba\r\n‚îÇ${setv} ${prefix}dadu\r\n‚îÇ${setv} ${prefix}bisakah (text)\r\n‚îÇ${setv} ${prefix}apakah (text)\r\n‚îÇ${setv} ${prefix}kapan (text)\r\n‚îÇ${setv} ${prefix}siapa (text)\r\n‚îÇ${setv} ${prefix}kerangajaib (text)\r\n‚îÇ${setv} ${prefix}cekmati (nama lu)\r\n‚îÇ${setv} ${prefix}ceksifat\r\n‚îÇ${setv} ${prefix}cekkhodam (nama lu)\r\n‚îÇ${setv} ${prefix}rate (reply pesan)\r\n‚îÇ${setv} ${prefix}jodohku\r\n‚îÇ${setv} ${prefix}jadian\r\n‚îÇ${setv} ${prefix}fitnah\r\n‚îÇ${setv} ${prefix}halah (text)\r\n‚îÇ${setv} ${prefix}hilih (text)\r\n‚îÇ${setv} ${prefix}huluh (text)\r\n‚îÇ${setv} ${prefix}heleh (text)\r\n‚îÇ${setv} ${prefix}holoh (text)\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *RANDOM* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}coffe\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *STALKER* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}wastalk\r\n‚îÇ${setv} ${prefix}telestalk\r\n‚îÇ${setv} ${prefix}igstalk\r\n‚îÇ${setv} ${prefix}tiktokstalk\r\n‚îÇ${setv} ${prefix}githubstalk\r\n‚îÇ${setv} ${prefix}genshinstalk\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚ùç„Äå *OWNER* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}bot [set]\r\n‚îÇ${setv} ${prefix}setbio\r\n‚îÇ${setv} ${prefix}setppbot\r\n‚îÇ${setv} ${prefix}join\r\n‚îÇ${setv} ${prefix}leave\r\n‚îÇ${setv} ${prefix}block\r\n‚îÇ${setv} ${prefix}listblock\r\n‚îÇ${setv} ${prefix}openblock\r\n‚îÇ${setv} ${prefix}listpc\r\n‚îÇ${setv} ${prefix}listgc\r\n‚îÇ${setv} ${prefix}ban\r\n‚îÇ${setv} ${prefix}unban\r\n‚îÇ${setv} ${prefix}mute\r\n‚îÇ${setv} ${prefix}unmute\r\n‚îÇ${setv} ${prefix}creategc\r\n‚îÇ${setv} ${prefix}clearchat\r\n‚îÇ${setv} ${prefix}addprem\r\n‚îÇ${setv} ${prefix}delprem\r\n‚îÇ${setv} ${prefix}listprem\r\n‚îÇ${setv} ${prefix}addlimit\r\n‚îÇ${setv} ${prefix}adduang\r\n‚îÇ${setv} ${prefix}setbotauthor\r\n‚îÇ${setv} ${prefix}setbotname\r\n‚îÇ${setv} ${prefix}setbotpackname\r\n‚îÇ${setv} ${prefix}addowner\r\n‚îÇ${setv} ${prefix}delowner\r\n‚îÇ${setv} ${prefix}getmsgstore\r\n‚îÇ${setv} ${prefix}bot --settings\r\n‚îÇ${setv} ${prefix}bot settings\r\n‚îÇ${setv} ${prefix}getsession\r\n‚îÇ${setv} ${prefix}delsession\r\n‚îÇ${setv} ${prefix}delsampah\r\n‚îÇ${setv} ${prefix}upsw\r\n‚îÇ${setv} ${prefix}backup\r\n‚îÇ${setv} $\r\n‚îÇ${setv} >\r\n‚îÇ${setv} <\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`\r\n\t\t\t\tawait m.reply({\r\n\t\t\t\t\tdocument: fake.docs,\r\n\t\t\t\t\tfileName: ucapanWaktu,\r\n\t\t\t\t\tmimetype: pickRandom(fake.listfakedocs),\r\n\t\t\t\t\tfileLength: '100000000000000',\r\n\t\t\t\t\tpageCount: '999',\r\n\t\t\t\t\tcaption: menunya,\r\n\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\tmentionedJid: [m.sender, '0@s.whatsapp.net', ownerNumber[0] + '@s.whatsapp.net'],\r\n\t\t\t\t\t\tforwardingScore: 10,\r\n\t\t\t\t\t\tisForwarded: true,\r\n\t\t\t\t\t\tforwardedNewsletterMessageInfo: {\r\n\t\t\t\t\t\t\tnewsletterJid: my.ch,\r\n\t\t\t\t\t\t\tserverMessageId: null,\r\n\t\t\t\t\t\t\tnewsletterName: 'Join For More Info'\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\ttitle: author,\r\n\t\t\t\t\t\t\tbody: packname,\r\n\t\t\t\t\t\t\tshowAdAttribution: false,\r\n\t\t\t\t\t\t\tthumbnailUrl: profile,\r\n\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t\tpreviewType: 0,\r\n\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t\tmediaUrl: my.gh,\r\n\t\t\t\t\t\t\tsourceUrl: my.gh,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'botmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *BOT* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}profile\r\n‚îÇ${setv} ${prefix}claim\r\n‚îÇ${setv} ${prefix}buy [item] (nominal)\r\n‚îÇ${setv} ${prefix}transfer\r\n‚îÇ${setv} ${prefix}leaderboard\r\n‚îÇ${setv} ${prefix}request (text)\r\n‚îÇ${setv} ${prefix}react (emoji)\r\n‚îÇ${setv} ${prefix}tagme\r\n‚îÇ${setv} ${prefix}runtime\r\n‚îÇ${setv} ${prefix}totalfitur\r\n‚îÇ${setv} ${prefix}speed\r\n‚îÇ${setv} ${prefix}ping\r\n‚îÇ${setv} ${prefix}afk\r\n‚îÇ${setv} ${prefix}rvo (reply pesan viewone)\r\n‚îÇ${setv} ${prefix}inspect (url gc)\r\n‚îÇ${setv} ${prefix}addmsg\r\n‚îÇ${setv} ${prefix}delmsg\r\n‚îÇ${setv} ${prefix}getmsg\r\n‚îÇ${setv} ${prefix}listmsg\r\n‚îÇ${setv} ${prefix}setcmd\r\n‚îÇ${setv} ${prefix}delcmd\r\n‚îÇ${setv} ${prefix}listcmd\r\n‚îÇ${setv} ${prefix}lockcmd\r\n‚îÇ${setv} ${prefix}q (reply pesan)\r\n‚îÇ${setv} ${prefix}menfes (62xxx|fake name)\r\n‚îÇ${setv} ${prefix}confes (62xxx|fake name)\r\n‚îÇ${setv} ${prefix}roomai\r\n‚îÇ${setv} ${prefix}jadibot üî∏Ô∏è\r\n‚îÇ${setv} ${prefix}stopjadibot\r\n‚îÇ${setv} ${prefix}listjadibot\r\n‚îÇ${setv} ${prefix}donasi\r\n‚îÇ${setv} ${prefix}addsewa\r\n‚îÇ${setv} ${prefix}delsewa\r\n‚îÇ${setv} ${prefix}listsewa\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'groupmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *GROUP* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}add (62xxx)\r\n‚îÇ${setv} ${prefix}kick (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}promote (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}demote (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}warn (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}unwarn (@tag/62xxx)\r\n‚îÇ${setv} ${prefix}setname (nama baru gc)\r\n‚îÇ${setv} ${prefix}setdesc (desk)\r\n‚îÇ${setv} ${prefix}setppgc (reply imgnya)\r\n‚îÇ${setv} ${prefix}delete (reply pesan)\r\n‚îÇ${setv} ${prefix}linkgrup\r\n‚îÇ${setv} ${prefix}revoke\r\n‚îÇ${setv} ${prefix}tagall\r\n‚îÇ${setv} ${prefix}pin\r\n‚îÇ${setv} ${prefix}unpin\r\n‚îÇ${setv} ${prefix}hidetag\r\n‚îÇ${setv} ${prefix}totag (reply pesan)\r\n‚îÇ${setv} ${prefix}listonline\r\n‚îÇ${setv} ${prefix}group set\r\n‚îÇ${setv} ${prefix}group (khusus admin)\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'searchmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *SEARCH* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}ytsearch (query)\r\n‚îÇ${setv} ${prefix}spotify (query)\r\n‚îÇ${setv} ${prefix}pixiv (query)\r\n‚îÇ${setv} ${prefix}pinterest (query)\r\n‚îÇ${setv} ${prefix}wallpaper (query)\r\n‚îÇ${setv} ${prefix}ringtone (query)\r\n‚îÇ${setv} ${prefix}google (query)\r\n‚îÇ${setv} ${prefix}gimage (query)\r\n‚îÇ${setv} ${prefix}npm (query)\r\n‚îÇ${setv} ${prefix}style (query)\r\n‚îÇ${setv} ${prefix}cuaca (kota)\r\n‚îÇ${setv} ${prefix}tenor (query)\r\n‚îÇ${setv} ${prefix}urban (query)\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'downloadmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *DOWNLOAD* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}ytmp3 (url)\r\n‚îÇ${setv} ${prefix}ytmp4 (url)\r\n‚îÇ${setv} ${prefix}instagram (url)\r\n‚îÇ${setv} ${prefix}tiktok (url)\r\n‚îÇ${setv} ${prefix}tiktokmp3 (url)\r\n‚îÇ${setv} ${prefix}facebook (url)\r\n‚îÇ${setv} ${prefix}spotifydl (url)\r\n‚îÇ${setv} ${prefix}mediafire (url)\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'quotesmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *QUOTES* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}motivasi\r\n‚îÇ${setv} ${prefix}quotes\r\n‚îÇ${setv} ${prefix}truth\r\n‚îÇ${setv} ${prefix}bijak\r\n‚îÇ${setv} ${prefix}dare\r\n‚îÇ${setv} ${prefix}bucin\r\n‚îÇ${setv} ${prefix}renungan\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'toolsmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *TOOLS* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}get (url) üî∏Ô∏è\r\n‚îÇ${setv} ${prefix}hd (reply pesan)\r\n‚îÇ${setv} ${prefix}toaudio (reply pesan)\r\n‚îÇ${setv} ${prefix}tomp3 (reply pesan)\r\n‚îÇ${setv} ${prefix}tovn (reply pesan)\r\n‚îÇ${setv} ${prefix}toimage (reply pesan)\r\n‚îÇ${setv} ${prefix}toptv (reply pesan)\r\n‚îÇ${setv} ${prefix}tourl (reply pesan)\r\n‚îÇ${setv} ${prefix}tts (textnya)\r\n‚îÇ${setv} ${prefix}toqr (textnya)\r\n‚îÇ${setv} ${prefix}brat (textnya)\r\n‚îÇ${setv} ${prefix}bratvid (textnya)\r\n‚îÇ${setv} ${prefix}ssweb (url) üî∏Ô∏è\r\n‚îÇ${setv} ${prefix}sticker (send/reply img)\r\n‚îÇ${setv} ${prefix}colong (reply stiker)\r\n‚îÇ${setv} ${prefix}smeme (send/reply img)\r\n‚îÇ${setv} ${prefix}dehaze (send/reply img)\r\n‚îÇ${setv} ${prefix}colorize (send/reply img)\r\n‚îÇ${setv} ${prefix}hitamkan (send/reply img)\r\n‚îÇ${setv} ${prefix}emojimix üôÉ+üíÄ\r\n‚îÇ${setv} ${prefix}nulis\r\n‚îÇ${setv} ${prefix}readmore text1|text2\r\n‚îÇ${setv} ${prefix}qc (pesannya)\r\n‚îÇ${setv} ${prefix}translate\r\n‚îÇ${setv} ${prefix}wasted (send/reply img)\r\n‚îÇ${setv} ${prefix}triggered (send/reply img)\r\n‚îÇ${setv} ${prefix}shorturl (urlnya)\r\n‚îÇ${setv} ${prefix}gitclone (urlnya)\r\n‚îÇ${setv} ${prefix}fat (reply audio)\r\n‚îÇ${setv} ${prefix}fast (reply audio)\r\n‚îÇ${setv} ${prefix}bass (reply audio)\r\n‚îÇ${setv} ${prefix}slow (reply audio)\r\n‚îÇ${setv} ${prefix}tupai (reply audio)\r\n‚îÇ${setv} ${prefix}deep (reply audio)\r\n‚îÇ${setv} ${prefix}robot (reply audio)\r\n‚îÇ${setv} ${prefix}blown (reply audio)\r\n‚îÇ${setv} ${prefix}reverse (reply audio)\r\n‚îÇ${setv} ${prefix}smooth (reply audio)\r\n‚îÇ${setv} ${prefix}earrape (reply audio)\r\n‚îÇ${setv} ${prefix}nightcore (reply audio)\r\n‚îÇ${setv} ${prefix}getexif (reply sticker)\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'aimenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *AI* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}ai (query)\r\n‚îÇ${setv} ${prefix}simi (query)\r\n‚îÇ${setv} ${prefix}gemini (query)\r\n‚îÇ${setv} ${prefix}txt2img (query)\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'randommenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *RANDOM* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}coffe\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'stalkermenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *STALKER* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}wastalk\r\n‚îÇ${setv} ${prefix}telestalk\r\n‚îÇ${setv} ${prefix}igstalk\r\n‚îÇ${setv} ${prefix}tiktokstalk\r\n‚îÇ${setv} ${prefix}githubstalk\r\n‚îÇ${setv} ${prefix}genshinstalk\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'animemenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *ANIME* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}waifu\r\n‚îÇ${setv} ${prefix}neko\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'gamemenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *GAME* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}tictactoe\r\n‚îÇ${setv} ${prefix}akinator\r\n‚îÇ${setv} ${prefix}suit\r\n‚îÇ${setv} ${prefix}slot\r\n‚îÇ${setv} ${prefix}math (level)\r\n‚îÇ${setv} ${prefix}begal\r\n‚îÇ${setv} ${prefix}ulartangga\r\n‚îÇ${setv} ${prefix}blackjack\r\n‚îÇ${setv} ${prefix}catur\r\n‚îÇ${setv} ${prefix}casino (nominal)\r\n‚îÇ${setv} ${prefix}samgong (nominal)\r\n‚îÇ${setv} ${prefix}rampok (@tag)\r\n‚îÇ${setv} ${prefix}tekateki\r\n‚îÇ${setv} ${prefix}tebaklirik\r\n‚îÇ${setv} ${prefix}tebakkata\r\n‚îÇ${setv} ${prefix}tebakbom\r\n‚îÇ${setv} ${prefix}susunkata\r\n‚îÇ${setv} ${prefix}colorblind\r\n‚îÇ${setv} ${prefix}tebakkimia\r\n‚îÇ${setv} ${prefix}caklontong\r\n‚îÇ${setv} ${prefix}tebakangka\r\n‚îÇ${setv} ${prefix}tebaknegara\r\n‚îÇ${setv} ${prefix}tebakgambar\r\n‚îÇ${setv} ${prefix}tebakbendera\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'funmenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *FUN* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}coba\r\n‚îÇ${setv} ${prefix}dadu\r\n‚îÇ${setv} ${prefix}bisakah (text)\r\n‚îÇ${setv} ${prefix}apakah (text)\r\n‚îÇ${setv} ${prefix}kapan (text)\r\n‚îÇ${setv} ${prefix}siapa (text)\r\n‚îÇ${setv} ${prefix}kerangajaib (text)\r\n‚îÇ${setv} ${prefix}cekmati (nama lu)\r\n‚îÇ${setv} ${prefix}ceksifat\r\n‚îÇ${setv} ${prefix}cekkhodam (nama lu)\r\n‚îÇ${setv} ${prefix}rate (reply pesan)\r\n‚îÇ${setv} ${prefix}jodohku\r\n‚îÇ${setv} ${prefix}jadian\r\n‚îÇ${setv} ${prefix}fitnah\r\n‚îÇ${setv} ${prefix}halah (text)\r\n‚îÇ${setv} ${prefix}hilih (text)\r\n‚îÇ${setv} ${prefix}huluh (text)\r\n‚îÇ${setv} ${prefix}heleh (text)\r\n‚îÇ${setv} ${prefix}holoh (text)\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\t\t\tcase 'ownermenu': {\r\n\t\t\t\tm.reply(`\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *OWNER* „Äç‚ùç\r\n‚îÇ${setv} ${prefix}bot [set]\r\n‚îÇ${setv} ${prefix}setbio\r\n‚îÇ${setv} ${prefix}setppbot\r\n‚îÇ${setv} ${prefix}join\r\n‚îÇ${setv} ${prefix}leave\r\n‚îÇ${setv} ${prefix}block\r\n‚îÇ${setv} ${prefix}listblock\r\n‚îÇ${setv} ${prefix}openblock\r\n‚îÇ${setv} ${prefix}listpc\r\n‚îÇ${setv} ${prefix}listgc\r\n‚îÇ${setv} ${prefix}ban\r\n‚îÇ${setv} ${prefix}unban\r\n‚îÇ${setv} ${prefix}mute\r\n‚îÇ${setv} ${prefix}unmute\r\n‚îÇ${setv} ${prefix}creategc\r\n‚îÇ${setv} ${prefix}clearchat\r\n‚îÇ${setv} ${prefix}addprem\r\n‚îÇ${setv} ${prefix}delprem\r\n‚îÇ${setv} ${prefix}listprem\r\n‚îÇ${setv} ${prefix}addlimit\r\n‚îÇ${setv} ${prefix}adduang\r\n‚îÇ${setv} ${prefix}setbotauthor\r\n‚îÇ${setv} ${prefix}setbotname\r\n‚îÇ${setv} ${prefix}setbotpackname\r\n‚îÇ${setv} ${prefix}addowner\r\n‚îÇ${setv} ${prefix}delowner\r\n‚îÇ${setv} ${prefix}getmsgstore\r\n‚îÇ${setv} ${prefix}bot --settings\r\n‚îÇ${setv} ${prefix}bot settings\r\n‚îÇ${setv} ${prefix}getsession\r\n‚îÇ${setv} ${prefix}delsession\r\n‚îÇ${setv} ${prefix}delsampah\r\n‚îÇ${setv} ${prefix}upsw\r\n‚îÇ${setv} ${prefix}backup\r\n‚îÇ${setv} $\r\n‚îÇ${setv} >\r\n‚îÇ${setv} <\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`)\r\n\t\t\t}\r\n\t\t\tbreak\r\n\r\n\t\t\tdefault:\r\n\t\t\tif (budy.startsWith('>')) {\r\n\t\t\t\tif (!isCreator) return\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet evaled = await eval(budy.slice(2))\r\n\t\t\t\t\tif (typeof evaled !== 'string') evaled = require('util').inspect(evaled)\r\n\t\t\t\t\tawait m.reply(evaled)\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tawait m.reply(String(err))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (budy.startsWith('<')) {\r\n\t\t\t\tif (!isCreator) return\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet evaled = await eval(`(async () => { ${budy.slice(2)} })()`)\r\n\t\t\t\t\tif (typeof evaled !== 'string') evaled = require('util').inspect(evaled)\r\n\t\t\t\t\tawait m.reply(evaled)\r\n\t\t\t\t} catch (err) {\r\n\t\t\t\t\tawait m.reply(String(err))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (budy.startsWith('$')) {\r\n\t\t\t\tif (!isCreator) return\r\n\t\t\t\tif (!text) return\r\n\t\t\t\texec(budy.slice(2), (err, stdout) => {\r\n\t\t\t\t\tif (err) return m.reply(`${err}`)\r\n\t\t\t\t\tif (stdout) return m.reply(stdout)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif ((!isCmd || isCreator) && budy.toLowerCase() != undefined) {\r\n\t\t\t\tif (m.chat.endsWith('broadcast')) return\r\n\t\t\t\tif (!(budy.toLowerCase() in db.database)) return\r\n\t\t\t\tawait naze.relayMessage(m.chat, db.database[budy.toLowerCase()], {})\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (e) {\r\n\t\tconsole.log(e);\r\n\t\tif (e?.message?.includes('No sessions')) return;\r\n\t\tconst errorKey = e?.code || e?.name || e?.message?.slice(0, 100) || 'unknown_error';\r\n\t\tconst now = Date.now();\r\n\t\tif (!errorCache[errorKey]) errorCache[errorKey] = [];\r\n\t\terrorCache[errorKey] = errorCache[errorKey].filter(ts => now - ts < 600000);\r\n\t\tif (errorCache[errorKey].length >= 3) return;\r\n\t\terrorCache[errorKey].push(now);\r\n\t\tm.reply('Error: ' + (e?.name || e?.code || e?.output?.statusCode || e?.status || 'Tidak diketahui') + '\\nLog Error Telah dikirim ke Owner\\n\\n')\r\n\t\treturn naze.sendFromOwner(ownerNumber, `Halo sayang, sepertinya ada yang error nih, jangan lupa diperbaiki ya\\n\\nVersion : *${require('./package.json').version}*\\n\\n*Log error:*\\n\\n` + util.format(e), m, { contextInfo: { isForwarded: true }})\r\n\t}\r\n}\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});\r\n","path":null,"size_bytes":218260,"size_tokens":null},"replit.md":{"content":"# Ciel Bot - WhatsApp Bot dengan PostgreSQL\n\n## Overview\n\nCiel Bot adalah WhatsApp bot canggih yang dibangun menggunakan Node.js dan Baileys library. Bot ini menggunakan PostgreSQL sebagai database utama melalui Prisma ORM untuk manajemen data pengguna, grup, dan fitur-fitur bot. Bot mendukung berbagai fitur seperti download media, game, AI chat, sticker creation, dan sistem premium/limit.\n\nProyek ini merupakan evolusi dari berbagai WhatsApp bot sebelumnya (Hitori Bot, TikTok Downloader Bot) yang digabungkan menjadi satu sistem yang lebih terstruktur dengan database PostgreSQL.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\nBahasa komunikasi: **Bahasa Indonesia** (sesuai file.txt dan dokumentasi deployment). Selalu gunakan Bahasa Indonesia dalam interaksi dengan user.\n\n## System Architecture\n\n### Core Technology Stack\n\n- **Runtime**: Node.js v18+ (CommonJS modules)\n- **WhatsApp Library**: @whiskeysockets/baileys v6.7.9 untuk multi-device WhatsApp connection\n- **Database ORM**: Prisma v5.22.0 dengan PostgreSQL\n- **Web Framework**: Express.js untuk health check dan monitoring endpoints\n- **AI Integration**: Google Generative AI (Gemini) untuk fitur AI chat\n- **Process Manager**: PM2 ecosystem (production) dan Nodemon (development)\n\n### Authentication & Connection\n\nBot menggunakan Baileys multi-file auth state yang disimpan di folder `sessions/ciel_session/`. Mendukung dua mode koneksi:\n- QR Code scanning (default)\n- Pairing code untuk deployment tanpa akses visual ke terminal\n\nConnection handler mengelola reconnection otomatis dengan retry policy saat terjadi disconnect.\n\n### Database Architecture\n\n**Database**: PostgreSQL (via Prisma ORM)\n\nSchema utama mencakup:\n- **Users**: Menyimpan data pengguna (jid, name, limit, money, premium status, banned status)\n- **Groups**: Data grup WhatsApp (jid, name, welcome/leave messages, settings seperti antilink, mute)\n- **BotSettings**: Konfigurasi global bot (owner numbers, bot name, packname, author)\n- **ActiveGames**: Tracking game yang sedang berlangsung (TicTacToe, dll)\n- **Hits**: Statistik penggunaan command\n- **Premium**: Tracking user premium dengan expired date\n- **Sewa**: Tracking grup sewa dengan expired date\n\nDatabase management functions di `src/services/database.js` menggunakan pattern `getOrCreate` untuk lazy initialization dan automatic cleanup untuk data expired.\n\n### Message Processing Flow\n\n1. **Connection Layer** (`src/index.js`): Inisialisasi Baileys socket, auth state, event handlers\n2. **Serialization** (`src/handlers/serialize.js`): Normalisasi pesan WhatsApp menjadi objek yang mudah digunakan dengan properties seperti `m.sender`, `m.isGroup`, `m.quoted`, dll\n3. **Message Handler** (`src/handlers/messageHandler.js`): \n   - Anti-spam checking\n   - User/Group creation di database\n   - Permission checking (owner, admin, premium)\n   - Command parsing dengan multi-prefix support\n   - Command routing ke handler yang sesuai\n4. **Command Handlers** (`src/handlers/commands/*.js`): Modular command implementation (download, game, group, info, owner, tools, fun)\n\n### Media Processing\n\nConverter utilities (`lib/converter.js`) menggunakan FFmpeg untuk:\n- Audio conversion (toAudio, toPTT)\n- Video processing\n- Image manipulation dengan Sharp library\n\nSticker creation (`lib/exif.js`) menggunakan node-webpmux untuk menambahkan EXIF metadata (packname, author).\n\n### Group Management\n\nGroup handler (`src/handlers/groupHandler.js`) menangani:\n- Participant add/remove events\n- Welcome/leave messages dengan customizable text\n- Auto-kick untuk link detector (antilink)\n- Metadata synchronization dengan database\n\n### External Service Integration\n\n- **TikTok Downloader**: Multiple API implementations (tmate.js, tikSnap.js) dengan fallback mechanism\n- **Gemini AI**: Google Generative AI untuk conversational features\n- **Media Upload**: Telegraph dan Uguu.se untuk temporary file hosting\n\n### Server & Monitoring\n\nExpress server (`src/server.js`) menyediakan:\n- `/` - Bot info dan statistics\n- `/health` - Health check endpoint untuk Railway/deployment platforms\n- `/stats` - Performance metrics (uptime, memory, database stats)\n\nServer berjalan di port yang dikonfigurasi (default: 5000) untuk monitoring oleh Railway atau platform deployment lainnya.\n\n### Anti-Spam System\n\nSimple rate-limiting menggunakan Map-based cooldown (`src/utils/antiSpam.js`) dengan auto-cleanup untuk mencegah command flooding.\n\n### Logging & Debugging\n\nCustom logger (`src/utils/logger.js`) menggunakan Chalk untuk colored console output dengan timestamps. Categories: info, success, warn, error, incoming, outgoing, command.\n\nPino logger digunakan untuk Baileys internal logging (set to silent di production).\n\n### Deployment Support\n\nMendukung multiple deployment platforms:\n- **Railway**: railway.json dengan Nixpacks builder, health check, auto-restart policy\n- **Replit**: Standard Node.js deployment dengan Secrets management\n- **VPS/Local**: PM2 ecosystem config untuk production management\n\nDatabase URL dan environment variables dikonfigurasi via `.env` file atau platform environment variables.\n\n## External Dependencies\n\n### Primary Services\n\n- **PostgreSQL Database**: Hosted service (Railway, Supabase, Neon) untuk persistent storage\n  - Connection URL via `DATABASE_URL` environment variable\n  - Prisma manages migrations dan schema\n\n### Third-Party APIs\n\n- **Google Gemini API**: AI conversation features\n  - API key via `GEMINI_API_KEY` environment variable\n- **TikTok/Douyin Downloaders**: Multiple scraper implementations tanpa official API\n  - Tmate (tmate.cc)\n  - SavetikAPI (savetik.co)\n- **Telegraph**: Media hosting untuk temporary images\n- **Uguu.se**: Alternative file hosting\n\n### System Dependencies\n\n- **FFmpeg**: Required untuk audio/video conversion\n- **ImageMagick**: Optional untuk advanced image processing (commented out di source-1)\n- **Node-webpmux**: WebP manipulation untuk stickers\n\n### NPM Packages (Key Dependencies)\n\n- `@whiskeysockets/baileys`: WhatsApp Web API\n- `@prisma/client`: Database ORM client\n- `@google/generative-ai`: Gemini AI integration\n- `express`: Web server\n- `axios`: HTTP client\n- `cheerio`: HTML parsing untuk scrapers\n- `sharp`: Image processing\n- `fluent-ffmpeg`: FFmpeg wrapper\n- `moment-timezone`: Timezone handling (Asia/Jakarta)\n- `qrcode-terminal`: QR code display\n- `node-cache`: In-memory caching\n- `node-cron`: Scheduled tasks\n- `pino` & `pino-pretty`: Structured logging","path":null,"size_bytes":6460,"size_tokens":null},"source-1/lib/screaper.js":{"content":"const fs = require('fs');\r\nconst path = require('path');\r\nconst chalk = require('chalk');\r\nconst https = require('https');\r\nconst axios = require('axios');\r\nconst yts = require('yt-search');\r\nconst ytdl = require('ytdl-core');\r\nconst crypto = require('crypto');\r\nconst cheerio = require('cheerio');\r\nconst fetch = require('node-fetch');\r\nconst FormData = require('form-data');\r\nconst { exec, spawn, execSync } = require('child_process');\r\nconst { GoogleGenerativeAI } = require('@google/generative-ai');\r\n\r\nasync function bytesToSize(bytes) {\r\n\tconst sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\r\n\tif (bytes === 0) return \"n/a\";\r\n\tconst i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)), 10);\r\n\tif (i === 0) resolve(`${bytes} ${sizes[i]}`);\r\n\treturn `${(bytes / 1024 ** i).toFixed(1)} ${sizes[i]}`;\r\n}\r\n\r\nconst agent = new https.Agent({\r\n\trejectUnauthorized: true,\r\n\tmaxVersion: 'TLSv1.3',\r\n\tminVersion: 'TLSv1.2'\r\n});\r\n\r\nconst yousearch = axios.create({\r\n\tbaseURL: 'https://app.yoursearch.ai',\r\n\theaders: {\r\n\t\t'content-type': 'application/json'\r\n\t}\r\n});\r\n\r\nasync function mediafireDl(url) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst res = await fetch('https://r.jina.ai/' + url, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'x-return-format': 'html'\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst data = await res.text()\r\n\t\t\tconst $ = cheerio.load(data);\r\n\t\t\tconst link = $('a#downloadButton').attr('href');\r\n\t\t\tconst size = $('a#downloadButton').text().replace('Download', '').replace('(', '').replace(')', '').trim();\r\n\t\t\tconst upload_date = $('.dl-info .details li').last().find('span').text().trim();\r\n\t\t\tconst name = $('div.dl-btn-label').attr('title') || link.split('/')[5];\r\n\t\t\tconst type = name.split('.')[1] || '';\r\n\t\t\tresolve({ name, type, upload_date, size, link })\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function pinterest(query) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\tconst baseUrl = 'https://www.pinterest.com/resource/BaseSearchResource/get/';\r\n\t\tconst params = {\r\n\t\t\tsource_url: '/search/pins/?q=' + encodeURIComponent(query),\r\n\t\t\tdata: JSON.stringify({\r\n\t\t\t\toptions: {\r\n\t\t\t\t\tisPrefetch: false,\r\n\t\t\t\t\tquery,\r\n\t\t\t\t\tscope: 'pins',\r\n\t\t\t\t\tno_fetch_context_on_resource: false\r\n\t\t\t\t},\r\n\t\t\t\tcontext: {}\r\n\t\t\t}),\r\n\t\t\t_: Date.now()\r\n\t\t};\r\n\t\tconst headers = {\r\n\t\t\t'accept': 'application/json, text/javascript, */*, q=0.01',\r\n\t\t\t'accept-encoding': 'gzip, deflate',\r\n\t\t\t'accept-language': 'en-US,en;q=0.9',\r\n\t\t\t'dnt': '1',\r\n\t\t\t'referer': 'https://www.pinterest.com/',\r\n\t\t\t'sec-ch-ua': '\"Not(A:Brand\";v=\"99\", \"Microsoft Edge\";v=\"133\", \"Chromium\";v=\"133\"',\r\n\t\t\t'sec-ch-ua-full-version-list': '\"Not(A:Brand\";v=\"99.0.0.0\", \"Microsoft Edge\";v=\"133.0.3065.92\", \"Chromium\";v=\"133.0.6943.142\"',\r\n\t\t\t'sec-ch-ua-mobile': '?0',\r\n\t\t\t'sec-ch-ua-model': '\"\"',\r\n\t\t\t'sec-ch-ua-platform': '\"Windows\"',\r\n\t\t\t'sec-ch-ua-platform-version': '\"10.0.0\"',\r\n\t\t\t'sec-fetch-dest': 'empty',\r\n\t\t\t'sec-fetch-mode': 'cors',\r\n\t\t\t'sec-fetch-site': 'same-origin',\r\n\t\t\t'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36 Edg/133.0.0.0',\r\n\t\t\t'x-app-version': 'c056fb7',\r\n\t\t\t'x-pinterest-appstate': 'active',\r\n\t\t\t'x-pinterest-pws-handler': 'www/[username]/[slug].js',\r\n\t\t\t'x-pinterest-source-url': '/hargr003/cat-pictures/',\r\n\t\t\t'x-requested-with': 'XMLHttpRequest'\r\n\t\t};\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.get(baseUrl, { httpsAgent: agent, headers, params });\r\n\t\t\tconst results = data.resource_response?.data?.results?? [];\r\n\t\t\tconst result = results.map(item => ({\r\n\t\t\t\tpin: 'https://www.pinterest.com/pin/' + item.id?? '',\r\n\t\t\t\tlink: item.link?? '',\r\n\t\t\t\tcreated_at: (new Date(item.created_at)).toLocaleDateString('id-ID', {\r\n\t\t\t\t\tday: 'numeric',\r\n\t\t\t\t\tmonth: 'long',\r\n\t\t\t\t\tyear: 'numeric'\r\n\t\t\t\t}) ?? '',\r\n\t\t\t\tid: item.id?? '',\r\n\t\t\t\timages_url: item.images?.['736x']?.url?? '',\r\n\t\t\t\tgrid_title: item.grid_title?? ''\r\n\t\t\t}));\r\n\t\t\tresolve(result);\r\n\t\t} catch (e) {\r\n\t\t\treject([])\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function remini(buffer, method = 'recolor') {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst form = new FormData();\r\n\t\t\tconst input = Buffer.from(buffer);\r\n\t\t\tform.append('model_version', 1);\r\n\t\t\tform.append('image', input, { filename: 'enhance_image_body.jpg', contentType: 'image/jpeg'  });\r\n\t\t\tconst { data } = await axios.post('https://inferenceengine.vyro.ai/' + method, form, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t...form.getHeaders(),\r\n\t\t\t\t\t'accept-encoding': 'gzip',\r\n\t\t\t\t\t'user-agent': 'Postify/1.0.0',\r\n\t\t\t\t},\r\n\t\t\t\tresponseType: 'arraybuffer',\r\n\t\t\t});\r\n\t\t\tresolve(data)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function styletext(teks) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\taxios.get('http://qaz.wtf/u/convert.cgi?text=' + teks).then(({ data }) => {\r\n\t\t\tlet $ = cheerio.load(data)\r\n\t\t\tlet hasil = []\r\n\t\t\t$('table > tbody > tr').each(function (a, b) {\r\n\t\t\t\thasil.push({ name: $(b).find('td:nth-child(1) > span').text(), result: $(b).find('td:nth-child(2)').text().trim() })\r\n\t\t\t});\r\n\t\t\tresolve(hasil)\r\n\t\t});\r\n\t});\r\n}\r\n\r\nasync function hitamkan(buffer, filter = 'coklat') {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.post('https://negro.consulting/api/process-image', JSON.stringify({\r\n\t\t\t\timageData: Buffer.from(buffer).toString('base64'),\r\n\t\t\t\tfilter\r\n\t\t\t}), {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'content-type': 'application/json'\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif(data && data.status === 'success') {\r\n\t\t\t\tresolve(Buffer.from(data.processedImageUrl.split(',')[1], 'base64'))\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function ringtone(title) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\taxios.get('https://meloboom.com/en/search/' + title).then(({ data }) => {\r\n\t\t\tlet $ = cheerio.load(data)\r\n\t\t\tlet hasil = []\r\n\t\t\t$('#__next > main > section > div.jsx-2244708474.container > div > div > div > div:nth-child(4) > div > div > div > ul > li').each(function (a, b) {\r\n\t\t\t\thasil.push({ title: $(b).find('h4').text(), source: 'https://meloboom.com/'+$(b).find('a').attr('href'), audio: $(b).find('audio').attr('src') })\r\n\t\t\t});\r\n\t\t\tresolve(hasil)\r\n\t\t});\r\n\t});\r\n}\r\n\r\nasync function wallpaper(title, page = '1') {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.get(`https://www.besthdwallpaper.com/search?CurrentPage=${page}&q=${title}`);\r\n\t\t\tconst $ = cheerio.load(data);\r\n\t\t\tconst hasil = [];\r\n\t\t\t$('div.grid-item').each(function (a, b) {\r\n\t\t\t\thasil.push({\r\n\t\t\t\t\ttitle: $(b).find('div.info > p').attr('title'),\r\n\t\t\t\t\ttype: $(b).find('div.info > a:nth-child(2)').text(),\r\n\t\t\t\t\tsource: 'https://www.besthdwallpaper.com' + $(b).find('a').attr('href'),\r\n\t\t\t\t\timage: [\r\n\t\t\t\t\t\t$(b).find('picture > img').attr('data-src') || $(b).find('picture > img').attr('src'), \r\n\t\t\t\t\t\t$(b).find('picture > source:nth-child(1)').attr('srcset'), \r\n\t\t\t\t\t\t$(b).find('picture > source:nth-child(2)').attr('srcset')\r\n\t\t\t\t\t]\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\tresolve(hasil)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function wikimedia(title) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\taxios.get(`https://commons.wikimedia.org/w/index.php?search=${title}&title=Special:MediaSearch&go=Go&type=image`).then(({ data }) => {\r\n\t\t\tlet $ = cheerio.load(data)\r\n\t\t\tlet hasil = []\r\n\t\t\t$('.sdms-search-results__list-wrapper > div > a').each(function (a, b) {\r\n\t\t\t\thasil.push({ title: $(b).find('img').attr('alt'), source: $(b).attr('href'), image: $(b).find('img').attr('data-src') || $(b).find('img').attr('src') })\r\n\t\t\t});\r\n\t\t\tresolve(hasil)\r\n\t\t});\r\n\t});\r\n}\r\n\r\nasync function instagramDl(url) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.post('https://yt1s.io/api/ajaxSearch', new URLSearchParams({ q: url, w: '', p: 'home', lang: 'en' }), {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'Accept': 'application/json, text/plain, */*',\r\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\r\n\t\t\t\t\t'Origin': 'https://yt1s.io',\r\n\t\t\t\t\t'Referer': 'https://yt1s.io/',\r\n\t\t\t\t\t'User-Agent': 'Postify/1.0.0',\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst $ = cheerio.load(data.data);\r\n\t\t\tlet anu = $('a.abutton.is-success.is-fullwidth.btn-premium').map((_, b) => ({\r\n\t\t\t\ttitle: $(b).attr('title'),\r\n\t\t\t\turl: $(b).attr('href')\r\n\t\t\t})).get()\r\n\t\t\tresolve(anu)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function tiktokDl(url) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tlet data = []\r\n\t\t\tfunction formatNumber(integer) {\r\n\t\t\t\tlet numb = parseInt(integer)\r\n\t\t\t\treturn Number(numb).toLocaleString().replace(/,/g, '.')\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfunction formatDate(n, locale = 'en') {\r\n\t\t\t\tlet d = new Date(n)\r\n\t\t\t\treturn d.toLocaleDateString(locale, {\r\n\t\t\t\t\tweekday: 'long',\r\n\t\t\t\t\tday: 'numeric',\r\n\t\t\t\t\tmonth: 'long',\r\n\t\t\t\t\tyear: 'numeric',\r\n\t\t\t\t\thour: 'numeric',\r\n\t\t\t\t\tminute: 'numeric',\r\n\t\t\t\t\tsecond: 'numeric'\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet domain = 'https://www.tikwm.com/api/';\r\n\t\t\tlet res = await (await axios.post(domain, {}, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'Accept': 'application/json, text/javascript, */*; q=0.01',\r\n\t\t\t\t\t'Accept-Language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',\r\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\r\n\t\t\t\t\t'Origin': 'https://www.tikwm.com',\r\n\t\t\t\t\t'Referer': 'https://www.tikwm.com/',\r\n\t\t\t\t\t'Sec-Ch-Ua': '\"Not)A;Brand\" ;v=\"24\" , \"Chromium\" ;v=\"116\"',\r\n\t\t\t\t\t'Sec-Ch-Ua-Mobile': '?1',\r\n\t\t\t\t\t'Sec-Ch-Ua-Platform': 'Android',\r\n\t\t\t\t\t'Sec-Fetch-Dest': 'empty',\r\n\t\t\t\t\t'Sec-Fetch-Mode': 'cors',\r\n\t\t\t\t\t'Sec-Fetch-Site': 'same-origin',\r\n\t\t\t\t\t'User-Agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36',\r\n\t\t\t\t\t'X-Requested-With': 'XMLHttpRequest'\r\n\t\t\t\t},\r\n\t\t\t\tparams: {\r\n\t\t\t\t\turl: url,\r\n\t\t\t\t\thd: 1\r\n\t\t\t\t}\r\n\t\t\t})).data.data\r\n\t\t\tif (res && !res.size && !res.wm_size && !res.hd_size) {\r\n\t\t\t\tres.images.map(v => {\r\n\t\t\t\t\tdata.push({ type: 'photo', url: v })\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tif (res && res.wmplay) {\r\n\t\t\t\t\tdata.push({ type: 'watermark', url: res.wmplay })\r\n\t\t\t\t}\r\n\t\t\t\tif (res && res.play) {\r\n\t\t\t\t\tdata.push({ type: 'nowatermark', url: res.play })\r\n\t\t\t\t}\r\n\t\t\t\tif (res && res.hdplay) {\r\n\t\t\t\t\tdata.push({ type: 'nowatermark_hd', url: res.hdplay })\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet json = {\r\n\t\t\t\tstatus: true,\r\n\t\t\t\ttitle: res.title,\r\n\t\t\t\ttaken_at: formatDate(res.create_time).replace('1970', ''),\r\n\t\t\t\tregion: res.region,\r\n\t\t\t\tid: res.id,\r\n\t\t\t\tdurations: res.duration,\r\n\t\t\t\tduration: res.duration + ' Seconds',\r\n\t\t\t\tcover: res.cover,\r\n\t\t\t\tsize_wm: res.wm_size,\r\n\t\t\t\tsize_nowm: res.size,\r\n\t\t\t\tsize_nowm_hd: res.hd_size,\r\n\t\t\t\tdata: data,\r\n\t\t\t\tmusic_info: {\r\n\t\t\t\t\tid: res.music_info.id,\r\n\t\t\t\t\ttitle: res.music_info.title,\r\n\t\t\t\t\tauthor: res.music_info.author,\r\n\t\t\t\t\talbum: res.music_info.album ? res.music_info.album : null,\r\n\t\t\t\t\turl: res.music || res.music_info.play\r\n\t\t\t\t},\r\n\t\t\t\tstats: {\r\n\t\t\t\t\tviews: formatNumber(res.play_count),\r\n\t\t\t\t\tlikes: formatNumber(res.digg_count),\r\n\t\t\t\t\tcomment: formatNumber(res.comment_count),\r\n\t\t\t\t\tshare: formatNumber(res.share_count),\r\n\t\t\t\t\tdownload: formatNumber(res.download_count)\r\n\t\t\t\t},\r\n\t\t\t\tauthor: {\r\n\t\t\t\t\tid: res.author.id,\r\n\t\t\t\t\tfullname: res.author.unique_id,\r\n\t\t\t\t\tnickname: res.author.nickname,\r\n\t\t\t\t\tavatar: res.author.avatar\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresolve(json)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function facebookDl(url) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.post('https://getmyfb.com/process', new URLSearchParams({\r\n\t\t\t\tid: decodeURIComponent(url),\r\n\t\t\t\tlocale: 'en',\r\n\t\t\t}), {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'hx-current-url': 'https://getmyfb.com/',\r\n\t\t\t\t\t'hx-request': 'true',\r\n\t\t\t\t\t'hx-target': url.includes('share') ? '#private-video-downloader' : '#target',\r\n\t\t\t\t\t'hx-trigger': 'form',\r\n\t\t\t\t\t'hx-post': '/process',\r\n\t\t\t\t\t'hx-swap': 'innerHTML',\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst $ = cheerio.load(data);\r\n\t\t\tresolve({\r\n\t\t\t\tcaption: $('.results-item-text').length > 0 ? $('.results-item-text').text().trim() : '',\r\n\t\t\t\tpreview: $('.results-item-image').attr('src') || '',\r\n\t\t\t\tresults: $('.results-list-item').get().map(el => ({\r\n\t\t\t\t\tquality: parseInt($(el).text().trim()) || '',\r\n\t\t\t\t\ttype: $(el).text().includes('HD') ? 'HD' : 'SD',\r\n\t\t\t\t\turl: $(el).find('a').attr('href') || '',\r\n\t\t\t\t}))\r\n\t\t\t});\r\n\t\t} catch (e) {\r\n\t\t\treject(e);\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function instaStalk(username) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.get('https://greatfon.com/v/' + username.toLowerCase(), {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',\r\n\t\t\t\t\t'Accept-Language': 'en-US,en;q=0.9',\r\n\t\t\t\t\t'Cache-Control': 'no-cache',\r\n\t\t\t\t\t'Pragma': 'no-cache',\r\n\t\t\t\t\t'Connection': 'keep-alive',\r\n\t\t\t\t\t'Upgrade-Insecure-Requests': '1',\r\n\t\t\t\t\t'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n\t\t\t\t\t'Sec-Fetch-Dest': 'document',\r\n\t\t\t\t\t'Sec-Fetch-Mode': 'navigate',\r\n\t\t\t\t\t'Sec-Fetch-Site': 'none',\r\n\t\t\t\t\t'Sec-Fetch-User': '?1'\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst $ = cheerio.load(data);\r\n\t\t\tlet list_post = [];\r\n\t\t\t$('.card').each((a, b) => {\r\n\t\t\t\tconst imageUrl = $(b).find('img').attr('src');\r\n\t\t\t\tconst description = $(b).find('img').attr('alt').replace(/.*Instagram post:\\s*/, '');\r\n\t\t\t\tconst detailUrl = 'https://greatfon.io' + $(b).find('a').attr('href');\r\n\t\t\t\tlist_post.push({ imageUrl, description, detailUrl });\r\n\t\t\t});\r\n\t\t\tresolve({\r\n\t\t\t\tavatar: $('.avatar img').attr('src') || '',\r\n\t\t\t\tusername: $('h1.text-4xl').text().trim() || '',\r\n\t\t\t\tnickname: $('h2.text-2xl').text().trim() || '',\r\n\t\t\t\tdescription: $('.text-sm.font-serif').text().trim() || '',\r\n\t\t\t\tposts: $('.stat').eq(0).find('.stat-value').text().trim() || 0,\r\n\t\t\t\tfollowers: $('.stat').eq(1).find('.stat-value').text().trim() || 0,\r\n\t\t\t\tfollowing: $('.stat').eq(2).find('.stat-value').text().trim() || 0,\r\n\t\t\t\tlist_post\r\n\t\t\t})\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function telegramStalk(username) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.get('https://t.me/' + username, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'x-return-format': 'html'\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst $ = cheerio.load(data);\r\n\t\t\tresolve({\r\n\t\t\t\turl: 'https://t.me/' + username,\r\n\t\t\t\ttitle: $('meta[property=\"og:title\"]').attr('content'),\r\n\t\t\t\tdescription: $('meta[property=\"og:description\"]').attr('content'),\r\n\t\t\t\timage_url: $('meta[property=\"og:image\"]').attr('content')\r\n\t\t\t})\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function tiktokStalk(username) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst headers = { 'referer': 'https://countik.com/user/@' + username, 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36' }\r\n\t\t\tconst { data } = await axios.get('https://www.tiktok.com/oembed?url=https://www.tiktok.com/@' + username);\r\n\t\t\tconst { data: res } = await axios.get('https://countik.com/api/exist/' + username, { headers });\r\n\t\t\tconst { data: wet } = await axios.get('https://countik.com/api/userinfo?sec_user_id=' + res.sec_uid, { headers });\r\n\t\t\tresolve({\r\n\t\t\t\t...res,\r\n\t\t\t\t...wet,\r\n\t\t\t\tnickname: data.author_name\r\n\t\t\t})\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function genshinStalk(id) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst headers = {\r\n\t\t\t\t'content-type': 'application/json; charset=UTF-8',\r\n\t\t\t\t'origin': 'https://enka.network',\r\n\t\t\t\t'referer': 'https://enka.network/',\r\n\t\t\t\t'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.5993.89 Safari/537.36',\r\n\t\t\t}\r\n\t\t\tconst { data } = await axios.get('https://enka.network/api/uid/' + id, { headers });\r\n\t\t\tconst p = data.playerInfo;\r\n\t\t\tresolve({\r\n\t\t\t\tuid: data.uid,\r\n\t\t\t\tttl: data.ttl,\r\n\t\t\t\tnickname: p.nickname,\r\n\t\t\t\tlevel: p.level,\r\n\t\t\t\tcard_id: p.nameCardId,\r\n\t\t\t\tsignature: p.signature,\r\n\t\t\t\tworld_level: p.worldLevel,\r\n\t\t\t\tachivement: p.finishAchievementNum,\r\n\t\t\t\tspiral_abyss: p.towerFloorIndex + ' - ' + p.towerLevelIndex,\r\n\t\t\t\timage: 'https://mini.s-shot.ru/990x810/PNG/975/Z100/?https://enka.network/u/' + data.uid\r\n\t\t\t})\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function instaStory(name) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst results = [];\r\n\t\t\tconst formData = new FormData();\r\n\t\t\tconst key = await axios.get('https://storydownloader.app/en');\r\n\t\t\tconst $$ = cheerio.load(key.data);\r\n\t\t\tconst cookie = key.headers['set-cookie']\r\n\t\t\tconst token = $$('input[name=\"_token\"]').attr('value');\r\n\t\t\tconst headers = {\r\n\t\t\t\taccept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\r\n\t\t\t\tcookie: cookie,\r\n\t\t\t\torigin: 'https://storydownloader.app',\r\n\t\t\t\treferer: 'https://storydownloader.app/en',\r\n\t\t\t\t'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36',\r\n\t\t\t\t'X-CSRF-TOKEN': token\r\n\t\t\t};\r\n\t\t\tformData.append('username', name);\r\n\t\t\tformData.append('_token', token);\r\n\t\t\tconst res = await axios.post('https://storydownloader.app/request', formData, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t...headers,\r\n\t\t\t\t\t...formData.getHeaders()\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst $ = cheerio.load(res.data.html);\r\n\t\t\tconst username = $('h3.card-title').text();\r\n\t\t\tconst profile_url = $('img.card-avatar').attr('src');\r\n\t\t\t$('div.row > div').each(function () {\r\n\t\t\t\tconst _ = $(this);\r\n\t\t\t\tconst url = _.find('a').attr('href');\r\n\t\t\t\tconst thumbnail = _.find('img').attr('src');\r\n\t\t\t\tconst type = /video_dashinit\\.mp4/i.test(url) ? 'video' : 'image';\r\n\t\t\t\tif (thumbnail && url) {\r\n\t\t\t\t\tresults.push({\r\n\t\t\t\t\t\tthumbnail,\r\n\t\t\t\t\t\turl,\r\n\t\t\t\t\t\ttype,\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst data = {\r\n\t\t\t\tusername,\r\n\t\t\t\tprofile_url,\r\n\t\t\t\tresults\r\n\t\t\t};\r\n\t\t\tresolve(data)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function bk9Ai(query) {\r\n\tconst teks = encodeURIComponent(query);\r\n\tconst urls = ['https://bk9.fun/ai/gemini?q=','https://bk9.fun/ai/jeeves-chat?q=','https://bk9.fun/ai/jeeves-chat2?q=','https://bk9.fun/ai/mendable?q=','https://bk9.fun/ai/Aoyo?q='];\r\n\tfor (let url of urls) {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.get(url + teks);\r\n\t\t\treturn data\r\n\t\t} catch (e) {\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function spotifyDl(url) {\r\n\treturn new Promise(async(resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.get('https://api.fabdl.com/spotify/get?url=' + url, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'content-type': 'application/json'\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst { data: res } = await axios.get(`https://api.fabdl.com/spotify/mp3-convert-task/${data.result.gid}/${data.result.id}`);\r\n\t\t\tresolve({\r\n\t\t\t\ttitle: data.result.name,\r\n\t\t\t\tduration: data.result.duration_ms,\r\n\t\t\t\tcover: data.result.image,\r\n\t\t\t\tdownload: \"https://api.fabdl.com\" + res.result.download_url,\r\n\t\t\t})\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function ytMp4(url, options) {\r\n    return new Promise(async(resolve, reject) => {\r\n        ytdl.getInfo(url, options).then(async(getUrl) => {\r\n            const audioPath = path.join('./database/sampah', `audio_${Date.now()}.mp4`);\r\n            const videoPath = path.join('./database/sampah', `video_${Date.now()}.mp4`);\r\n            const outputPath = path.join('./database/sampah', `output_${Date.now()}.mp4`);\r\n            await new Promise((resolv, rejectt) => {\r\n            \tytdl(url, { format: ytdl.chooseFormat(getUrl.formats, { quality: 'highestaudio', filter: 'audioonly' })}).pipe(fs.createWriteStream(audioPath)).on('finish', resolv).on('error', rejectt);\r\n            })\r\n            await new Promise((resolv, rejectt) => {\r\n            \tytdl(url, { format: ytdl.chooseFormat(getUrl.formats, { quality: 'highestvideo', filter: 'videoonly' })}).pipe(fs.createWriteStream(videoPath)).on('finish', resolv).on('error', rejectt);\r\n            })\r\n            await new Promise((resolv, rejectt) => {\r\n\t\t        exec(`ffmpeg -i ${videoPath} -i ${audioPath} -c:v copy -c:a aac ${outputPath}`, (error, stdout, stderr) => {\r\n\t\t            if (error) {\r\n\t\t                rejectt(new Error(`ffmpeg error: ${error.message}`));\r\n\t\t                return;\r\n\t\t            }\r\n\t\t            resolv();\r\n\t\t        });\r\n\t\t    });\r\n            let title = getUrl.videoDetails.title;\r\n            let desc = getUrl.videoDetails.description;\r\n            let views = getUrl.videoDetails.viewCount;\r\n            let likes = getUrl.videoDetails.likes;\r\n            let dislike = getUrl.videoDetails.dislikes;\r\n            let channel = getUrl.videoDetails.ownerChannelName;\r\n            let uploadDate = getUrl.videoDetails.uploadDate;\r\n            let thumb = getUrl.player_response.microformat.playerMicroformatRenderer.thumbnail.thumbnails[0].url;\r\n            let result = fs.readFileSync(outputPath);\r\n            await fs.promises.unlink(audioPath);\r\n            await fs.promises.unlink(videoPath);\r\n            await fs.promises.unlink(outputPath);\r\n            resolve({\r\n                title,\r\n                result,\r\n                thumb,\r\n                views,\r\n                likes,\r\n                dislike,\r\n                channel,\r\n                uploadDate,\r\n                desc\r\n            });\r\n        }).catch(reject);\r\n    });\r\n};\r\n\r\nasync function ytMp3(url, options) {\r\n    return new Promise((resolve, reject) => {\r\n        ytdl.getInfo(url, options).then(async(getUrl) => {\r\n            let result = [];\r\n            for(let i = 0; i < getUrl.formats.length; i++) {\r\n                let item = getUrl.formats[i];\r\n                if (item.mimeType == 'audio/webm; codecs=\\\"opus\\\"') {\r\n                    let { contentLength } = item;\r\n                    let bytes = await bytesToSize(contentLength);\r\n                    result[i] = {\r\n                        audio: item.url,\r\n                        size: bytes\r\n                    };\r\n                };\r\n            };\r\n            let resultFix = result.filter(x => x.audio != undefined && x.size != undefined)\r\n            let title = getUrl.videoDetails.title;\r\n            let desc = getUrl.videoDetails.description;\r\n            let views = getUrl.videoDetails.viewCount;\r\n            let likes = getUrl.videoDetails.likes;\r\n            let dislike = getUrl.videoDetails.dislikes;\r\n            let channel = getUrl.videoDetails.ownerChannelName;\r\n            let uploadDate = getUrl.videoDetails.uploadDate;\r\n            let thumb = getUrl.player_response.microformat.playerMicroformatRenderer.thumbnail.thumbnails[0].url;\r\n            resolve({\r\n                title,\r\n                result: resultFix[0].audio,\r\n                size: resultFix[0].size,\r\n                thumb,\r\n                views,\r\n                likes,\r\n                dislike,\r\n                channel,\r\n                uploadDate,\r\n                desc\r\n            });\r\n        }).catch(reject);\r\n    });\r\n}\r\n\r\nclass NvlGroup {\r\n\tconstructor() {\r\n\t\tthis.signature = null;\r\n\t\tthis.timestamp = null;\r\n\t}\r\n\t\r\n\tasync updateSignature() {\r\n\t\tconst res = await axios.get('https://ytdownloader.nvlgroup.my.id/generate-signature');\r\n\t\tthis.signature = res.data.signature;\r\n\t\tthis.timestamp = res.data.timestamp;\r\n\t}\r\n\tasync ensureSignature() {\r\n\t\tif (!this.signature || !this.timestamp || Date.now() - this.timestamp > 4 * 60 * 1000) {\r\n\t\t\tawait this.updateSignature();\r\n\t\t}\r\n\t}\r\n\t\r\n\tasync search(query) {\r\n\t\tawait this.ensureSignature();\r\n\t\tconst { data } = await axios.get(`https://ytdownloader.nvlgroup.my.id/web/search?q=${encodeURIComponent(query)}`, {\r\n\t\t\theaders: {\r\n\t\t\t\t'x-server-signature': this.signature,\r\n\t\t\t\t'x-signature-timestamp': this.timestamp\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn data;\r\n\t}\r\n\t\r\n\tasync info(url) {\r\n\t\tawait this.ensureSignature();\r\n\t\tconst { data } = await axios.get(`https://ytdownloader.nvlgroup.my.id/web/info?url=${encodeURIComponent(url)}`, {\r\n\t\t\theaders: {\r\n\t\t\t\t'x-server-signature': this.signature,\r\n\t\t\t\t'x-signature-timestamp': this.timestamp\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn data;\r\n\t}\r\n\t\r\n\tasync download(url) {\r\n\t\tawait this.ensureSignature();\r\n\t\tconst info = await this.info(url);\r\n\t\tconst video = info.resolutions.map(res => ({\r\n\t\t\t...res,\r\n\t\t\turl: `https://ytdownloader.nvlgroup.my.id/web/download?url=${url}&resolution=${res.height}&signature=${this.signature}&timestamp=${this.timestamp}`\r\n\t\t}));\r\n\t\tconst audio = info.audioBitrates.map(res => ({\r\n\t\t\t...res,\r\n\t\t\turl: `https://ytdownloader.nvlgroup.my.id/web/audio?url=${url}&bitrate=${res.bitrate}&signature=${this.signature}&timestamp=${this.timestamp}`\r\n\t\t}));\r\n\t\treturn { video, audio };\r\n\t}\r\n}\r\n\r\nasync function quotedLyo(teks, name, profile, replynya, color = '#FFFFFF') {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\tconst { url, options, reply } = replynya || {}\r\n\t\tconst payload = {\r\n\t\t\ttype: 'quote',\r\n\t\t\tformat: 'png',\r\n\t\t\tbackgroundColor: color,\r\n\t\t\twidth: 512,\r\n\t\t\theight: 768,\r\n\t\t\tscale: 2,\r\n\t\t\tmessages: [{\r\n\t\t\t\tentities: [],\r\n\t\t\t\t...(url ? { media: { url }} : {}),\r\n\t\t\t\tavatar: true,\r\n\t\t\t\tfrom: {\r\n\t\t\t\t\tid: 1,\r\n\t\t\t\t\tname,\r\n\t\t\t\t\tphoto: {\r\n\t\t\t\t\t\turl: profile\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t...(options ? options : {}),\r\n\t\t\t\ttext: teks,\r\n\t\t\t\treplyMessage: reply ? {\r\n\t\t\t\t\tname: reply.name || '',\r\n\t\t\t\t\ttext: reply.text || '',\r\n\t\t\t\t\tchatId: Math.floor(Math.random() * 9999999)\r\n\t\t\t\t} : {},\r\n\t\t\t}]\r\n\t\t};\r\n\t\ttry {\r\n\t\t\tconst urls = ['https://quotly.netorare.codes/generate', 'https://btzqc.betabotz.eu.org/generate', 'https://qc.botcahx.eu.org/generate', 'https://bot.lyo.su/quote/generate'];\r\n\t\t\tfor (let url of urls) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconst { data } = await axios.post(url, JSON.stringify(payload, null, 2), {\r\n\t\t\t\t\t\theaders: {\r\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tresolve(data)\r\n\t\t\t\t} catch (e) {}\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t});\r\n}\r\n\r\nasync function yanzGpt(messages = [], model = 'yanzgpt-revolution-25b-v3.0') {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry { // Ai by Yanz-Gpt > https://whatsapp.com/channel/0029Vai7FxK5Ui2TkgHi1P0I\r\n\t\t\tconst models = {\r\n\t\t\t\tdefault: 'yanzgpt-revolution-25b-v3.5',\r\n\t\t\t\tpro: 'yanzgpt-legacy-72b-v3.5',\r\n\t\t\t\treasoning: 'yanzgpt-r1-70b-v3.5'\r\n\t\t\t};\r\n\t\t\tconst { data } = await axios.post('https://api.yanzgpt.my.id/v1/chat', {\r\n\t\t\t\tmessages,\r\n\t\t\t\tmodel: model || models.default\r\n\t\t\t}, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\tauthorization: 'Bearer yzgpt-sc4tlKsMRdNMecNy',\r\n\t\t\t\t\t'content-type': 'application/json'\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tresolve(data)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function youSearch(query) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst res = await yousearch.post('/api', {\r\n\t\t\t\tsearchTerm: query,\r\n\t\t\t\tpromptTemplate: `Search term: '{searchTerm}'`,\r\n\t\t\t\tsearchParameters: '{}',\r\n\t\t\t\tsearchResultTemplate: `[{order}] '{snippet}'\\nURL: {link}`,\r\n\t\t\t});\r\n\t\t\tresolve(res.data.response)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function gptLogic(messages = [], prompt) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst { data } = await axios.post('https://chateverywhere.app/api/chat', {\r\n\t\t\t\tmodel: {\r\n\t\t\t\t\tid: 'gpt-3.5-turbo-0613',\r\n\t\t\t\t\tname: 'GPT-3.5',\r\n\t\t\t\t\tmaxLength: 12000,\r\n\t\t\t\t\ttokenLimit: 4000,\r\n\t\t\t\t},\r\n\t\t\t\tprompt, messages\r\n\t\t\t}, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'content-type': 'application/json',\r\n\t\t\t\t\t'cookie': '_ga=GA1.1.34196701.1707462626; _ga_ZYMW9SZKVK=GS1.1.1707462625.1.0.1707462625.60.0.0; ph_phc_9n85Ky3ZOEwVZlg68f8bI3jnOJkaV8oVGGJcoKfXyn1_posthog=%7B%22distinct_id%22%3A%225aa4878d-a9b6-40fb-8345-3d686d655483%22%2C%22%24sesid%22%3A%5B1707462733662%2C%22018d8cb4-0217-79f9-99ac-b77f18f82ac8%22%2C1707462623766%5D%7D',\r\n\t\t\t\t\t'origin': 'https://chateverywhere.app',\r\n\t\t\t\t\t'referer': 'https://chateverywhere.app/id',\r\n\t\t\t\t\t'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36',\r\n\t\t\t\t\t'x-forwarded-for': Array(4).fill().map(() => Math.floor(Math.random() * 256)).join('.'),\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tresolve(data)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nconst savetube = {\r\n  api: {\r\n    base: \"https://media.savetube.me/api\",\r\n    cdn: \"/random-cdn\",\r\n    info: \"/v2/info\", \r\n    download: \"/download\"\r\n  },\r\n  headers: {\r\n    'accept': '*/*',\r\n    'content-type': 'application/json',\r\n    'origin': 'https://yt.savetube.me',\r\n    'referer': 'https://yt.savetube.me/',\r\n    'user-agent': 'Postify/1.0.0'\r\n  },\r\n  formatVideo: ['144', '240', '360', '480', '720', '1080', '1440', '2k', '3k', '4k', '5k', '8k'],\r\n  formatAudio: ['mp3', 'm4a', 'webm', 'aac', 'flac', 'opus', 'ogg', 'wav' ],\r\n\r\n  crypto: {\r\n    hexToBuffer: (hexString) => {\r\n      const matches = hexString.match(/.{1,2}/g);\r\n      return Buffer.from(matches.join(''), 'hex');\r\n    },\r\n\r\n    decrypt: async (enc) => {\r\n      try {\r\n        const secretKey = 'C5D58EF67A7584E4A29F6C35BBC4EB12';\r\n        const data = Buffer.from(enc, 'base64');\r\n        const iv = data.slice(0, 16);\r\n        const content = data.slice(16);\r\n        const key = savetube.crypto.hexToBuffer(secretKey);\r\n        \r\n        const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);\r\n        let decrypted = decipher.update(content);\r\n        decrypted = Buffer.concat([decrypted, decipher.final()]);\r\n        \r\n        return JSON.parse(decrypted.toString());\r\n      } catch (error) {\r\n        throw new Error(`${error.message}`);\r\n      }\r\n    }\r\n  },\r\n\r\n  isUrl: str => { \r\n    try { \r\n      new URL(str); \r\n      return true; \r\n    } catch (_) { \r\n      return false; \r\n    } \r\n  },\r\n\r\n  youtube: url => {\r\n    if (!url) return null;\r\n    const a = [\r\n      /youtube\\.com\\/watch\\?v=([a-zA-Z0-9_-]{11})/,\r\n      /youtube\\.com\\/embed\\/([a-zA-Z0-9_-]{11})/,\r\n      /youtube\\.com\\/v\\/([a-zA-Z0-9_-]{11})/,\r\n      /youtube\\.com\\/shorts\\/([a-zA-Z0-9_-]{11})/,\r\n      /youtu\\.be\\/([a-zA-Z0-9_-]{11})/\r\n    ];\r\n    for (let b of a) {\r\n      if (b.test(url)) return url.match(b)[1];\r\n    }\r\n    return null;\r\n  },\r\n\r\n  request: async (endpoint, data = {}, method = 'post') => {\r\n    try {\r\n      const { data: response } = await axios({\r\n        method,\r\n        url: `${endpoint.startsWith('http') ? '' : savetube.api.base}${endpoint}`,\r\n        data: method === 'post' ? data : undefined,\r\n        params: method === 'get' ? data : undefined,\r\n        headers: savetube.headers\r\n      });\r\n      return {\r\n        status: true,\r\n        code: 200,\r\n        data: response\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        status: false,\r\n        code: error.response?.status || 500,\r\n        error: error.message\r\n      };\r\n    }\r\n  },\r\n\r\n  getCDN: async () => {\r\n    const response = await savetube.request(savetube.api.cdn, {}, 'get');\r\n    if (!response.status) return response;\r\n    return {\r\n      status: true,\r\n      code: 200,\r\n      data: response.data.cdn\r\n    };\r\n  },\r\n\r\n  download: async (link, format) => {\r\n    if (!link) {\r\n      return {\r\n        status: false,\r\n        code: 400,\r\n        error: \"Infokan linknya cik\"\r\n      };\r\n    }\r\n\r\n    if (!savetube.isUrl(link)) {\r\n      return {\r\n        status: false,\r\n        code: 400,\r\n        error: \"Itu bukan link youtube kocak\"\r\n      };\r\n    }\r\n\r\n    const allFormats = [...savetube.formatVideo, ...savetube.formatAudio];\r\n    if (!format || !allFormats.includes(format)) {\r\n      return {\r\n        status: false,\r\n        code: 400,\r\n        error: \"Itu bukan formats yang ada cik, liat dibawah ini\",\r\n        available_fmt: allFormats\r\n      };\r\n    }\r\n\r\n    const id = savetube.youtube(link);\r\n    if (!id) {\r\n      return {\r\n        status: false,\r\n        code: 400,\r\n        error: \"Yaelah link youtubenya ada yang salah cik\"\r\n      };\r\n    }\r\n\r\n    try {\r\n      const cdnx = await savetube.getCDN();\r\n      if (!cdnx.status) return cdnx;\r\n      const cdn = cdnx.data;\r\n\r\n      const result = await savetube.request(`https://${cdn}${savetube.api.info}`, {\r\n        url: `https://www.youtube.com/watch?v=${id}`\r\n      });\r\n      if (!result.status) return result;\r\n      const decrypted = await savetube.crypto.decrypt(result.data.data);\r\n\r\n      const dl = await savetube.request(`https://${cdn}${savetube.api.download}`, {\r\n        id: id,\r\n        downloadType: savetube.formatAudio.includes(format) ? 'audio' : 'video',\r\n        quality: savetube.formatAudio.includes(format) ? '128' : format,\r\n        key: decrypted.key\r\n      });\r\n\r\n      return {\r\n        status: true,\r\n        code: 200,\r\n        result: {\r\n          title: decrypted.title || \"Gak tau ü§∑üèª\",\r\n          type: savetube.formatAudio.includes(format) ? 'audio' : 'video',\r\n          format: format,\r\n          thumbnail: decrypted.thumbnail || `https://i.ytimg.com/vi/${id}/maxresdefault.jpg`,\r\n          download: dl.data.data.downloadUrl,\r\n          id: id,\r\n          key: decrypted.key,\r\n          duration: decrypted.duration,\r\n          quality: savetube.formatAudio.includes(format) ? '128' : format,\r\n          downloaded: dl.data.data.downloaded || false\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        status: false,\r\n        code: 500,\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n};\r\n\r\nasync function simi(query) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tconst isi = new URLSearchParams();\r\n\t\t\tisi.append('text', query);\r\n\t\t\tisi.append('lc', 'id');\r\n\t\t\tisi.append('=', '');\r\n\t\t\tconst { data } = await axios.post('https://simsimi.vn/web/simtalk', isi, {\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t'Accept': 'application/json, text/javascript, */*; q=0.01',\r\n\t\t\t\t\t'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\r\n\t\t\t\t\t'X-Requested-With': 'XMLHttpRequest'\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tresolve(data)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nasync function geminiAi(query, apikey, options = {}) {\r\n\treturn new Promise(async (resolve, reject) => {\r\n\t\ttry {\r\n\t\t\tif (!apikey) reject({ status: 401, error: 'Unauthorized' });\r\n\t\t\tconst gemini = new GoogleGenerativeAI(apikey);\r\n\t\t\tconst model = gemini.getGenerativeModel({\r\n\t\t\t\t...(options.prompt ? { systemInstruction: options.prompt } : {}),\r\n\t\t\t\tmodel: 'gemini-2.0-flash-exp-image-generation',\r\n\t\t\t\tgenerationConfig: {\r\n\t\t\t\t\tresponseModalities: ['Text', 'Image']\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconst { response } = await model.generateContent([{ text: query }, ...(options.media ? [{\r\n\t\t\t\tinlineData: {\r\n\t\t\t\t\tmimeType: options.mime,\r\n\t\t\t\t\tdata: Buffer.from(options.media).toString('base64')\r\n\t\t\t\t}\r\n\t\t\t}] : [])]);\r\n\t\t\tconst hasil = {}\r\n\t\t\thasil.token = response.usageMetadata;\r\n\t\t\tif (response?.promptFeedback?.blockReason === 'OTHER' || response?.candidates?.[0]?.finishReason === 'IMAGE_SAFETY') resolve(hasil)\r\n\t\t\tfor (const part of response.candidates[0].content.parts) {\r\n\t\t\t\tif (part.text) {\r\n\t\t\t\t\thasil.text = part.text;\r\n\t\t\t\t}\r\n\t\t\t\tif (part.inlineData) {\r\n\t\t\t\t\thasil.media = Buffer.from(part.inlineData.data, 'base64');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresolve(hasil)\r\n\t\t} catch (e) {\r\n\t\t\treject(e)\r\n\t\t}\r\n\t})\r\n}\r\n\r\nmodule.exports = { pinterest, wallpaper, remini, hitamkan, wikimedia, yanzGpt, mediafireDl, ringtone, styletext, instagramDl, tiktokDl, facebookDl, instaStalk, telegramStalk, tiktokStalk, genshinStalk, instaStory, bk9Ai, spotifyDl, ytMp4, ytMp3, NvlGroup, quotedLyo, youSearch, gptLogic, savetube, simi, geminiAi }\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});","path":null,"size_bytes":35349,"size_tokens":null},"ciel/src/index.js":{"content":"require('dotenv').config();\n\nconst os = require('os');\nconst fs = require('fs-extra');\nconst path = require('path');\nconst pino = require('pino');\nconst readline = require('readline');\nconst NodeCache = require('node-cache');\nconst { Boom } = require('@hapi/boom');\nconst qrcode = require('qrcode-terminal');\nconst { parsePhoneNumber } = require('awesome-phonenumber');\n\nconst {\n    default: makeWASocket,\n    useMultiFileAuthState,\n    Browsers,\n    DisconnectReason,\n    makeCacheableSignalKeyStore,\n    fetchLatestBaileysVersion,\n    jidNormalizedUser\n} = require('@whiskeysockets/baileys');\n\nconst settings = require('../config/settings');\nconst { logger } = require('./utils/logger');\nconst { runtime, getGreeting, getTime } = require('./utils/functions');\nconst { connectDatabase, getOrCreateBotSettings, checkExpiredSewa, cleanupExpiredData, resetDailyLimits } = require('./services/database');\nconst { Serialize, setupExtensions } = require('./handlers/serialize');\nconst { handleMessage } = require('./handlers/messageHandler');\nconst { handleGroupParticipantsUpdate, handleGroupUpdate } = require('./handlers/groupHandler');\nconst { startServer } = require('./server');\n\nconst msgRetryCounterCache = new NodeCache();\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout });\nconst question = (text) => new Promise((resolve) => rl.question(text, resolve));\n\nlet pairingStarted = false;\n\nconst printSystemInfo = () => {\n    logger.banner();\n    logger.systemInfo({\n        os: `${os.platform()} ${os.release()} ${os.arch()}`,\n        platform: os.type(),\n        nodeVersion: process.version,\n        memory: `${(os.freemem() / 1024 / 1024).toFixed(0)} MB / ${(os.totalmem() / 1024 / 1024).toFixed(0)} MB`,\n        cpu: os.cpus()[0]?.model?.trim() || 'Unknown',\n        date: getTime('dddd, DD MMMM YYYY HH:mm:ss')\n    });\n};\n\nasync function startCielBot() {\n    printSystemInfo();\n    \n    const dbConnected = await connectDatabase();\n    if (!dbConnected) {\n        logger.error('Gagal terhubung ke database. Bot tidak dapat dijalankan.');\n        process.exit(1);\n    }\n    \n    startServer(null);\n    \n    const sessionFolder = path.join(process.cwd(), 'sessions', settings.session.folderName);\n    await fs.ensureDir(sessionFolder);\n    \n    const { state, saveCreds } = await useMultiFileAuthState(sessionFolder);\n    const { version, isLatest } = await fetchLatestBaileysVersion();\n    \n    logger.info(`Menggunakan Baileys versi ${version.join('.')} (Latest: ${isLatest})`);\n    \n    const pinoLogger = pino({ level: 'silent' });\n    \n    const getMessage = async (key) => {\n        return { conversation: 'Halo, saya Ciel Bot!' };\n    };\n    \n    const conn = makeWASocket({\n        version,\n        logger: pinoLogger,\n        getMessage,\n        syncFullHistory: true,\n        maxMsgRetryCount: 15,\n        msgRetryCounterCache,\n        retryRequestDelayMs: 10,\n        defaultQueryTimeoutMs: 0,\n        connectTimeoutMs: 60000,\n        browser: Browsers.ubuntu('Chrome'),\n        generateHighQualityLinkPreview: true,\n        shouldSyncHistoryMessage: (msg) => {\n            logger.info(`Memuat Chat [${msg.progress || 0}%]`);\n            return !!msg.syncType;\n        },\n        transactionOpts: {\n            maxCommitRetries: 10,\n            delayBetweenTriesMs: 10\n        },\n        auth: {\n            creds: state.creds,\n            keys: makeCacheableSignalKeyStore(state.keys, pinoLogger)\n        }\n    });\n    \n    global.store = {\n        contacts: {},\n        presences: {},\n        messages: {},\n        groupMetadata: {}\n    };\n    \n    if (settings.pairing.enabled && !conn.authState.creds.registered) {\n        let phoneNumber = settings.pairing.phoneNumber || process.env.BOT_NUMBER;\n        \n        if (!phoneNumber) {\n            phoneNumber = await question('Masukkan nomor WhatsApp Bot (contoh: 62812xxx): ');\n        }\n        \n        phoneNumber = phoneNumber.replace(/[^0-9]/g, '');\n        \n        const parsedNumber = parsePhoneNumber('+' + phoneNumber);\n        if (!parsedNumber.valid || phoneNumber.length < 10) {\n            logger.error('Nomor tidak valid! Mulai dengan kode negara (contoh: 62xxx)');\n            process.exit(1);\n        }\n        \n        logger.info('Nomor berhasil diverifikasi. Menunggu koneksi...');\n        \n        setTimeout(async () => {\n            if (!pairingStarted && !conn.authState.creds.registered) {\n                pairingStarted = true;\n                logger.info('Meminta Pairing Code...');\n                try {\n                    const code = await conn.requestPairingCode(phoneNumber);\n                    logger.success(`Pairing Code: ${code}`);\n                    logger.info('Masukkan kode ini di WhatsApp > Linked Devices > Link with phone number');\n                } catch (e) {\n                    logger.error(`Gagal mendapatkan Pairing Code: ${e.message}`);\n                }\n            }\n        }, 3000);\n    }\n    \n    setupExtensions(conn, global.store);\n    \n    startServer(conn);\n    \n    conn.ev.on('creds.update', saveCreds);\n    \n    conn.ev.on('connection.update', async (update) => {\n        const { qr, connection, lastDisconnect, isNewLogin, receivedPendingNotifications } = update;\n        \n        if (!conn.authState.creds.registered) {\n            logger.info(`Connection: ${connection || 'waiting'}`);\n        }\n        \n        if (qr && !settings.pairing.enabled) {\n            qrcode.generate(qr, { small: true });\n            logger.info('Scan QR Code diatas dengan WhatsApp');\n        }\n        \n        if (connection === 'close') {\n            const reason = new Boom(lastDisconnect?.error)?.output?.statusCode;\n            \n            const reconnectReasons = [\n                DisconnectReason.connectionLost,\n                DisconnectReason.connectionClosed,\n                DisconnectReason.restartRequired,\n                DisconnectReason.timedOut,\n                DisconnectReason.badSession\n            ];\n            \n            if (reconnectReasons.includes(reason)) {\n                logger.warn(`Koneksi terputus (${DisconnectReason[reason] || reason}). Menghubungkan ulang...`);\n                startCielBot();\n            } else if (reason === DisconnectReason.loggedOut || reason === DisconnectReason.forbidden) {\n                if (!conn.authState.creds.registered && pairingStarted) {\n                    logger.warn('Menunggu pairing code dimasukkan. Menghubungkan ulang dalam 5 detik...');\n                    setTimeout(() => startCielBot(), 5000);\n                } else {\n                    logger.error('Session tidak valid. Hapus folder session dan scan ulang.');\n                    await fs.remove(sessionFolder);\n                    process.exit(1);\n                }\n            } else if (reason === DisconnectReason.connectionReplaced) {\n                logger.error('Koneksi digantikan oleh session lain.');\n                process.exit(0);\n            } else {\n                logger.warn(`Disconnect (${reason}). Menghubungkan ulang...`);\n                startCielBot();\n            }\n        }\n        \n        if (connection === 'open') {\n            const botJid = jidNormalizedUser(conn.user.id);\n            logger.success(`Terhubung sebagai: ${conn.user.name || botJid}`);\n            \n            await getOrCreateBotSettings(botJid);\n            \n            conn.public = settings.features.public;\n            \n            if (!global.store.groupMetadata || Object.keys(global.store.groupMetadata).length === 0) {\n                try {\n                    global.store.groupMetadata = await conn.groupFetchAllParticipating();\n                    logger.info(`Loaded ${Object.keys(global.store.groupMetadata).length} groups`);\n                } catch (e) {\n                    logger.warn('Gagal memuat group metadata');\n                }\n            }\n        }\n        \n        if (isNewLogin) {\n            logger.success('Login baru terdeteksi!');\n        }\n        \n        if (receivedPendingNotifications === 'true') {\n            logger.info('Memproses notifikasi pending...');\n        }\n    });\n    \n    conn.ev.on('messages.upsert', async (message) => {\n        try {\n            await handleMessage(conn, message, global.store);\n        } catch (e) {\n            logger.error(`Error handling message: ${e.message}`);\n        }\n    });\n    \n    conn.ev.on('group-participants.update', async (update) => {\n        try {\n            await handleGroupParticipantsUpdate(conn, update, global.store);\n        } catch (e) {\n            logger.error(`Error handling group update: ${e.message}`);\n        }\n    });\n    \n    conn.ev.on('groups.update', (updates) => {\n        try {\n            handleGroupUpdate(updates, global.store);\n        } catch (e) {\n            logger.error(`Error handling group metadata update: ${e.message}`);\n        }\n    });\n    \n    conn.ev.on('contacts.update', (updates) => {\n        for (const contact of updates) {\n            if (!contact.id) continue;\n            const jid = jidNormalizedUser(contact.id);\n            global.store.contacts[jid] = {\n                ...global.store.contacts[jid],\n                id: jid,\n                name: contact.notify\n            };\n        }\n    });\n    \n    conn.ev.on('presence.update', ({ id, presences }) => {\n        global.store.presences[id] = global.store.presences[id] || {};\n        Object.assign(global.store.presences[id], presences);\n    });\n    \n    conn.ev.on('call', async (calls) => {\n        const botSettings = await getOrCreateBotSettings(jidNormalizedUser(conn.user.id));\n        if (botSettings?.antiCall) {\n            for (const call of calls) {\n                if (call.status === 'offer') {\n                    const callType = call.isVideo ? 'Video' : 'Voice';\n                    await conn.rejectCall(call.id, call.from);\n                    await conn.sendMessage(call.from, {\n                        text: `*Anti-Call Aktif*\\n\\nMaaf, bot tidak dapat menerima panggilan ${callType}.`\n                    });\n                    logger.info(`Rejected ${callType} call from ${call.from}`);\n                }\n            }\n        }\n    });\n    \n    const cron = require('node-cron');\n    \n    cron.schedule('0 0 * * *', async () => {\n        logger.info('Running daily reset...');\n        await resetDailyLimits();\n    }, { timezone: settings.timezone });\n    \n    cron.schedule('*/5 * * * *', async () => {\n        await checkExpiredSewa(conn);\n    });\n    \n    cron.schedule('0 * * * *', async () => {\n        await cleanupExpiredData();\n    });\n    \n    setInterval(async () => {\n        if (conn?.user?.id) {\n            await conn.sendPresenceUpdate('available', jidNormalizedUser(conn.user.id)).catch(() => {});\n        }\n    }, 10 * 60 * 1000);\n    \n    return conn;\n}\n\nstartCielBot().catch((err) => {\n    logger.error(`Startup error: ${err.message}`);\n    process.exit(1);\n});\n\nconst cleanup = async (signal) => {\n    logger.info(`Received ${signal}. Menyimpan data...`);\n    const { disconnectDatabase } = require('./services/database');\n    await disconnectDatabase();\n    process.exit(0);\n};\n\nprocess.on('SIGINT', () => cleanup('SIGINT'));\nprocess.on('SIGTERM', () => cleanup('SIGTERM'));\nprocess.on('uncaughtException', (err) => {\n    logger.error(`Uncaught Exception: ${err.message}`);\n    console.error(err);\n});\nprocess.on('unhandledRejection', (err) => {\n    logger.error(`Unhandled Rejection: ${err.message}`);\n    console.error(err);\n});\n","path":null,"size_bytes":11474,"size_tokens":null},"source-2/lib/handlers/connectionHandler.js":{"content":"const { DisconnectReason } = require('@naruyaizumi/baileys');\nconst { logger } = require('../utils/logger');\n\nfunction handleConnectionUpdate(conn, update) {\n    const { connection, lastDisconnect } = update;\n    \n    if (connection === 'open') {\n        logger.success(`‚úÖ Bot connected successfully!`);\n        logger.info(`üëÇ Listening for messages...\\n`);\n    }\n    \n    if (connection === 'close') {\n        const statusCode = lastDisconnect?.error?.output?.statusCode || \n                          lastDisconnect?.error?.output?.payload?.statusCode;\n        \n        logger.error(`Connection closed: ${DisconnectReason[statusCode] || statusCode || 'unknown'}`);\n        \n        if (statusCode === DisconnectReason.badSession) {\n            logger.error('[!] Invalid session - please delete auth folder and restart');\n        } else {\n            logger.info('[!] Attempting to reconnect...');\n            setTimeout(() => {\n                require('../../index').startBot();\n            }, 5000);\n        }\n    }\n}\n\nmodule.exports = {\n    handleConnectionUpdate\n};","path":null,"size_bytes":1074,"size_tokens":null},"ciel/src/utils/logger.js":{"content":"const chalk = require('chalk');\nconst moment = require('moment-timezone');\n\nconst getTimestamp = () => {\n    return moment.tz('Asia/Jakarta').format('HH:mm:ss');\n};\n\nconst logger = {\n    info: (message) => {\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.blue('[INFO]')} ${message}`);\n    },\n    \n    success: (message) => {\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.green('[SUCCESS]')} ${message}`);\n    },\n    \n    warn: (message) => {\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.yellow('[WARN]')} ${message}`);\n    },\n    \n    error: (message) => {\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.red('[ERROR]')} ${message}`);\n    },\n    \n    incoming: (message) => {\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.cyan('[INCOMING]')} ${message}`);\n    },\n    \n    outgoing: (message) => {\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.magenta('[OUTGOING]')} ${message}`);\n    },\n    \n    command: (cmd, user, isGroup) => {\n        const type = isGroup ? 'Group' : 'Private';\n        console.log(`${chalk.gray(`[${getTimestamp()}]`)} ${chalk.green('[CMD]')} ${chalk.yellow(cmd)} from ${chalk.cyan(user)} (${type})`);\n    },\n    \n    banner: () => {\n        console.log(chalk.cyan(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                                       ‚ïë\n‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó             ‚ïë\n‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë             ‚ïë\n‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë             ‚ïë\n‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë             ‚ïë\n‚ïë    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó        ‚ïë\n‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù        ‚ïë\n‚ïë                                       ‚ïë\n‚ïë    WhatsApp Bot with PostgreSQL       ‚ïë\n‚ïë         Powered by Baileys            ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n        `));\n    },\n    \n    systemInfo: (info) => {\n        console.log(chalk.green('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'));\n        console.log(chalk.green('‚ïë') + chalk.cyan(' System Information'));\n        console.log(chalk.green('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'));\n        console.log(chalk.green('‚ïë') + ` OS: ${chalk.yellow(info.os)}`);\n        console.log(chalk.green('‚ïë') + ` Platform: ${chalk.yellow(info.platform)}`);\n        console.log(chalk.green('‚ïë') + ` Node.js: ${chalk.yellow(info.nodeVersion)}`);\n        console.log(chalk.green('‚ïë') + ` Memory: ${chalk.yellow(info.memory)}`);\n        console.log(chalk.green('‚ïë') + ` CPU: ${chalk.yellow(info.cpu)}`);\n        console.log(chalk.green('‚ïë') + ` Date: ${chalk.yellow(info.date)}`);\n        console.log(chalk.green('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'));\n    }\n};\n\nmodule.exports = { logger };\n","path":null,"size_bytes":3373,"size_tokens":null},"ciel/config/settings.js":{"content":"require('dotenv').config();\n\nmodule.exports = {\n    owner: process.env.OWNER_NUMBER ? process.env.OWNER_NUMBER.split(',') : ['6282113821188'],\n    \n    botInfo: {\n        name: process.env.BOT_NAME || 'Ciel Bot',\n        author: process.env.BOT_AUTHOR || 'Ciel',\n        packname: process.env.STICKER_PACKNAME || 'Ciel Stickers',\n        version: '1.0.0'\n    },\n    \n    prefixes: ['+', '!', '.', '#', '/'],\n    \n    limits: {\n        free: 20,\n        premium: 999,\n        vip: 9999\n    },\n    \n    money: {\n        free: 10000,\n        premium: 1000000,\n        vip: 10000000\n    },\n    \n    messages: {\n        owner: 'Fitur khusus Owner!',\n        admin: 'Fitur khusus Admin!',\n        botAdmin: 'Bot bukan Admin!',\n        group: 'Gunakan di Group!',\n        private: 'Gunakan di Private Chat!',\n        limit: 'Limit anda telah habis!',\n        premium: 'Khusus User Premium!',\n        wait: 'Sedang memproses...',\n        error: 'Terjadi kesalahan!',\n        done: 'Selesai!'\n    },\n    \n    apis: {\n        gemini: process.env.GEMINI_API_KEY || ''\n    },\n    \n    database: {\n        url: process.env.DATABASE_URL || 'postgresql://postgres:VSktFuvpEIgHCnIDpNnXXnCSZlotLNUI@shinkansen.proxy.rlwy.net:22870/railway'\n    },\n    \n    server: {\n        port: process.env.PORT || 5000\n    },\n    \n    session: {\n        folderName: process.env.SESSION_FOLDER || 'ciel_session'\n    },\n    \n    pairing: {\n        enabled: process.env.PAIRING_CODE === 'true' || true,\n        phoneNumber: process.env.BOT_NUMBER || ''\n    },\n    \n    features: {\n        autoRead: true,\n        autoTyping: true,\n        antiSpam: true,\n        multiPrefix: true,\n        public: true\n    },\n    \n    badWords: ['tolol', 'goblok', 'asu', 'pantek', 'kampret', 'ngentot', 'jancok', 'kontol', 'memek', 'lonte'],\n    \n    timezone: 'Asia/Jakarta',\n    \n    social: {\n        youtube: 'https://youtube.com',\n        github: 'https://github.com',\n        whatsappChannel: ''\n    }\n};\n","path":null,"size_bytes":1962,"size_tokens":null},"ciel/src/handlers/commands/tools.js":{"content":"const axios = require('axios');\nconst settings = require('../../../config/settings');\nconst { createSticker, webpToImage } = require('../../../lib/exif');\nconst { toAudio, toPTT, resizeImage, compressImage } = require('../../../lib/converter');\nconst { tts, ttsGoogle } = require('../../../lib/tts');\nconst { TelegraPh, UguuSe, Catbox } = require('../../../lib/uploader');\nconst { styletext, remini } = require('../../../lib/scraper');\nconst { nulisBuku, nulisFolio } = require('../../../lib/nulis');\n\nconst sticker = async (conn, m, { args, text, isOwner, botSettings }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isMedia) {\n        return m.reply('Kirim/reply gambar atau video dengan caption .sticker');\n    }\n    \n    if (!quoted.isImage && !quoted.isVideo && !quoted.isSticker) {\n        return m.reply('Hanya gambar/video/gif yang bisa dijadikan sticker!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        \n        const packname = args[0] || botSettings.packname || settings.botInfo.packname;\n        const author = args[1] || botSettings.author || settings.botInfo.author;\n        \n        const stickerBuffer = await createSticker(buffer, { packname, author });\n        \n        await conn.sendMessage(m.chat, { sticker: stickerBuffer }, { quoted: m });\n    } catch (e) {\n        console.error('Sticker error:', e);\n        m.reply('Gagal membuat sticker!');\n    }\n};\n\nconst s = sticker;\nconst stiker = sticker;\n\nconst toimg = async (conn, m, { isOwner }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isSticker) {\n        return m.reply('Reply sticker untuk dijadikan gambar!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        const imageBuffer = await webpToImage(buffer, 'png');\n        \n        await conn.sendMessage(m.chat, { \n            image: imageBuffer, \n            caption: 'Berhasil convert sticker ke gambar!' \n        }, { quoted: m });\n    } catch (e) {\n        console.error('Toimg error:', e);\n        m.reply('Gagal convert sticker!');\n    }\n};\n\nconst toimage = toimg;\n\nconst tomp3 = async (conn, m, { isOwner }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isMedia || (!quoted.isVideo && !quoted.isAudio)) {\n        return m.reply('Reply video/audio untuk dijadikan MP3!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        const mp3Buffer = await toAudio(buffer, 'mp3');\n        \n        await conn.sendMessage(m.chat, { \n            audio: mp3Buffer,\n            mimetype: 'audio/mpeg'\n        }, { quoted: m });\n    } catch (e) {\n        console.error('Tomp3 error:', e);\n        m.reply('Gagal convert ke MP3!');\n    }\n};\n\nconst toaudio = tomp3;\n\nconst tovn = async (conn, m, { isOwner }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isMedia || (!quoted.isVideo && !quoted.isAudio)) {\n        return m.reply('Reply video/audio untuk dijadikan voice note!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        const pttBuffer = await toPTT(buffer);\n        \n        await conn.sendMessage(m.chat, { \n            audio: pttBuffer,\n            mimetype: 'audio/ogg; codecs=opus',\n            ptt: true\n        }, { quoted: m });\n    } catch (e) {\n        console.error('Tovn error:', e);\n        m.reply('Gagal convert ke voice note!');\n    }\n};\n\nconst toptt = tovn;\n\nconst translate = async (conn, m, { args, text }) => {\n    if (!text) return m.reply('Masukkan teks yang akan diterjemahkan!\\nContoh: .translate en Halo apa kabar');\n    \n    const lang = args[0]?.length === 2 ? args[0] : 'id';\n    const textToTranslate = lang === args[0] ? args.slice(1).join(' ') : text;\n    \n    if (!textToTranslate) return m.reply('Masukkan teks yang akan diterjemahkan!');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://api.mymemory.translated.net/get`, {\n            params: {\n                q: textToTranslate,\n                langpair: `auto|${lang}`\n            }\n        });\n        \n        const translated = response.data.responseData.translatedText;\n        m.reply(`*üåê Translate*\\n\\n*Teks:* ${textToTranslate}\\n*Bahasa:* ${lang}\\n*Hasil:* ${translated}`);\n    } catch (e) {\n        console.error('Translate error:', e);\n        m.reply('Gagal menerjemahkan!');\n    }\n};\n\nconst tr = translate;\n\nconst resize = async (conn, m, { args }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isImage) {\n        return m.reply('Reply gambar untuk diresize!');\n    }\n    \n    const width = parseInt(args[0]) || 512;\n    const height = parseInt(args[1]) || 512;\n    \n    if (width > 2048 || height > 2048) {\n        return m.reply('Ukuran maksimal 2048x2048!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        const resizedBuffer = await resizeImage(buffer, width, height, 'fill');\n        \n        await conn.sendMessage(m.chat, { \n            image: resizedBuffer, \n            caption: `Berhasil resize ke ${width}x${height}!` \n        }, { quoted: m });\n    } catch (e) {\n        console.error('Resize error:', e);\n        m.reply('Gagal resize gambar!');\n    }\n};\n\nconst compress = async (conn, m, { args }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isImage) {\n        return m.reply('Reply gambar untuk dicompress!');\n    }\n    \n    const quality = parseInt(args[0]) || 50;\n    \n    if (quality < 1 || quality > 100) {\n        return m.reply('Quality harus antara 1-100!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        const compressedBuffer = await compressImage(buffer, quality);\n        \n        const originalSize = (buffer.length / 1024).toFixed(2);\n        const newSize = (compressedBuffer.length / 1024).toFixed(2);\n        \n        await conn.sendMessage(m.chat, { \n            image: compressedBuffer, \n            caption: `‚úÖ Berhasil compress!\\nUkuran: ${originalSize}KB ‚Üí ${newSize}KB\\nQuality: ${quality}%` \n        }, { quoted: m });\n    } catch (e) {\n        console.error('Compress error:', e);\n        m.reply('Gagal compress gambar!');\n    }\n};\n\nconst qr = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan teks untuk dijadikan QR Code!');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const url = `https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${encodeURIComponent(text)}`;\n        const response = await axios.get(url, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, { \n            image: Buffer.from(response.data), \n            caption: `*QR Code*\\n\\nData: ${text}` \n        }, { quoted: m });\n    } catch (e) {\n        console.error('QR error:', e);\n        m.reply('Gagal membuat QR Code!');\n    }\n};\n\nconst qrcode = qr;\n\nconst ocr = async (conn, m, { text }) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isImage) {\n        return m.reply('Reply gambar untuk membaca teks!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        m.reply('Fitur OCR membutuhkan API. Silakan hubungi owner untuk mengaktifkan fitur ini.');\n    } catch (e) {\n        console.error('OCR error:', e);\n        m.reply('Gagal membaca teks dari gambar!');\n    }\n};\n\nconst ssweb = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan URL website!\\nContoh: .ssweb google.com');\n    \n    let url = text.trim();\n    if (!url.startsWith('http')) url = 'https://' + url;\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const apiUrl = `https://image.thum.io/get/width/1280/crop/720/fullpage/${encodeURIComponent(url)}`;\n        const response = await axios.get(apiUrl, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, { \n            image: Buffer.from(response.data), \n            caption: `*üì∏ Screenshot*\\n\\nURL: ${url}` \n        }, { quoted: m });\n    } catch (e) {\n        console.error('Ssweb error:', e);\n        m.reply('Gagal screenshot website!');\n    }\n};\n\nconst ss = ssweb;\n\nconst get = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan URL!\\nContoh: .get https://api.example.com/data');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(text);\n        let result = typeof response.data === 'object' ? \n            JSON.stringify(response.data, null, 2) : \n            response.data;\n        \n        if (result.length > 4000) {\n            result = result.substring(0, 4000) + '\\n\\n... (terpotong)';\n        }\n        \n        m.reply(`*üì• GET Response*\\n\\n${result}`);\n    } catch (e) {\n        console.error('Get error:', e);\n        m.reply(`Error: ${e.message}`);\n    }\n};\n\nconst fetch = get;\n\nconst shorturl = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan URL yang akan dipendekkan!');\n    \n    let url = text.trim();\n    if (!url.startsWith('http')) url = 'https://' + url;\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(url)}`);\n        m.reply(`*üîó URL Shortener*\\n\\nOriginal: ${url}\\nShort: ${response.data}`);\n    } catch (e) {\n        console.error('Shorturl error:', e);\n        m.reply('Gagal mempendekkan URL!');\n    }\n};\n\nconst tinyurl = shorturl;\n\nconst calc = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan rumus matematika!\\nContoh: .calc 2+2*3');\n    \n    try {\n        const sanitized = text.replace(/[^0-9+\\-*/().%\\s]/g, '');\n        const result = eval(sanitized);\n        m.reply(`*üî¢ Kalkulator*\\n\\n${text} = ${result}`);\n    } catch (e) {\n        m.reply('Rumus tidak valid!');\n    }\n};\n\nconst kalkulator = calc;\nconst hitung = calc;\n\nconst runtime = async (conn, m, {}) => {\n    const uptime = process.uptime();\n    const days = Math.floor(uptime / 86400);\n    const hours = Math.floor((uptime % 86400) / 3600);\n    const minutes = Math.floor((uptime % 3600) / 60);\n    const seconds = Math.floor(uptime % 60);\n    \n    m.reply(`*‚è±Ô∏è Runtime*\\n\\n${days}d ${hours}h ${minutes}m ${seconds}s`);\n};\n\nconst uptime = runtime;\n\nconst weather = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan nama kota!\\nContoh: .weather Jakarta');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://wttr.in/${encodeURIComponent(text)}?format=j1`);\n        const data = response.data;\n        const current = data.current_condition[0];\n        const location = data.nearest_area[0];\n        \n        const info = `*üå§Ô∏è Weather*\n\n*Lokasi:* ${location.areaName[0].value}, ${location.country[0].value}\n*Cuaca:* ${current.weatherDesc[0].value}\n*Suhu:* ${current.temp_C}¬∞C / ${current.temp_F}¬∞F\n*Kelembaban:* ${current.humidity}%\n*Angin:* ${current.windspeedKmph} km/h ${current.winddir16Point}\n*Visibilitas:* ${current.visibility} km\n*UV Index:* ${current.uvIndex}`;\n        \n        m.reply(info);\n    } catch (e) {\n        console.error('Weather error:', e);\n        m.reply('Gagal mendapatkan info cuaca!');\n    }\n};\n\nconst cuaca = weather;\n\nconst say2 = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan teks yang akan diubah ke audio!\\nContoh: .tts halo dunia\\nContoh dengan bahasa: .tts en hello world');\n    \n    const validLangs = ['id', 'en', 'ja', 'ko', 'zh', 'es', 'fr', 'de', 'ar', 'hi', 'pt', 'ru', 'it', 'th', 'vi', 'ms'];\n    const parts = text.split(' ');\n    const firstWord = parts[0]?.toLowerCase();\n    \n    let lang = 'id';\n    let teksToSay = text;\n    \n    if (firstWord?.length === 2 && validLangs.includes(firstWord)) {\n        lang = firstWord;\n        teksToSay = parts.slice(1).join(' ');\n    }\n    \n    if (!teksToSay || !teksToSay.trim()) {\n        return m.reply('Masukkan teks yang akan diubah ke audio!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const audioBuffer = await ttsGoogle(teksToSay.trim(), lang);\n        \n        await conn.sendMessage(m.chat, {\n            audio: audioBuffer,\n            mimetype: 'audio/mpeg',\n            ptt: true\n        }, { quoted: m });\n    } catch (e) {\n        console.error('TTS error:', e);\n        m.reply('Gagal membuat audio! Coba lagi nanti.');\n    }\n};\n\nconst texttospeech = say2;\n\nconst upload = async (conn, m, {}) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isMedia) {\n        return m.reply('Reply gambar/video/dokumen untuk diupload!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        \n        let url;\n        try {\n            url = await TelegraPh(buffer);\n        } catch (e) {\n            try {\n                const result = await UguuSe(buffer);\n                url = result.url || result;\n            } catch (e2) {\n                url = await Catbox(buffer);\n            }\n        }\n        \n        m.reply(`*üì§ Upload Berhasil!*\\n\\n*URL:* ${url}\\n\\n_Link akan expired sesuai kebijakan hosting._`);\n    } catch (e) {\n        console.error('Upload error:', e);\n        m.reply('Gagal upload file!');\n    }\n};\n\nconst tourl = upload;\n\nconst styletxt = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan teks untuk diubah stylenya!\\nContoh: .styletext hello');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const result = await styletext(text);\n        \n        if (!result || !result.length) {\n            return m.reply('Gagal mengubah style teks!');\n        }\n        \n        let msg = `*‚ú® StyleText*\\n\\n*Teks:* ${text}\\n\\n`;\n        result.slice(0, 15).forEach((item, i) => {\n            if (item.name && item.result) {\n                msg += `*${i + 1}. ${item.name}*\\n${item.result}\\n\\n`;\n            }\n        });\n        \n        m.reply(msg);\n    } catch (e) {\n        console.error('StyleText error:', e);\n        m.reply('Gagal mengubah style teks!');\n    }\n};\n\nconst styletext2 = styletxt;\n\nconst hd = async (conn, m, {}) => {\n    const quoted = m.quoted || m;\n    \n    if (!quoted.isImage) {\n        return m.reply('Reply gambar untuk ditingkatkan kualitasnya!');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await quoted.download();\n        const result = await remini(buffer, 'enhance');\n        \n        await conn.sendMessage(m.chat, {\n            image: Buffer.from(result),\n            caption: '*‚ú® HD Enhance Berhasil!*'\n        }, { quoted: m });\n    } catch (e) {\n        console.error('HD error:', e);\n        m.reply('Gagal meningkatkan kualitas gambar!');\n    }\n};\n\nconst enhance = hd;\nconst remini2 = hd;\n\nconst nulis = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan teks untuk ditulis!\\nContoh: .nulis Halo dunia ini adalah contoh tulisan tangan');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await nulisBuku(text, 'kiri');\n        \n        await conn.sendMessage(m.chat, {\n            image: buffer,\n            caption: '*‚úçÔ∏è Nulis Berhasil!*'\n        }, { quoted: m });\n    } catch (e) {\n        console.error('Nulis error:', e);\n        m.reply('Gagal membuat tulisan!');\n    }\n};\n\nconst tulis = nulis;\n\nconst nulisfolio = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan teks untuk ditulis!\\nContoh: .nulisfolio Halo dunia ini adalah contoh tulisan di folio');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const buffer = await nulisFolio(text, 'kiri');\n        \n        await conn.sendMessage(m.chat, {\n            image: buffer,\n            caption: '*‚úçÔ∏è Nulis Folio Berhasil!*'\n        }, { quoted: m });\n    } catch (e) {\n        console.error('Nulis folio error:', e);\n        m.reply('Gagal membuat tulisan!');\n    }\n};\n\nmodule.exports = {\n    sticker,\n    s,\n    stiker,\n    toimg,\n    toimage,\n    tomp3,\n    toaudio,\n    tovn,\n    toptt,\n    translate,\n    tr,\n    resize,\n    compress,\n    qr,\n    qrcode,\n    ocr,\n    ssweb,\n    ss,\n    get,\n    fetch,\n    shorturl,\n    tinyurl,\n    calc,\n    kalkulator,\n    hitung,\n    runtime,\n    uptime,\n    weather,\n    cuaca,\n    tts: say2,\n    texttospeech,\n    upload,\n    tourl,\n    styletext: styletxt,\n    styletxt,\n    hd,\n    enhance,\n    remini: remini2,\n    nulis,\n    tulis,\n    nulisfolio\n};\n","path":null,"size_bytes":16653,"size_tokens":null},"ciel/src/server.js":{"content":"const express = require('express');\nconst { createServer } = require('http');\nconst settings = require('../config/settings');\nconst { runtime } = require('./utils/functions');\nconst pkg = require('../package.json');\n\nconst app = express();\nconst server = createServer(app);\n\napp.use(express.json());\n\nlet botInstance = null;\nlet serverStarted = false;\nconst startTime = Date.now();\n\nconst startServer = (conn) => {\n    botInstance = conn;\n    \n    if (serverStarted) return;\n    \n    const PORT = settings.server.port;\n    \n    server.listen(PORT, '0.0.0.0', () => {\n        serverStarted = true;\n        console.log(`üåê Server berjalan di port ${PORT}`);\n    });\n};\n\napp.get('/', (req, res) => {\n    const uptime = Math.floor((Date.now() - startTime) / 1000);\n    res.json({\n        status: 'online',\n        bot_name: pkg.name,\n        version: pkg.version,\n        author: pkg.author,\n        uptime: runtime(uptime),\n        uptime_seconds: uptime,\n        connected: !!botInstance?.user,\n        user: botInstance?.user?.name || null\n    });\n});\n\napp.get('/health', (req, res) => {\n    res.json({\n        status: botInstance?.user ? 'healthy' : 'starting',\n        timestamp: new Date().toISOString()\n    });\n});\n\napp.get('/stats', async (req, res) => {\n    try {\n        const { getHitStats } = require('./services/database');\n        const stats = await getHitStats();\n        res.json({\n            success: true,\n            data: stats\n        });\n    } catch (e) {\n        res.status(500).json({\n            success: false,\n            error: e.message\n        });\n    }\n});\n\napp.post('/send', async (req, res) => {\n    if (!botInstance) {\n        return res.status(503).json({\n            success: false,\n            error: 'Bot tidak terhubung'\n        });\n    }\n    \n    const { to, message } = req.body;\n    \n    if (!to || !message) {\n        return res.status(400).json({\n            success: false,\n            error: 'Parameter \"to\" dan \"message\" diperlukan'\n        });\n    }\n    \n    try {\n        const jid = to.includes('@') ? to : `${to.replace(/[^0-9]/g, '')}@s.whatsapp.net`;\n        await botInstance.sendMessage(jid, { text: message });\n        res.json({\n            success: true,\n            message: 'Pesan terkirim'\n        });\n    } catch (e) {\n        res.status(500).json({\n            success: false,\n            error: e.message\n        });\n    }\n});\n\napp.get('/groups', async (req, res) => {\n    if (!botInstance) {\n        return res.status(503).json({\n            success: false,\n            error: 'Bot tidak terhubung'\n        });\n    }\n    \n    try {\n        const groups = await botInstance.groupFetchAllParticipating();\n        const groupList = Object.values(groups).map(g => ({\n            id: g.id,\n            subject: g.subject,\n            participants: g.participants?.length || 0\n        }));\n        \n        res.json({\n            success: true,\n            count: groupList.length,\n            groups: groupList\n        });\n    } catch (e) {\n        res.status(500).json({\n            success: false,\n            error: e.message\n        });\n    }\n});\n\nserver.on('error', (error) => {\n    if (error.code === 'EADDRINUSE') {\n        console.log(`Port ${settings.server.port} sudah digunakan!`);\n    } else {\n        console.error('Server error:', error);\n    }\n});\n\nmodule.exports = { app, server, startServer };\n","path":null,"size_bytes":3371,"size_tokens":null},"source-2/README.md":{"content":"# WhatsApp TikTok/Douyin Downloader Bot\n\n![Bot Logo](https://files.catbox.moe/nlxg1u.jpg)\n\nA feature-rich WhatsApp bot that allows users to download TikTok and Douyin videos directly through WhatsApp, with additional utilities like sticker creation and performance monitoring.\n\n## üåü Features\n\n- **TikTok/Douyin Downloader**\n  - Download videos without watermark\n  - Support for slideshow posts\n  - Audio extraction option\n  - Automatic detection of TikTok/Douyin links\n\n- **Sticker Creator**\n  - Convert images/videos to stickers\n  - Custom pack name and author\n  - Supports GIF, image, and video formats\n\n- **Bot Utilities**\n  - Multi-prefix support (`!`, `.`, `/`, or no prefix)\n  - Performance monitoring (RAM, uptime, speed)\n  - Auto-read messages\n  - Ping command to check latency\n\n- **User Friendly**\n  - Detailed error messages\n  - Progress updates\n  - Clean response formatting\n\n## üöÄ Installation\n\n### Prerequisites\n- Node.js v20 or higher\n- WhatsApp account\n- FFmpeg installed\n\n### Setup\n1. Clone the repository:\n```bash\ngit clone https://github.com/Yuri-Neko/Simple-Bot.git\ncd Simple-Bot\n```\n\n2. Install dependencies:\n```bash\nnpm install\n```\n\n3. Configure the bot:\n```bash\nnano config.js\n```\nEdit `config.js` with your preferences\n\n4. Start the bot:\n```bash\nnpm start\n```\n\n## üìã Usage\n\n### Basic Commands\n| Command | Description | Example |\n|---------|-------------|---------|\n| `!sticker` | Create sticker from media | `!sticker` |\n| `!ping` | Check bot response time | `!ping` |\n| `!info` | Show bot information | `!info` |\n\n### TikTok/Douyin Download\nSimply send any TikTok/Douyin link in chat:\n```\nhttps://vt.tiktok.com/xyz123\nhttps://www.douyin.com/abc456\n```\n\n## üõ†Ô∏è Configuration\nEdit `config.js` to customize:\n```javascript\nmodule.exports = {\n    // Bot settings\n    botInfo: {\n        name: \"MyBot\",\n        owner: [\"6281234567890@s.whatsapp.net\"],\n        public: true,\n        version: \"1.0.0\"\n    },\n    \n    // Command prefixes\n    prefixes: ['!', '.', '/', ''], // Empty string for no prefix\n    \n    // Sticker defaults\n    globalPackname: 'MyBot Stickers',\n    globalAuthor: 'MyBot',\n    \n    // Performance monitoring\n    monitorInterval: 60000 // 1 minute\n};\n```\n\n## üìä Bot Information Display\n```\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå BOT INFO „Äç‚ùç\n‚îú Name : MyBot v1.0.0\n‚îú Owner : @username\n‚îú Mode : Public\n‚îú Prefix : Multi-Prefix\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå PERFORMANCE „Äç‚ùç\n‚îú Uptime : 2d 5h 30m\n‚îú RAM Usage : 156.42 MB\n‚îú Speed : 24.56 ms\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\n```\n\n## üíñ Special Thanks\n- **[Baileys Library](https://github.com/naruyaizumi/baileys)** by [@naruyaizumi](https://github.com/naruyaizumi) - The WhatsApp Web library that makes this bot possible\n- All contributors and users who helped test and improve this bot\n\n## ü§ù Contributing\nContributions are welcome! Please follow these steps:\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/AmazingFeature`)\n3. Commit your changes (`git commit -m 'Add some amazing feature'`)\n4. Push to the branch (`git push origin feature/AmazingFeature`)\n5. Open a Pull Request\n\n\n## ‚úâÔ∏è Contact\nAuthor: Ren Takamori  \nProject Link: [https://github.com/Yuri-Neko/Simple-Bot/](https://github.com/Yuri-Neko/Simple-Bot/)  \nEmail: admin@takamori.xyz\n","path":null,"size_bytes":3285,"size_tokens":null},"source-1/settings.js":{"content":"const fs = require('fs');\r\nconst chalk = require('chalk');\r\n\r\n/*\r\n\t* Create By Naze\r\n\t* Follow https://github.com/nazedev\r\n\t* Whatsapp : https://whatsapp.com/channel/0029VaWOkNm7DAWtkvkJBK43\r\n*/\r\n\r\n//~~~~~~~~~~~~< GLOBAL SETTINGS >~~~~~~~~~~~~\\\\\r\n\r\nglobal.owner = ['6282113821188'] //['628','628'] 2 owner atau lebih\r\nglobal.author = 'Nazedev'\r\nglobal.botname = 'Hitori Bot'\r\nglobal.packname = 'Bot WhatsApp'\r\nglobal.listprefix = ['+','!','.']\r\n\r\n/*\r\n- Setting Author, Packname, Botname sekarang pakai command\r\n- Walau sudah diganti tidak berubah\r\n- setbotauthor, setbotpackname, setbotname\r\n*/\r\n\r\nglobal.listv = ['‚Ä¢','‚óè','‚ñ†','‚úø','‚ñ≤','‚û©','‚û¢','‚û£','‚û§','‚ú¶','‚úß','‚ñ≥','‚ùÄ','‚óã','‚ñ°','‚ô§','‚ô°','‚óá','‚ôß','„ÄÖ','„ÄÜ']\r\nglobal.tempatDB = 'database.json' // Taruh url mongodb di sini jika menggunakan mongodb. Format : 'mongodb+srv://...'\r\nglobal.tempatStore = 'baileys_store.json' // Taruh url mongodb di sini jika menggunakan mongodb. Format : 'mongodb+srv://...'\r\nglobal.pairing_code = true\r\nglobal.number_bot = '' // Kalo pake panel bisa masukin nomer di sini, jika belum ambil session. Format : '628xx'\r\n\r\nglobal.fake = {\r\n\tanonim: 'https://telegra.ph/file/95670d63378f7f4210f03.png',\r\n\tthumbnailUrl: 'https://telegra.ph/file/fe4843a1261fc414542c4.jpg',\r\n\tthumbnail: fs.readFileSync('./src/media/naze.png'),\r\n\tdocs: fs.readFileSync('./src/media/fake.pdf'),\r\n\tlistfakedocs: ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet','application/vnd.openxmlformats-officedocument.presentationml.presentation','application/vnd.openxmlformats-officedocument.wordprocessingml.document','application/pdf'],\r\n}\r\n\r\nglobal.my = {\r\n\tyt: 'https://youtube.com/c/Nazedev',\r\n\tgh: 'https://github.com/nazedev',\r\n\tgc: 'https://chat.whatsapp.com/B5qJIwZHm4VEYZJQE6iMwy',\r\n\tch: '120363250409960161@newsletter',\r\n}\r\n\r\nglobal.limit = {\r\n\tfree: 20,\r\n\tpremium: 999,\r\n\tvip: 9999\r\n}\r\n\r\nglobal.money = {\r\n\tfree: 10000,\r\n\tpremium: 1000000,\r\n\tvip: 10000000\r\n}\r\n\r\nglobal.mess = {\r\n\tkey: 'Apikey mu telah habis silahkan kunjungi\\nhttps://my.hitori.pw',\r\n\towner: 'Fitur Khusus Owner!',\r\n\tadmin: 'Fitur Khusus Admin!',\r\n\tbotAdmin: 'Bot Bukan Admin!',\r\n\tgroup: 'Gunakan Di Group!',\r\n\tprivate: 'Gunakan Di Privat Chat!',\r\n\tlimit: 'Limit Anda Telah Habis!',\r\n\tprem: 'Khusus User Premium!',\r\n\twait: 'Loading...',\r\n\terror: 'Error!',\r\n\tdone: 'Done'\r\n}\r\n\r\nglobal.APIs = {\r\n\thitori: 'https://api.hitori.pw',\r\n}\r\nglobal.APIKeys = {\r\n\t'https://api.hitori.pw': 'htrkey-77eb83c0eeb39d40',\r\n\tgeminiApikey: ['AIzaSyD0lkGz6ZhKi_MHSSmJcCX3wXoDZhELPaQ','AIzaSyDnBPd_EhBfr73NssnThVQZYiKZVhGZewU','AIzaSyA94OZD-0V4quRbzPb2j75AuzSblPHE75M','AIzaSyB5aTYbUg2VQ0oXr5hdJPN8AyLJcmM84-A','AIzaSyB1xYZ2YImnBdi2Bh-If_8lj6rvSkabqlA']\r\n}\r\n\r\n// Lainnya\r\n\r\nglobal.badWords = ['tolol','goblok','asu','pantek','kampret','ngentot','jancok','kontol','memek','lonte']\r\nglobal.chatLength = 1000\r\n\r\n//~~~~~~~~~~~~~~~< PROCESS >~~~~~~~~~~~~~~~\\\\\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});\r\n","path":null,"size_bytes":3111,"size_tokens":null},"ciel/src/services/database.js":{"content":"const { PrismaClient } = require('@prisma/client');\nconst settings = require('../../config/settings');\n\nconst prisma = new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error']\n});\n\nasync function connectDatabase() {\n    try {\n        await prisma.$connect();\n        console.log('‚úÖ Database PostgreSQL terhubung!');\n        return true;\n    } catch (error) {\n        console.error('‚ùå Gagal menghubungkan database:', error.message);\n        return false;\n    }\n}\n\nasync function disconnectDatabase() {\n    await prisma.$disconnect();\n    console.log('Database terputus');\n}\n\nasync function getOrCreateUser(jid, name = null) {\n    try {\n        let user = await prisma.user.findUnique({ where: { jid } });\n        if (!user) {\n            user = await prisma.user.create({\n                data: {\n                    jid,\n                    name,\n                    limit: settings.limits.free,\n                    money: settings.money.free\n                }\n            });\n        } else if (name && user.name !== name) {\n            user = await prisma.user.update({\n                where: { jid },\n                data: { name }\n            });\n        }\n        return user;\n    } catch (error) {\n        console.error('Error getOrCreateUser:', error);\n        return null;\n    }\n}\n\nasync function getUser(jid) {\n    try {\n        return await prisma.user.findUnique({ where: { jid } });\n    } catch (error) {\n        console.error('Error getUser:', error);\n        return null;\n    }\n}\n\nasync function updateUser(jid, data) {\n    try {\n        return await prisma.user.update({\n            where: { jid },\n            data\n        });\n    } catch (error) {\n        console.error('Error updateUser:', error);\n        return null;\n    }\n}\n\nasync function getOrCreateGroup(jid, name = null) {\n    try {\n        let group = await prisma.group.findUnique({ where: { jid } });\n        if (!group) {\n            group = await prisma.group.create({\n                data: { jid, name }\n            });\n        } else if (name && group.name !== name) {\n            group = await prisma.group.update({\n                where: { jid },\n                data: { name }\n            });\n        }\n        return group;\n    } catch (error) {\n        console.error('Error getOrCreateGroup:', error);\n        return null;\n    }\n}\n\nasync function getGroup(jid) {\n    try {\n        return await prisma.group.findUnique({ where: { jid } });\n    } catch (error) {\n        console.error('Error getGroup:', error);\n        return null;\n    }\n}\n\nasync function updateGroup(jid, data) {\n    try {\n        return await prisma.group.update({\n            where: { jid },\n            data\n        });\n    } catch (error) {\n        console.error('Error updateGroup:', error);\n        return null;\n    }\n}\n\nasync function getOrCreateBotSettings(botJid) {\n    try {\n        let botSettings = await prisma.botSettings.findUnique({ where: { botJid } });\n        if (!botSettings) {\n            botSettings = await prisma.botSettings.create({\n                data: {\n                    botJid,\n                    owner: settings.owner,\n                    botName: settings.botInfo.name,\n                    author: settings.botInfo.author,\n                    packname: settings.botInfo.packname\n                }\n            });\n        }\n        return botSettings;\n    } catch (error) {\n        console.error('Error getOrCreateBotSettings:', error);\n        return null;\n    }\n}\n\nasync function updateBotSettings(botJid, data) {\n    try {\n        return await prisma.botSettings.update({\n            where: { botJid },\n            data\n        });\n    } catch (error) {\n        console.error('Error updateBotSettings:', error);\n        return null;\n    }\n}\n\nasync function addPremium(userJid, days) {\n    try {\n        const expiredAt = new Date();\n        expiredAt.setDate(expiredAt.getDate() + days);\n        \n        const existing = await prisma.premium.findUnique({ where: { userJid } });\n        if (existing) {\n            const newExpiry = new Date(existing.expiredAt);\n            newExpiry.setDate(newExpiry.getDate() + days);\n            await prisma.premium.update({\n                where: { userJid },\n                data: { expiredAt: newExpiry }\n            });\n        } else {\n            await prisma.premium.create({\n                data: { userJid, expiredAt }\n            });\n        }\n        \n        await prisma.user.update({\n            where: { jid: userJid },\n            data: {\n                premium: true,\n                premiumExpiry: expiredAt,\n                limit: settings.limits.premium,\n                money: { increment: settings.money.premium - settings.money.free }\n            }\n        });\n        \n        return true;\n    } catch (error) {\n        console.error('Error addPremium:', error);\n        return false;\n    }\n}\n\nasync function removePremium(userJid) {\n    try {\n        await prisma.premium.delete({ where: { userJid } });\n        await prisma.user.update({\n            where: { jid: userJid },\n            data: {\n                premium: false,\n                premiumExpiry: null,\n                limit: settings.limits.free\n            }\n        });\n        return true;\n    } catch (error) {\n        console.error('Error removePremium:', error);\n        return false;\n    }\n}\n\nasync function isPremium(userJid) {\n    try {\n        const premium = await prisma.premium.findUnique({ where: { userJid } });\n        if (!premium) return false;\n        if (new Date() > premium.expiredAt) {\n            await removePremium(userJid);\n            return false;\n        }\n        return true;\n    } catch (error) {\n        console.error('Error isPremium:', error);\n        return false;\n    }\n}\n\nasync function listPremium() {\n    try {\n        return await prisma.premium.findMany({\n            include: { }\n        });\n    } catch (error) {\n        console.error('Error listPremium:', error);\n        return [];\n    }\n}\n\nasync function addSewa(groupJid, groupUrl, days) {\n    try {\n        const expiredAt = new Date();\n        expiredAt.setDate(expiredAt.getDate() + days);\n        \n        const existing = await prisma.sewa.findUnique({ where: { groupJid } });\n        if (existing) {\n            const newExpiry = new Date(existing.expiredAt);\n            newExpiry.setDate(newExpiry.getDate() + days);\n            return await prisma.sewa.update({\n                where: { groupJid },\n                data: { expiredAt: newExpiry, groupUrl }\n            });\n        }\n        \n        return await prisma.sewa.create({\n            data: { groupJid, groupUrl, expiredAt }\n        });\n    } catch (error) {\n        console.error('Error addSewa:', error);\n        return null;\n    }\n}\n\nasync function removeSewa(groupJid) {\n    try {\n        await prisma.sewa.delete({ where: { groupJid } });\n        return true;\n    } catch (error) {\n        console.error('Error removeSewa:', error);\n        return false;\n    }\n}\n\nasync function getSewa(groupJid) {\n    try {\n        return await prisma.sewa.findUnique({ where: { groupJid } });\n    } catch (error) {\n        console.error('Error getSewa:', error);\n        return null;\n    }\n}\n\nasync function listSewa() {\n    try {\n        return await prisma.sewa.findMany();\n    } catch (error) {\n        console.error('Error listSewa:', error);\n        return [];\n    }\n}\n\nasync function addHit(command) {\n    try {\n        await prisma.hit.upsert({\n            where: { command },\n            create: { command, count: 1 },\n            update: { count: { increment: 1 } }\n        });\n        \n        await prisma.totalHit.upsert({\n            where: { id: 'total' },\n            create: { totalCmd: 1, todayCmd: 1 },\n            update: {\n                totalCmd: { increment: 1 },\n                todayCmd: { increment: 1 }\n            }\n        });\n        \n        return true;\n    } catch (error) {\n        console.error('Error addHit:', error);\n        return false;\n    }\n}\n\nasync function resetDailyHit() {\n    try {\n        await prisma.totalHit.update({\n            where: { id: 'total' },\n            data: { todayCmd: 0, lastReset: new Date() }\n        });\n        return true;\n    } catch (error) {\n        console.error('Error resetDailyHit:', error);\n        return false;\n    }\n}\n\nasync function getHitStats() {\n    try {\n        const total = await prisma.totalHit.findUnique({ where: { id: 'total' } });\n        const topCommands = await prisma.hit.findMany({\n            orderBy: { count: 'desc' },\n            take: 10\n        });\n        return { total, topCommands };\n    } catch (error) {\n        console.error('Error getHitStats:', error);\n        return { total: null, topCommands: [] };\n    }\n}\n\nasync function addWarn(groupJid, userJid, reason = null) {\n    try {\n        const group = await getOrCreateGroup(groupJid);\n        const warn = await prisma.groupWarn.upsert({\n            where: {\n                groupId_userJid: {\n                    groupId: group.id,\n                    userJid\n                }\n            },\n            create: {\n                groupId: group.id,\n                userJid,\n                reason,\n                count: 1\n            },\n            update: {\n                count: { increment: 1 },\n                reason\n            }\n        });\n        return warn;\n    } catch (error) {\n        console.error('Error addWarn:', error);\n        return null;\n    }\n}\n\nasync function removeWarn(groupJid, userJid) {\n    try {\n        const group = await getGroup(groupJid);\n        if (!group) return false;\n        \n        await prisma.groupWarn.delete({\n            where: {\n                groupId_userJid: {\n                    groupId: group.id,\n                    userJid\n                }\n            }\n        });\n        return true;\n    } catch (error) {\n        console.error('Error removeWarn:', error);\n        return false;\n    }\n}\n\nasync function getWarn(groupJid, userJid) {\n    try {\n        const group = await getGroup(groupJid);\n        if (!group) return null;\n        \n        return await prisma.groupWarn.findUnique({\n            where: {\n                groupId_userJid: {\n                    groupId: group.id,\n                    userJid\n                }\n            }\n        });\n    } catch (error) {\n        console.error('Error getWarn:', error);\n        return null;\n    }\n}\n\nasync function createActiveGame(chatJid, gameType, gameData, players, expiresInMinutes = 30) {\n    try {\n        const expiresAt = new Date();\n        expiresAt.setMinutes(expiresAt.getMinutes() + expiresInMinutes);\n        \n        return await prisma.activeGame.upsert({\n            where: {\n                chatJid_gameType: { chatJid, gameType }\n            },\n            create: {\n                chatJid,\n                gameType,\n                gameData,\n                players,\n                expiresAt\n            },\n            update: {\n                gameData,\n                players,\n                expiresAt\n            }\n        });\n    } catch (error) {\n        console.error('Error createActiveGame:', error);\n        return null;\n    }\n}\n\nasync function getActiveGame(chatJid, gameType) {\n    try {\n        const game = await prisma.activeGame.findUnique({\n            where: {\n                chatJid_gameType: { chatJid, gameType }\n            }\n        });\n        \n        if (game && new Date() > game.expiresAt) {\n            await deleteActiveGame(chatJid, gameType);\n            return null;\n        }\n        \n        return game;\n    } catch (error) {\n        console.error('Error getActiveGame:', error);\n        return null;\n    }\n}\n\nasync function updateActiveGame(chatJid, gameType, gameData) {\n    try {\n        return await prisma.activeGame.update({\n            where: {\n                chatJid_gameType: { chatJid, gameType }\n            },\n            data: { gameData }\n        });\n    } catch (error) {\n        console.error('Error updateActiveGame:', error);\n        return null;\n    }\n}\n\nasync function deleteActiveGame(chatJid, gameType) {\n    try {\n        await prisma.activeGame.delete({\n            where: {\n                chatJid_gameType: { chatJid, gameType }\n            }\n        });\n        return true;\n    } catch (error) {\n        console.error('Error deleteActiveGame:', error);\n        return false;\n    }\n}\n\nasync function cleanupExpiredData() {\n    try {\n        const now = new Date();\n        \n        const expiredPremiums = await prisma.premium.findMany({\n            where: { expiredAt: { lt: now } }\n        });\n        for (const prem of expiredPremiums) {\n            await removePremium(prem.userJid);\n        }\n        \n        await prisma.activeGame.deleteMany({\n            where: { expiresAt: { lt: now } }\n        });\n        \n        await prisma.mediaCache.deleteMany({\n            where: { expiresAt: { lt: now } }\n        });\n        \n        console.log('‚úÖ Cleanup expired data selesai');\n        return true;\n    } catch (error) {\n        console.error('Error cleanupExpiredData:', error);\n        return false;\n    }\n}\n\nasync function resetDailyLimits() {\n    try {\n        const users = await prisma.user.findMany();\n        \n        for (const user of users) {\n            let newLimit = settings.limits.free;\n            if (user.vip) {\n                newLimit = settings.limits.vip;\n            } else if (await isPremium(user.jid)) {\n                newLimit = settings.limits.premium;\n            }\n            \n            if (user.limit < newLimit) {\n                await prisma.user.update({\n                    where: { jid: user.jid },\n                    data: { limit: newLimit }\n                });\n            }\n        }\n        \n        await resetDailyHit();\n        console.log('‚úÖ Reset daily limits selesai');\n        return true;\n    } catch (error) {\n        console.error('Error resetDailyLimits:', error);\n        return false;\n    }\n}\n\nasync function checkExpiredSewa(conn) {\n    try {\n        const now = new Date();\n        const expiredSewas = await prisma.sewa.findMany({\n            where: { expiredAt: { lt: now } }\n        });\n        \n        for (const sewa of expiredSewas) {\n            if (conn) {\n                try {\n                    await conn.groupLeave(sewa.groupJid);\n                    console.log(`Left group ${sewa.groupJid} (sewa expired)`);\n                } catch (e) {\n                    console.error(`Error leaving group ${sewa.groupJid}:`, e.message);\n                }\n            }\n            await removeSewa(sewa.groupJid);\n        }\n        \n        return expiredSewas.length;\n    } catch (error) {\n        console.error('Error checkExpiredSewa:', error);\n        return 0;\n    }\n}\n\nmodule.exports = {\n    prisma,\n    connectDatabase,\n    disconnectDatabase,\n    getOrCreateUser,\n    getUser,\n    updateUser,\n    getOrCreateGroup,\n    getGroup,\n    updateGroup,\n    getOrCreateBotSettings,\n    updateBotSettings,\n    addPremium,\n    removePremium,\n    isPremium,\n    listPremium,\n    addSewa,\n    removeSewa,\n    getSewa,\n    listSewa,\n    addHit,\n    resetDailyHit,\n    getHitStats,\n    addWarn,\n    removeWarn,\n    getWarn,\n    createActiveGame,\n    getActiveGame,\n    updateActiveGame,\n    deleteActiveGame,\n    cleanupExpiredData,\n    resetDailyLimits,\n    checkExpiredSewa\n};\n","path":null,"size_bytes":15356,"size_tokens":null},"source-1/lib/exif.js":{"content":"require('../settings');\nconst fs = require('fs');\nconst path = require('path');\nconst { tmpdir } = require('os');\nconst Crypto = require('crypto');\nconst ff = require('fluent-ffmpeg');\nconst FileType = require('file-type');\nconst webp = require('node-webpmux');\n\nasync function gifToWebp(media) {\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.gif`)\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    fs.writeFileSync(tmpFileIn, media);\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on('error', reject)\n            .on('end', () => resolve(true))\n            .addOutputOptions([\n            \t'-vf', 'scale=512:512:force_original_aspect_ratio=decrease',\n            \t'-loop', '0',\n            \t'-preset', 'default',\n            \t'-an', '-vsync', '0'\n            ])\n            .toFormat('webp')\n            .save(tmpFileOut)\n    })\n    const buff = fs.readFileSync(tmpFileOut)\n    fs.unlinkSync(tmpFileOut)\n    fs.unlinkSync(tmpFileIn)\n    return buff\n}\n\nasync function imageToWebp(media) {\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.jpg`)\n    fs.writeFileSync(tmpFileIn, media)\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on('error', reject)\n            .on('end', () => resolve(true))\n            .addOutputOptions([\n                '-vcodec', 'libwebp', '-vf',\n                'scale=500:500:force_original_aspect_ratio=decrease,setsar=1, pad=500:500:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse',\n                '-loop', '0', '-preset', 'default'\n                 ])\n            .toFormat('webp')\n            .save(tmpFileOut)\n    })\n\n    const buff = fs.readFileSync(tmpFileOut)\n    fs.unlinkSync(tmpFileOut)\n    fs.unlinkSync(tmpFileIn)\n    return buff\n}\n\nasync function videoToWebp(media) {\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.mp4`)\n    fs.writeFileSync(tmpFileIn, media)\n    await new Promise((resolve, reject) => {\n        ff(tmpFileIn)\n            .on('error', reject)\n            .on('end', () => resolve(true))\n            .addOutputOptions([\n                '-vcodec',\n                'libwebp',\n                '-vf',\n                \"scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse\",\n                '-loop',\n                '0',\n                '-ss',\n                '00:00:00',\n                '-t',\n                '00:00:05',\n                '-preset',\n                'default',\n                '-an',\n                '-vsync',\n                '0'\n            ])\n            .toFormat('webp')\n            .save(tmpFileOut)\n    })\n\n    const buff = fs.readFileSync(tmpFileOut)\n    fs.unlinkSync(tmpFileOut)\n    fs.unlinkSync(tmpFileIn)\n    return buff\n}\n\nasync function writeExif(media, data) {\n\tconst anu = await FileType.fromBuffer(media)\n    const wMedia = /webp/.test(anu.mime) ? media : /image\\/gif/.test(anu.mime) ? await gifToWebp(media) : /jpeg|jpg|png/.test(anu.mime) ? await imageToWebp(media) : /video/.test(anu.mime) ? await videoToWebp(media) : '';\n    const tmpFileIn = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    const tmpFileOut = path.join(tmpdir(), `${Crypto.randomBytes(6).readUIntLE(0, 6).toString(36)}.webp`)\n    fs.writeFileSync(tmpFileIn, wMedia)\n    if (data) {\n        const img = new webp.Image()\n        const { wra = data.pack_id ? data.pack_id : global.author ? global.author : 'naze-dev', wrb = data.packname ? data.packname : global.packname ? global.packname : 'Bot WhatsApp', wrc = data.author ? data.author : global.author ? global.author : 'Nazedev', wrd = data.categories ? data.categories : [''], wre = data.isAvatar ? data.isAvatar : 0, ...wrf } = data\n        const json = { 'sticker-pack-id': wra, 'sticker-pack-name': wrb, 'sticker-pack-publisher': wrc, 'emojis': wrd, 'is-avatar-sticker': wre, wrf };\n        const exifAttr = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00])\n        const jsonBuff = Buffer.from(JSON.stringify(json), 'utf-8')\n        const exif = Buffer.concat([exifAttr, jsonBuff])\n        exif.writeUIntLE(jsonBuff.length, 14, 4)\n        await img.load(tmpFileIn)\n        fs.unlinkSync(tmpFileIn)\n        img.exif = exif\n        await img.save(tmpFileOut)\n        return tmpFileOut\n    }\n}\n\n\nmodule.exports = { imageToWebp, videoToWebp, writeExif, gifToWebp }\n","path":null,"size_bytes":5036,"size_tokens":null},"source-2/lib/tikSnap.js":{"content":"const axios = require('axios');\nconst { CookieJar } = require('tough-cookie');\nconst wrapper = require('axios-cookiejar-support').wrapper;\nconst cheerio = require('cheerio');\n\nclass SavetikAPI {\n  constructor() {\n    this.cookieJar = new CookieJar();\n    this.client = wrapper(axios.create({\n      jar: this.cookieJar,\n      withCredentials: true\n    }));\n    this.csrfToken = \"\";\n    this.userAgent = \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Mobile Safari/537.36\";\n  }\n  \n  async fetchCsrfToken(url) {\n    try {\n      const response = await this.client.get(url, {\n        headers: { \"user-agent\": this.userAgent }\n      });\n      \n      const csrfMatch = response.data.match(/<meta name=\"csrf-token\" content=\"([^\"]+)\">/);\n      if (csrfMatch && csrfMatch[1]) {\n        this.csrfToken = csrfMatch[1];\n      } else {\n        const cookieString = await this.cookieJar.getCookieString(url);\n        const csrfCookieMatch = /XSRF-TOKEN=([^;]+)/.exec(cookieString);\n        if (csrfCookieMatch && csrfCookieMatch[1]) {\n          this.csrfToken = decodeURIComponent(csrfCookieMatch[1]);\n        }\n      }\n    } catch (error) {\n      console.error(\"Error fetching CSRF token:\", error);\n      throw error;\n    }\n  }\n  \n  async ajaxSearch(url, videoUrl) {\n    try {\n      if (!this.csrfToken) {\n        await this.fetchCsrfToken(\"https://savetik.co/vi/douyin-downloader\");\n      }\n      \n      const response = await this.client.post(url, `q=${encodeURIComponent(videoUrl)}&lang=vi&cftoken=${this.csrfToken}`, {\n        headers: {\n          \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n          \"user-agent\": this.userAgent,\n          \"x-requested-with\": \"XMLHttpRequest\"\n        }\n      });\n      \n      const $ = cheerio.load(response.data.data);\n      const videoTitle = $(\"div.video-data h3\").text().trim();\n      const thumbnailUrl = $(\"div.thumbnail img\").attr(\"src\");\n      const downloadLinks = $(\"div.dl-action a\").map((index, element) => {\n        return {\n          text: $(element).text().trim(),\n          link: $(element).attr(\"href\")\n        };\n      }).get();\n      \n      return {\n        status: \"ok\",\n        videoTitle,\n        thumbnailUrl,\n        downloadLinks\n      };\n    } catch (error) {\n      console.error(\"Error in ajaxSearch:\", error);\n      throw error;\n    }\n  }\n  \n  async download({ url: videoUrl }) {\n    try {\n      const searchResult = await this.ajaxSearch(\"https://savetik.co/api/ajaxSearch\", videoUrl);\n      return searchResult;\n    } catch (error) {\n      console.error(\"Error during search and download:\", error);\n      throw error;\n    }\n  }\n}\n\nmodule.exports = SavetikAPI;","path":null,"size_bytes":2684,"size_tokens":null},"source-2/lib/handlers/messageHandler.js":{"content":"const { tiktokRegex, douyinRegex, prefixes, commands } = require('../../config.js');\nconst { logger } = require('../utils/logger.js');\nconst { handleStickerCommand } = require('./stickerHandler.js');\nconst { handleTiktokUrl } = require('./tiktokHandler.js');\nconst { handleDouyinUrl } = require('./douyinHandler.js');\nconst { handleBotInfo, handlePing } = require('./infoHandler');\n\nfunction extractCommand(text) {\n    if (!text) return null;\n    \n    for (const prefix of prefixes) {\n        if (text.startsWith(prefix)) {\n            const cmd = text.slice(prefix.length).trim().split(/\\s+/)[0].toLowerCase();\n            \n            // Check command aliases\n            for (const [mainCmd, aliases] of Object.entries(commands)) {\n                if (aliases.includes(cmd)) {\n                    return {\n                        prefix,\n                        command: mainCmd,\n                        args: text.slice(prefix.length + cmd.length).trim()\n                    };\n                }\n            }\n            \n            // Check if it's a direct command\n            if (commands[cmd]) {\n                return {\n                    prefix,\n                    command: cmd,\n                    args: text.slice(prefix.length + cmd.length).trim()\n                };\n            }\n        }\n    }\n    \n    return null;\n}\n\nasync function handleMessages(conn, messages) {\n    const m = messages[0];\n    if (!m?.message) return;\n\n    // Auto-read message immediately\n    try {\n        await conn.readMessages([m.key]);\n        logger.outgoing(`‚úì Marked message as read from ${m.pushName || 'Unknown'}`);\n    } catch (err) {\n        logger.error(`Failed to mark as read: ${err.message}`);\n    }\n\n    const messageType = Object.keys(m.message)[0];\n    const sender = m.pushName || 'Unknown';\n    const chatType = m.key.remoteJid.endsWith('@g.us') ? 'Group' : 'Private';\n    const text = m.message.conversation || m.message.extendedTextMessage?.text || '';\n\n    logger.incoming(`\\nüì• ${chatType} Message from ${sender}`);\n    logger.incoming(`‚îú‚îÄ Type: ${messageType}`);\n    if (text) logger.incoming(`‚îî‚îÄ Content: ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`);\n\n    // Check for commands\n    const cmdData = extractCommand(text);\n    if (cmdData) {\n        switch (cmdData.command) {\n            case 'sticker':\n                await handleStickerCommand(conn, m, cmdData.args);\n                return;\n            case 'ping':\n                await handlePing(conn, m);\n                return;\n            case 'info':\n                await handleBotInfo(conn, m);\n                return;\n        }\n    }\n\n    // Handle TikTok/Douyin URLs (with or without command)\n    const tiktokUrls = text.match(tiktokRegex) || [];\n    const douyinUrls = text.match(douyinRegex) || [];\n    const allUrls = [...tiktokUrls, ...douyinUrls];\n\n    if (allUrls.length === 0) return;\n\n    logger.info(`üîç Found ${allUrls.length} TikTok/Douyin URL(s)`);\n    await conn.sendMessage(m.key.remoteJid, { text: '‚è≥ Processing video links...' });\n\n    for (const url of allUrls) {\n        try {\n            const isDouyin = douyinRegex.test(url);\n            if (isDouyin) {\n                logger.info(`üé• Processing Douyin URL: ${url.substring(0, 30)}...`);\n                await handleDouyinUrl(conn, m, url);\n            } else {\n                logger.info(`üé¨ Processing TikTok URL: ${url.substring(0, 30)}...`);\n                await handleTiktokUrl(conn, m, url);\n            }\n            \n            // Mark as read again after processing\n            await conn.readMessages([m.key]);\n        } catch (err) {\n            logger.error(`‚ùå Download error: ${err.message}`);\n            await conn.sendMessage(m.key.remoteJid, { \n                text: '‚ùå Failed to process this link. Please try another one.'\n            });\n        }\n    }\n}\n\nmodule.exports = {\n    handleMessages,\n    extractCommand\n};","path":null,"size_bytes":3931,"size_tokens":null},"source-1/lib/template_menu.js":{"content":"const fs = require('fs')\r\nconst chalk = require('chalk');\r\nconst moment = require('moment-timezone');\r\nconst { pickRandom } = require('./function');\r\n\r\nasync function setTemplateMenu(naze, type, m, prefix, setv, db, options = {}) {\r\n\tconst hari = moment.tz('Asia/Jakarta').locale('id').format('dddd');\r\n\tconst tanggal = moment.tz('Asia/Jakarta').locale('id').format('DD/MM/YYYY');\r\n\tconst jam = moment.tz('Asia/Jakarta').locale('id').format('HH:mm:ss');\r\n\tconst ucapanWaktu = jam < '05:00:00' ? 'Selamat Pagi üåâ' : jam < '11:00:00' ? 'Selamat Pagi üåÑ' : jam < '15:00:00' ? 'Selamat Siang üèô' : jam < '18:00:00' ? 'Selamat Sore üåÖ' : jam < '19:00:00' ? 'Selamat Sore üåÉ' : jam < '23:59:00' ? 'Selamat Malam üåå' : 'Selamat Malam üåå';\r\n\t\r\n\tlet total = Object.entries(db.hit).sort((a, b) => b[1] - a[1]).slice(0, Math.min(7, Object.keys(db.hit).length)).filter(([command]) => command !== 'totalcmd' && command !== 'todaycmd').slice(0, 5);\r\n\t\r\n\tlet text = `‚ï≠‚îÄ‚îÄ‚ùç„Äå *TOP MENU* „Äç‚ùç\\n`\r\n\t\r\n\tif (total && total.length >= 5) {\r\n\t\ttotal.forEach(([command, hit], index) => {\r\n\t\t\ttext += `‚îÇ${setv} ${prefix}${command}: ${hit} hits\\n`\r\n\t\t})\r\n\t\ttext += '‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç'\r\n\t} else text += `‚îÇ${setv} ${prefix}ai\r\n‚îÇ${setv} ${prefix}brat\r\n‚îÇ${setv} ${prefix}tiktok\r\n‚îÇ${setv} ${prefix}cekmati\r\n‚îÇ${setv} ${prefix}susunkata\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç`\r\n\r\n\tif (type == 1 || type == 'buttonMessage') {\r\n\t\tawait naze.sendButtonMsg(m.chat, {\r\n\t\t\ttext: `Halo @${m.sender.split('@')[0]}\\n` + text,\r\n\t\t\tfooter: ucapanWaktu,\r\n\t\t\tmentions: [m.sender],\r\n\t\t\tcontextInfo: {\r\n\t\t\t\tforwardingScore: 10,\r\n\t\t\t\tisForwarded: true,\r\n\t\t\t},\r\n\t\t\tbuttons: [{\r\n\t\t\t\tbuttonId: `${prefix}allmenu`,\r\n\t\t\t\tbuttonText: { displayText: 'All Menu' },\r\n\t\t\t\ttype: 1\r\n\t\t\t},{\r\n\t\t\t\tbuttonId: `${prefix}sc`,\r\n\t\t\t\tbuttonText: { displayText: 'SC' },\r\n\t\t\t\ttype: 1\r\n\t\t\t}]\r\n\t\t}, { quoted: m })\r\n\t} else if (type == 2 || type == 'listMessage') {\r\n\t\tawait naze.sendButtonMsg(m.chat, {\r\n\t\t\ttext: `Halo @${m.sender.split('@')[0]}\\n` + text,\r\n\t\t\tfooter: ucapanWaktu,\r\n\t\t\tmentions: [m.sender],\r\n\t\t\tcontextInfo: {\r\n\t\t\t\tforwardingScore: 10,\r\n\t\t\t\tisForwarded: true,\r\n\t\t\t},\r\n\t\t\tbuttons: [{\r\n\t\t\t\tbuttonId: `${prefix}allmenu`,\r\n\t\t\t\tbuttonText: { displayText: 'All Menu' },\r\n\t\t\t\ttype: 1\r\n\t\t\t},{\r\n\t\t\t\tbuttonId: `${prefix}sc`,\r\n\t\t\t\tbuttonText: { displayText: 'SC' },\r\n\t\t\t\ttype: 1\r\n\t\t\t}, {\r\n\t\t\t\tbuttonId: 'list_button',\r\n\t\t\t\tbuttonText: { displayText: 'list' },\r\n\t\t\t\tnativeFlowInfo: {\r\n\t\t\t\t\tname: 'single_select',\r\n\t\t\t\t\tparamsJson: JSON.stringify({\r\n\t\t\t\t\t\ttitle: 'List Menu',\r\n\t\t\t\t\t\tsections: [{\r\n\t\t\t\t\t\t\ttitle: 'List Menu',\r\n\t\t\t\t\t\t\trows: [{\r\n\t\t\t\t\t\t\t\ttitle: 'All Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}allmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Bot Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}botmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Group Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}groupmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Search Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}searchmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Download Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}downloadmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Quotes Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}quotesmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Tools Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}toolsmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Ai Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}aimenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Stalker Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}stalkermenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Random Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}randommenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Anime Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}animemenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Game Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}gamemenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Fun Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}funmenu`\r\n\t\t\t\t\t\t\t},{\r\n\t\t\t\t\t\t\t\ttitle: 'Owner Menu',\r\n\t\t\t\t\t\t\t\tid: `${prefix}ownermenu`\r\n\t\t\t\t\t\t\t}]\r\n\t\t\t\t\t\t}]\r\n\t\t\t\t\t})\r\n\t\t\t\t},\r\n\t\t\t\ttype: 2\r\n\t\t\t}]\r\n\t\t}, { quoted: m })\r\n\t} else if (type == 3 || type == 'documentMessage') {\r\n\t\tlet profile\r\n\t\ttry {\r\n\t\t\tprofile = await naze.profilePictureUrl(m.sender, 'image');\r\n\t\t} catch (e) {\r\n\t\t\tprofile = fake.anonim\r\n\t\t}\r\n\t\tconst menunya = `\r\n‚ï≠‚îÄ‚îÄ‚ùç„Äå *USER INFO* „Äç‚ùç\r\n‚îú *Nama* : ${m.pushName ? m.pushName : 'Tanpa Nama'}\r\n‚îú *Id* : @${m.sender.split('@')[0]}\r\n‚îú *User* : ${options.isVip ? 'VIP' : options.isPremium ? 'PREMIUM' : 'FREE'}\r\n‚îú *Limit* : ${options.isVip ? 'VIP' : db.users[m.sender].limit }\r\n‚îú *Uang* : ${db.users[m.sender] ? db.users[m.sender].money.toLocaleString('id-ID') : '0'}\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *BOT INFO* „Äç‚ùç\r\n‚îú *Nama Bot* : ${db?.set?.[options.botNumber]?.botname || 'Naze Bot'}\r\n‚îú *Powered* : @${'0@s.whatsapp.net'.split('@')[0]}\r\n‚îú *Owner* : @${owner[0].split('@')[0]}\r\n‚îú *Mode* : ${naze.public ? 'Public' : 'Self'}\r\n‚îú *Prefix* :${db.set[options.botNumber].multiprefix ? '„Äå MULTI-PREFIX „Äç' : ' *'+prefix+'*' }\r\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\r\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *ABOUT* „Äç‚ùç\r\n‚îú *Tanggal* : ${tanggal}\r\n‚îú *Hari* : ${hari}\r\n‚îú *Jam* : ${jam} WIB\r\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\\n`\r\n\t\tawait m.reply({\r\n\t\t\tdocument: fake.docs,\r\n\t\t\tfileName: ucapanWaktu,\r\n\t\t\tmimetype: pickRandom(fake.listfakedocs),\r\n\t\t\tfileLength: '100000000000000',\r\n\t\t\tpageCount: '999',\r\n\t\t\tcaption: menunya + text,\r\n\t\t\tcontextInfo: {\r\n\t\t\t\tmentionedJid: [m.sender, '0@s.whatsapp.net', owner[0] + '@s.whatsapp.net'],\r\n\t\t\t\tforwardingScore: 10,\r\n\t\t\t\tisForwarded: true,\r\n\t\t\t\tforwardedNewsletterMessageInfo: {\r\n\t\t\t\t\tnewsletterJid: my.ch,\r\n\t\t\t\t\tserverMessageId: null,\r\n\t\t\t\t\tnewsletterName: 'Join For More Info'\r\n\t\t\t\t},\r\n\t\t\t\texternalAdReply: {\r\n\t\t\t\t\ttitle: options.author,\r\n\t\t\t\t\tbody: options.packname,\r\n\t\t\t\t\tshowAdAttribution: false,\r\n\t\t\t\t\tthumbnailUrl: profile,\r\n\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\tpreviewType: 0,\r\n\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\tmediaUrl: my.gh,\r\n\t\t\t\t\tsourceUrl: my.gh,\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t} else if (type == 4 || type == 'videoMessage') {\r\n\t\t//tambahin sendiri :v\r\n\t} else {\r\n\t\tm.reply(`${ucapanWaktu} @${m.sender.split('@')[0]}\\nSilahkan Gunakan ${prefix}allmenu\\nUntuk Melihat Semua Menunya`)\r\n\t}\r\n}\r\n\r\nmodule.exports = setTemplateMenu\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});\r\n","path":null,"size_bytes":6093,"size_tokens":null},"ciel/src/handlers/commands/fun.js":{"content":"const axios = require('axios');\nconst settings = require('../../../config/settings');\nconst { wallpaper, quotesAnime, tiktokStalk, instaStalk, ringtone } = require('../../../lib/scraper');\n\nconst say = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan teks!');\n    m.reply(text);\n};\n\nconst simisimi = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan pesan untuk ngobrol!');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const responses = [\n            'Halo! Apa kabar?',\n            'Hmm, menarik sekali!',\n            'Oh begitu ya...',\n            'Wah, kamu lucu sekali!',\n            'Aku tidak mengerti maksudmu.',\n            'Ceritakan lebih lanjut!',\n            'Hahaha, bisa saja kamu!',\n            'Aku setuju denganmu!',\n            'Wah, serius?',\n            'Keren banget!',\n            'Aku suka caramu berpikir!',\n            'Hmm, aku perlu waktu untuk memikirkannya.',\n            'Kamu membuatku bingung!',\n            'Oke, aku paham sekarang.',\n            'Bagaimana perasaanmu hari ini?'\n        ];\n        \n        const response = responses[Math.floor(Math.random() * responses.length)];\n        m.reply(response);\n    } catch (e) {\n        console.error('Simisimi error:', e);\n        m.reply('Gagal mendapatkan respons!');\n    }\n};\n\nconst simi = simisimi;\n\nconst truth = async (conn, m, {}) => {\n    const truths = [\n        'Apa hal paling memalukan yang pernah kamu lakukan?',\n        'Siapa crush kamu sekarang?',\n        'Apa rahasia terbesar yang kamu simpan?',\n        'Pernahkah kamu berbohong pada orang yang kamu sayang?',\n        'Apa ketakutan terbesarmu?',\n        'Apa mimpi terburukmu?',\n        'Siapa mantan yang paling sulit kamu lupakan?',\n        'Pernah stalking sosmed siapa?',\n        'Apa kebiasaan aneh yang kamu punya?',\n        'Pernah naksir teman sendiri?',\n        'Kapan terakhir kali kamu menangis?',\n        'Apa hal yang membuatmu insecure?',\n        'Pernah cemburu sama siapa?',\n        'Apa yang paling kamu sesali?',\n        'Siapa orang yang paling kamu benci?'\n    ];\n    \n    const random = truths[Math.floor(Math.random() * truths.length)];\n    m.reply(`*üéØ Truth*\\n\\n${random}`);\n};\n\nconst dare = async (conn, m, {}) => {\n    const dares = [\n        'Kirim chat \"Aku kangen\" ke mantan!',\n        'Voice note nyanyikan lagu favorit!',\n        'Kirim selfie tanpa filter!',\n        'Ceritakan hal memalukan di grup!',\n        'Ubah nama WA jadi \"Aku Ganteng/Cantik\" selama 1 jam!',\n        'Kirim pesan \"Aku suka kamu\" ke crush!',\n        'Voice note tertawa selama 30 detik!',\n        'Jadi budak orang yang nge-dare selama 5 menit!',\n        'Kirim foto gallery ke-13!',\n        'Roasting admin grup!',\n        'Kirim stiker terakhir yang kamu simpan!',\n        'Panggil semua member grup \"kakak\"!',\n        'Buat status tentang dirimu!',\n        'Kirim voice note nyanyi lagu anak-anak!',\n        'Ganti foto profil jadi foto absurd selama 1 jam!'\n    ];\n    \n    const random = dares[Math.floor(Math.random() * dares.length)];\n    m.reply(`*üî• Dare*\\n\\n${random}`);\n};\n\nconst tod = async (conn, m, {}) => {\n    const type = Math.random() < 0.5 ? 'truth' : 'dare';\n    if (type === 'truth') {\n        await truth(conn, m, {});\n    } else {\n        await dare(conn, m, {});\n    }\n};\n\nconst truthordare = tod;\n\nconst joke = async (conn, m, {}) => {\n    const jokes = [\n        'Kenapa kucing bisa menang lomba lari? Karena dia punya 4 kaki!',\n        'Apa bedanya maling sama programmer? Maling ngambil duit, programmer ngambil kopi!',\n        'Kenapa matematika sedih? Karena punya banyak masalah!',\n        'Hewan apa yang paling pintar? Owl! Karena dia professor!',\n        'Apa makanan favorit hantu? Spookghetti!',\n        'Kenapa komputer tidak pernah marah? Karena sudah di-install kesabaran!',\n        'Sayur apa yang paling keren? Terong! Karena ada \"e-rong\" nya!',\n        'Kenapa bulan tidak bisa makan? Karena sudah kenyang dengan bintang!',\n        'Apa bedanya kamu sama kalender? Kalender punya tanggal, kamu nggak!',\n        'Kenapa hujan turun? Karena kalau naik, namanya gerimis!',\n        'Hewan apa yang paling jago matematika? Kelinci! Karena bisa berkali-kali!',\n        'Kenapa semut baris rapi? Karena takut keinjak!',\n        'Apa bahasa Jepangnya nenek jatuh? Obaa-san tsunamida!',\n        'Kenapa meja bisa lari? Karena punya 4 kaki!',\n        'Sayur apa yang dingin? Brrrokoli!'\n    ];\n    \n    const random = jokes[Math.floor(Math.random() * jokes.length)];\n    m.reply(`*üòÇ Joke*\\n\\n${random}`);\n};\n\nconst meme = async (conn, m, {}) => {\n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get('https://meme-api.com/gimme');\n        const memeUrl = response.data.url;\n        \n        const imageBuffer = await axios.get(memeUrl, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, {\n            image: Buffer.from(imageBuffer.data),\n            caption: `*üòÇ Meme*\\n\\n${response.data.title}`\n        }, { quoted: m });\n    } catch (e) {\n        console.error('Meme error:', e);\n        m.reply('Gagal mendapatkan meme!');\n    }\n};\n\nconst quote = async (conn, m, {}) => {\n    const quotes = [\n        { text: 'Hidup itu seperti bersepeda. Untuk menjaga keseimbangan, kamu harus terus bergerak.', author: 'Albert Einstein' },\n        { text: 'Satu-satunya cara untuk melakukan pekerjaan hebat adalah dengan mencintai apa yang kamu lakukan.', author: 'Steve Jobs' },\n        { text: 'Jangan menunggu. Waktu tidak akan pernah tepat.', author: 'Napoleon Hill' },\n        { text: 'Kesuksesan bukanlah kunci kebahagiaan. Kebahagiaan adalah kunci kesuksesan.', author: 'Albert Schweitzer' },\n        { text: 'Masa depan milik mereka yang percaya pada keindahan mimpi-mimpi mereka.', author: 'Eleanor Roosevelt' },\n        { text: 'Semakin keras kamu bekerja, semakin beruntung kamu.', author: 'Gary Player' },\n        { text: 'Jangan biarkan kemarin mengambil terlalu banyak hari ini.', author: 'Will Rogers' },\n        { text: 'Hiduplah seolah-olah kamu akan mati besok. Belajarlah seolah-olah kamu akan hidup selamanya.', author: 'Mahatma Gandhi' },\n        { text: 'Kegagalan adalah kesempatan untuk memulai lagi dengan lebih cerdas.', author: 'Henry Ford' },\n        { text: 'Jadilah perubahan yang ingin kamu lihat di dunia.', author: 'Mahatma Gandhi' }\n    ];\n    \n    const random = quotes[Math.floor(Math.random() * quotes.length)];\n    m.reply(`*üí¨ Quote*\\n\\n\"${random.text}\"\\n\\n‚Äî ${random.author}`);\n};\n\nconst motivasi = quote;\n\nconst fakta = async (conn, m, {}) => {\n    const facts = [\n        'Sidik jari koala 95% mirip dengan manusia!',\n        'Madu tidak akan pernah basi!',\n        'Jantung manusia berdetak lebih dari 100.000 kali sehari!',\n        'Lumba-lumba tidur dengan satu mata terbuka!',\n        'Lebah bisa terbang lebih tinggi dari Gunung Everest!',\n        'Octopus memiliki 3 jantung!',\n        'Kuda nil mengeluarkan keringat berwarna merah!',\n        'Lidah manusia adalah otot terkuat di tubuh!',\n        'Gajah adalah satu-satunya hewan yang tidak bisa melompat!',\n        'Wortel awalnya berwarna ungu, bukan oranye!',\n        'Laba-laba tidak bisa terbang tapi bisa menggunakan jaring untuk melayang!',\n        'Kucing menghabiskan 70% hidupnya untuk tidur!',\n        'Mata burung unta lebih besar dari otaknya!',\n        'Pisang termasuk buah berry, tapi strawberry bukan!',\n        'Air laut mengandung emas sekitar 20 juta ton!'\n    ];\n    \n    const random = facts[Math.floor(Math.random() * facts.length)];\n    m.reply(`*üß† Fakta Unik*\\n\\n${random}`);\n};\n\nconst fact = fakta;\n\nconst ship = async (conn, m, {}) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    \n    const participants = m.metadata.participants;\n    if (participants.length < 2) return m.reply('Minimal 2 member di grup!');\n    \n    const shuffled = [...participants].sort(() => Math.random() - 0.5);\n    const person1 = shuffled[0].id;\n    const person2 = shuffled[1].id;\n    \n    const percentage = Math.floor(Math.random() * 101);\n    \n    let status;\n    if (percentage >= 80) status = '‚ù§Ô∏è Perfect Match!';\n    else if (percentage >= 60) status = 'üíï Great Match!';\n    else if (percentage >= 40) status = 'üíì Good Match!';\n    else if (percentage >= 20) status = 'üíî Not Bad!';\n    else status = 'üíî Better as Friends!';\n    \n    m.reply(`*üíò Love Ship*\n\n@${person1.split('@')[0]} ‚ù§Ô∏è @${person2.split('@')[0]}\n\nCompatibility: ${percentage}%\n${status}\n\n${'‚ñà'.repeat(Math.floor(percentage / 10))}${'‚ñë'.repeat(10 - Math.floor(percentage / 10))}`, { mentions: [person1, person2] });\n};\n\nconst couple = ship;\n\nconst gay = async (conn, m, {}) => {\n    const target = m.mentionedJid[0] || m.quoted?.sender || m.sender;\n    const percentage = Math.floor(Math.random() * 101);\n    \n    let emoji;\n    if (percentage >= 80) emoji = 'üè≥Ô∏è‚Äçüåà';\n    else if (percentage >= 50) emoji = 'üò≥';\n    else emoji = 'üòé';\n    \n    m.reply(`*${emoji} Gay Meter*\n\n@${target.split('@')[0]}: ${percentage}% Gay\n\n${'‚ñà'.repeat(Math.floor(percentage / 10))}${'‚ñë'.repeat(10 - Math.floor(percentage / 10))}`, { mentions: [target] });\n};\n\nconst lesbi = async (conn, m, {}) => {\n    const target = m.mentionedJid[0] || m.quoted?.sender || m.sender;\n    const percentage = Math.floor(Math.random() * 101);\n    \n    let emoji;\n    if (percentage >= 80) emoji = 'üè≥Ô∏è‚Äçüåà';\n    else if (percentage >= 50) emoji = 'üò≥';\n    else emoji = 'üòé';\n    \n    m.reply(`*${emoji} Lesbi Meter*\n\n@${target.split('@')[0]}: ${percentage}% Lesbi\n\n${'‚ñà'.repeat(Math.floor(percentage / 10))}${'‚ñë'.repeat(10 - Math.floor(percentage / 10))}`, { mentions: [target] });\n};\n\nconst ganteng = async (conn, m, {}) => {\n    const target = m.mentionedJid[0] || m.quoted?.sender || m.sender;\n    const percentage = Math.floor(Math.random() * 101);\n    \n    let emoji;\n    if (percentage >= 80) emoji = 'üòç';\n    else if (percentage >= 50) emoji = 'üòä';\n    else emoji = 'üòÖ';\n    \n    m.reply(`*${emoji} Ganteng Meter*\n\n@${target.split('@')[0]}: ${percentage}% Ganteng\n\n${'‚ñà'.repeat(Math.floor(percentage / 10))}${'‚ñë'.repeat(10 - Math.floor(percentage / 10))}`, { mentions: [target] });\n};\n\nconst cantik = async (conn, m, {}) => {\n    const target = m.mentionedJid[0] || m.quoted?.sender || m.sender;\n    const percentage = Math.floor(Math.random() * 101);\n    \n    let emoji;\n    if (percentage >= 80) emoji = 'üòç';\n    else if (percentage >= 50) emoji = 'üòä';\n    else emoji = 'üòÖ';\n    \n    m.reply(`*${emoji} Cantik Meter*\n\n@${target.split('@')[0]}: ${percentage}% Cantik\n\n${'‚ñà'.repeat(Math.floor(percentage / 10))}${'‚ñë'.repeat(10 - Math.floor(percentage / 10))}`, { mentions: [target] });\n};\n\nconst iq = async (conn, m, {}) => {\n    const target = m.mentionedJid[0] || m.quoted?.sender || m.sender;\n    const iqScore = Math.floor(Math.random() * 150) + 50;\n    \n    let status;\n    if (iqScore >= 180) status = 'üß† Genius!';\n    else if (iqScore >= 140) status = 'üéì Very Superior';\n    else if (iqScore >= 120) status = 'üìö Superior';\n    else if (iqScore >= 110) status = 'üìñ High Average';\n    else if (iqScore >= 90) status = 'üìó Average';\n    else if (iqScore >= 80) status = 'üìï Low Average';\n    else status = 'üòÖ Below Average';\n    \n    m.reply(`*üß† IQ Test*\n\n@${target.split('@')[0]}: ${iqScore} IQ\n${status}`, { mentions: [target] });\n};\n\nconst cekmati = async (conn, m, {}) => {\n    const target = m.mentionedJid[0] || m.quoted?.sender || m.sender;\n    \n    const causes = [\n        'keselek biji durian',\n        'jatuh dari kasur',\n        'kena serangan jomblo akut',\n        'overdosis micin',\n        'ditinggal pacar',\n        'kehabisan kuota internet',\n        'baper berkepanjangan',\n        'tertimpa gedung',\n        'kesambet wifi lemot',\n        'dipatuk bebek',\n        'tersedak es batu',\n        'kena serangan mager',\n        'karena terlalu ganteng/cantik',\n        'kebanyakan stalking mantan',\n        'kena karma'\n    ];\n    \n    const years = Math.floor(Math.random() * 80) + 20;\n    const cause = causes[Math.floor(Math.random() * causes.length)];\n    \n    m.reply(`*üíÄ Ramalan Kematian*\n\n@${target.split('@')[0]}\n\nUmur: ${years} tahun\nPenyebab: ${cause}\n\n‚ö†Ô∏è Ini hanya hiburan, jangan ditanggapi serius!`, { mentions: [target] });\n};\n\nconst randomnumber = async (conn, m, { args }) => {\n    const min = parseInt(args[0]) || 1;\n    const max = parseInt(args[1]) || 100;\n    \n    if (min >= max) return m.reply('Angka pertama harus lebih kecil dari angka kedua!');\n    \n    const random = Math.floor(Math.random() * (max - min + 1)) + min;\n    m.reply(`*üé≤ Random Number*\\n\\nRange: ${min} - ${max}\\nHasil: ${random}`);\n};\n\nconst random = randomnumber;\n\nconst choose = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan pilihan dipisah dengan \" atau \" atau \",\"!\\nContoh: .choose makan atau tidur');\n    \n    const choices = text.split(/ atau |,/).map(c => c.trim()).filter(c => c);\n    if (choices.length < 2) return m.reply('Minimal 2 pilihan!');\n    \n    const chosen = choices[Math.floor(Math.random() * choices.length)];\n    m.reply(`*ü§î Choose*\\n\\nPilihan: ${choices.join(', ')}\\n\\nJawaban: ${chosen}`);\n};\n\nconst pilih = choose;\n\nconst eightball = async (conn, m, { text }) => {\n    if (!text) return m.reply('Ajukan pertanyaan!\\nContoh: .8ball apakah aku ganteng?');\n    \n    const answers = [\n        'Ya, pasti!',\n        'Tentu saja!',\n        'Tanpa keraguan!',\n        'Kemungkinan besar iya.',\n        'Sepertinya iya.',\n        'Mungkin.',\n        'Tidak yakin, coba lagi.',\n        'Lebih baik tidak memberitahu sekarang.',\n        'Tidak bisa diprediksi.',\n        'Fokus dan tanya lagi.',\n        'Jangan andalkan itu.',\n        'Jawabanku adalah tidak.',\n        'Sumber saya mengatakan tidak.',\n        'Prospeknya tidak bagus.',\n        'Sangat meragukan.'\n    ];\n    \n    const answer = answers[Math.floor(Math.random() * answers.length)];\n    m.reply(`*üé± 8Ball*\\n\\nPertanyaan: ${text}\\nJawaban: ${answer}`);\n};\n\nconst ball = eightball;\n\nconst rate = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan sesuatu untuk di-rate!');\n    \n    const rating = Math.floor(Math.random() * 11);\n    const stars = '‚≠ê'.repeat(rating) + '‚òÜ'.repeat(10 - rating);\n    \n    m.reply(`*üìä Rate*\\n\\n${text}\\n\\n${stars}\\n${rating}/10`);\n};\n\nconst wp = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan keyword pencarian!\\nContoh: .wallpaper anime');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const result = await wallpaper(text);\n        \n        if (!result || !result.length) {\n            return m.reply('Wallpaper tidak ditemukan!');\n        }\n        \n        const randomWp = result[Math.floor(Math.random() * Math.min(result.length, 5))];\n        const imageUrl = randomWp.image?.[0] || randomWp.image;\n        \n        if (!imageUrl) {\n            return m.reply('Wallpaper tidak ditemukan!');\n        }\n        \n        const imageBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, {\n            image: Buffer.from(imageBuffer.data),\n            caption: `*üñºÔ∏è Wallpaper*\\n\\n*Title:* ${randomWp.title || 'Unknown'}`\n        }, { quoted: m });\n    } catch (e) {\n        console.error('Wallpaper error:', e);\n        m.reply('Gagal mencari wallpaper!');\n    }\n};\n\nconst animequote = async (conn, m, {}) => {\n    await m.reply(settings.messages.wait);\n    \n    try {\n        const result = await quotesAnime();\n        \n        if (!result) {\n            return m.reply('Gagal mendapatkan quote anime!');\n        }\n        \n        m.reply(`*üéå Anime Quote*\\n\\n\"${result.content}\"\\n\\n‚Äî ${result.character?.name || 'Unknown'}\\n*Anime:* ${result.anime?.name || 'Unknown'}`);\n    } catch (e) {\n        console.error('Anime quote error:', e);\n        m.reply('Gagal mendapatkan quote anime!');\n    }\n};\n\nconst quoteanime = animequote;\n\nconst ttstalk = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan username TikTok!\\nContoh: .ttstalk username');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const result = await tiktokStalk(text.replace('@', ''));\n        \n        if (!result) {\n            return m.reply('User tidak ditemukan!');\n        }\n        \n        m.reply(`*üìä TikTok Stalk*\n\n*Username:* ${result.author_name || result.username || 'Unknown'}\n*Nickname:* ${result.nickname || '-'}\n*Followers:* ${result.followerCount || 0}\n*Following:* ${result.followingCount || 0}\n*Likes:* ${result.heartCount || 0}\n*Videos:* ${result.videoCount || 0}\n\n*Bio:* ${result.signature || '-'}`);\n    } catch (e) {\n        console.error('TikTok stalk error:', e);\n        m.reply('Gagal stalking user TikTok!');\n    }\n};\n\nconst tikstalk = ttstalk;\n\nconst igstalk = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan username Instagram!\\nContoh: .igstalk username');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const result = await instaStalk(text.replace('@', ''));\n        \n        if (!result) {\n            return m.reply('User tidak ditemukan!');\n        }\n        \n        m.reply(`*üìä Instagram Stalk*\n\n*Username:* ${result.username || 'Unknown'}\n*Nickname:* ${result.nickname || '-'}\n*Followers:* ${result.followers || 0}\n*Following:* ${result.following || 0}\n*Posts:* ${result.posts || 0}\n\n*Bio:* ${result.description || '-'}`);\n    } catch (e) {\n        console.error('Instagram stalk error:', e);\n        m.reply('Gagal stalking user Instagram!');\n    }\n};\n\nconst instastalk = igstalk;\n\nmodule.exports = {\n    say,\n    simisimi,\n    simi,\n    truth,\n    dare,\n    tod,\n    truthordare,\n    joke,\n    meme,\n    quote,\n    motivasi,\n    fakta,\n    fact,\n    ship,\n    couple,\n    gay,\n    lesbi,\n    ganteng,\n    cantik,\n    iq,\n    cekmati,\n    randomnumber,\n    random,\n    choose,\n    pilih,\n    eightball,\n    '8ball': eightball,\n    ball,\n    rate,\n    wallpaper: wp,\n    wp,\n    animequote,\n    quoteanime,\n    ttstalk,\n    tikstalk,\n    igstalk,\n    instastalk\n};\n","path":null,"size_bytes":18196,"size_tokens":null},"source-1/lib/uploader.js":{"content":"const fs = require('fs');\nconst axios = require('axios');\nconst cheerio = require('cheerio');\nconst fetch = require('node-fetch');\nconst FormData = require('form-data');\nconst { fromBuffer } = require('file-type');\n\nasync function TelegraPh(buffer) {\n\treturn new Promise (async (resolve, reject) => {\n\t\ttry {\n\t\t\tconst form = new FormData();\n\t\t\tconst input = Buffer.from(buffer);\n\t\t\tconst { ext } = await fromBuffer(buffer);\n\t\t\tform.append('file', input, { filename: 'data.' + ext });\n\t\t\tconst data = await axios.post('https://telegra.ph/upload', form, {\n\t\t\t\theaders: {\n\t\t\t\t\t...form.getHeaders()\n\t\t\t\t}\n\t\t\t})\n\t\t\tresolve('https://telegra.ph' + data.data[0].src)\n\t\t} catch (e) {\n\t\t\treject(e)\n\t\t}\n\t})\n}\n\nasync function UguuSe(buffer) {\n\treturn new Promise (async (resolve, reject) => {\n\t\ttry {\n\t\t\tconst form = new FormData();\n\t\t\tconst input = Buffer.from(buffer);\n\t\t\tconst { ext } = await fromBuffer(buffer);\n\t\t\tform.append('files[]', input, { filename: 'data.' + ext });\n\t\t\tconst data = await axios.post('https://uguu.se/upload.php', form, {\n\t\t\t\theaders: {\n\t\t\t\t\t...form.getHeaders()\n\t\t\t\t}\n\t\t\t})\n\t\t\tresolve(data.data.files[0])\n\t\t} catch (e) {\n\t\t\treject(e)\n\t\t}\n\t})\n}\n\nasync function webp2mp4File(path) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst form = new FormData();\n\t\t form.append('new-image-url', '')\n\t\t form.append('new-image', fs.createReadStream(path))\n\t\t axios({\n\t\t\t  method: 'post',\n\t\t\t  url: 'https://s6.ezgif.com/webp-to-mp4',\n\t\t\t  data: form,\n\t\t\t  headers: {\n\t\t\t\t   'Content-Type': `multipart/form-data; boundary=${form._boundary}`\n\t\t\t  }\n\t\t }).then(({ data }) => {\n\t\t\t  const FormDataThen = new FormData()\n\t\t\t  const $ = cheerio.load(data)\n\t\t\t  const file = $('input[name=\"file\"]').attr('value')\n\t\t\t  FormDataThen.append('file', file)\n\t\t\t  FormDataThen.append('convert', \"Convert WebP to MP4!\")\n\t\t\t  axios({\n\t\t\t\t   method: 'post',\n\t\t\t\t   url: 'https://ezgif.com/webp-to-mp4/' + file,\n\t\t\t\t   data: FormDataThen,\n\t\t\t\t   headers: {\n\t\t\t\t\t\t'Content-Type': `multipart/form-data; boundary=${FormDataThen._boundary}`\n\t\t\t\t   }\n\t\t\t  }).then(({ data }) => {\n\t\t\t\t   const $ = cheerio.load(data)\n\t\t\t\t   const result = 'https:' + $('div#output > p.outfile > video > source').attr('src')\n\t\t\t\t   resolve({\n\t\t\t\t\t\tstatus: true,\n\t\t\t\t\t\tmessage: \"Created By MRHRTZ\",\n\t\t\t\t\t\tresult: result\n\t\t\t\t   })\n\t\t\t  }).catch(reject)\n\t\t }).catch(reject)\n\t})\n}\n\nmodule.exports = { TelegraPh, UguuSe, webp2mp4File }\n","path":null,"size_bytes":2395,"size_tokens":null},"ciel/src/utils/antiSpam.js":{"content":"class AntiSpam {\n    constructor(cooldownMs = 5000) {\n        this.users = new Map();\n        this.cooldown = cooldownMs;\n    }\n    \n    isFiltered(userId) {\n        const now = Date.now();\n        const lastTime = this.users.get(userId);\n        \n        if (lastTime && now - lastTime < this.cooldown) {\n            return true;\n        }\n        return false;\n    }\n    \n    addFilter(userId) {\n        this.users.set(userId, Date.now());\n    }\n    \n    removeFilter(userId) {\n        this.users.delete(userId);\n    }\n    \n    clear() {\n        this.users.clear();\n    }\n    \n    cleanup() {\n        const now = Date.now();\n        for (const [userId, lastTime] of this.users.entries()) {\n            if (now - lastTime > this.cooldown * 2) {\n                this.users.delete(userId);\n            }\n        }\n    }\n}\n\nconst antiSpam = new AntiSpam(5000);\n\nsetInterval(() => {\n    antiSpam.cleanup();\n}, 60000);\n\nmodule.exports = { antiSpam, AntiSpam };\n","path":null,"size_bytes":957,"size_tokens":null},"source-1/lib/pixiv.js":{"content":"const { URL_REGEX } = require('baileys');\nconst { Pixiv } = require ( '@ibaraki-douji/pixivts');\nconst pixiv = new Pixiv();\n\n\nasync function pixivdl(query) {\n\tif (query.match(URL_REGEX)) {\n\t\tif (!/https:\\/\\/www.pixiv.net\\/en\\/artworks\\/[0-9]+/i.test(query)) throw 'Invalid Pixiv Url'\n\t\tquery = query.replace(/\\D/g, '')\n\t\tlet res = await pixiv.getIllustByID(query).catch(() => null)\n\t\tif (!res) throw `ID \"${query}\" not found :/`\n\t\tlet media = []\n\t\tfor (let x = 0; x < res.urls.length; x++) media.push(await pixiv.download(new URL(res.urls[x].original)))\n\t\treturn {\n\t\t\tartist: res.user.name, caption: res.title, tags: res.tags.tags.map(v => v.tag), media\n\t\t}\n\t} else {\n\t\tlet res = await pixiv.getIllustsByTag(query)\n\t\tif (!res.length) throw `Tag's \"${query}\" not found :/`\n\t\tres = res[~~(Math.random() * res.length)].id\n\t\tres = await pixiv.getIllustByID(res)\n\t\tlet media = []\n\t\tfor (let x = 0; x < res.urls.length; x++) media.push(await pixiv.download(new URL(res.urls[x].original)))\n\t\treturn {\n\t\t\tartist: res.user.name, caption: res.title, tags: res.tags.tags.map(v => v.tag), media\n\t\t}\n\t}\n}\n\nmodule.exports = { pixivdl }","path":null,"size_bytes":1121,"size_tokens":null},"source-1/index.js":{"content":"require('./settings');\r\nconst fs = require('fs');\r\nconst os = require('os');\r\nconst pino = require('pino');\r\nconst path = require('path');\r\nconst axios = require('axios');\r\nconst chalk = require('chalk');\r\nconst readline = require('readline');\r\nconst { Boom } = require('@hapi/boom');\r\nconst qrcode = require('qrcode-terminal');\r\nconst NodeCache = require('node-cache');\r\nconst { toBuffer, toDataURL } = require('qrcode');\r\nconst { exec, spawn, execSync } = require('child_process');\r\nconst { parsePhoneNumber } = require('awesome-phonenumber');\r\nconst { default: WAConnection, useMultiFileAuthState, Browsers, DisconnectReason, makeInMemoryStore, makeCacheableSignalKeyStore, fetchLatestBaileysVersion, proto, jidNormalizedUser, getAggregateVotesInPollMessage } = require('baileys');\r\n\r\nconst { dataBase } = require('./src/database');\r\nconst { app, server, PORT } = require('./src/server');\r\nconst { GroupParticipantsUpdate, MessagesUpsert, Solving } = require('./src/message');\r\nconst { isUrl, generateMessageTag, getBuffer, getSizeMedia, fetchJson, assertInstalled, sleep } = require('./lib/function');\r\n\r\nconst print = (label, value) => console.log(`${chalk.green.bold('‚ïë')} ${chalk.cyan.bold(label.padEnd(16))}${chalk.yellow.bold(':')} ${value}`);\r\nconst pairingCode = process.argv.includes('--qr') ? false : process.argv.includes('--pairing-code') || global.pairing_code;\r\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout })\r\nconst question = (text) => new Promise((resolve) => rl.question(text, resolve))\r\nlet pairingStarted = false;\r\nlet phoneNumber;\r\n\r\nconst userInfoSyt = () => {\r\n\ttry {\r\n\t\treturn os.userInfo().username\r\n\t} catch (e) {\r\n\t\treturn process.env.USER || process.env.USERNAME || 'unknown';\r\n\t}\r\n}\r\n\r\nglobal.fetchApi = async (path = '/', query = {}, options) => {\r\n\tconst urlnya = (options?.name || options ? ((options?.name || options) in global.APIs ? global.APIs[(options?.name || options)] : (options?.name || options)) : global.APIs['hitori'] ? global.APIs['hitori'] : (options?.name || options)) + path + (query ? '?' + decodeURIComponent(new URLSearchParams(Object.entries({ ...query }))) : '')\r\n\tconst { data } = await axios.get(urlnya, { ...((options?.name || options) ? {} : { headers: { 'accept': 'application/json', 'x-api-key': global.APIKeys[global.APIs['hitori']]}})})\r\n\treturn data\r\n}\r\n\r\nconst storeDB = dataBase(global.tempatStore);\r\nconst database = dataBase(global.tempatDB);\r\nconst msgRetryCounterCache = new NodeCache();\r\n\r\nassertInstalled(process.platform === 'win32' ? 'where ffmpeg' : 'command -v ffmpeg', 'FFmpeg', 0);\r\n//assertInstalled(process.platform === 'win32' ? 'where magick' : 'command -v convert', 'ImageMagick', 0);\r\nconsole.log(chalk.greenBright('‚úÖ  All external dependencies are satisfied'));\r\nconsole.log(chalk.green.bold(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê[${`${chalk.cyan(userInfoSyt())}@${chalk.cyan(os.hostname())}`}]‚ïê‚ïê‚ïê‚ïê‚ïê`));\r\nprint('OS', `${os.platform()} ${os.release()} ${os.arch()}`);\r\nprint('Uptime', `${Math.floor(os.uptime() / 3600)} h ${Math.floor((os.uptime() % 3600) / 60)} m`);\r\nprint('Shell', process.env.SHELL || process.env.COMSPEC || 'unknown');\r\nprint('CPU', os.cpus()[0]?.model.trim() || 'unknown');\r\nprint('Memory', `${(os.freemem()/1024/1024).toFixed(0)} MiB / ${(os.totalmem()/1024/1024).toFixed(0)} MiB`);\r\nprint('Script version', `v${require('./package.json').version}`);\r\nprint('Node.js', process.version);\r\nprint('Baileys', `v${require('./package.json').dependencies.baileys}`);\r\nprint('Date & Time', new Date().toLocaleString('en-US', { timeZone: 'Asia/Jakarta', hour12: false }));\r\nconsole.log(chalk.green.bold('‚ïö' + ('‚ïê'.repeat(30))));\r\nserver.listen(PORT, () => {\r\n\tconsole.log('App listened on port', PORT);\r\n});\r\n\r\n/*\r\n\t* Create By Naze\r\n\t* Follow https://github.com/nazedev\r\n\t* Whatsapp : https://whatsapp.com/channel/0029VaWOkNm7DAWtkvkJBK43\r\n*/\r\n\r\nasync function startNazeBot() {\r\n\tconst { state, saveCreds } = await useMultiFileAuthState('nazedev');\r\n\tconst { version, isLatest } = await fetchLatestBaileysVersion();\r\n\tconst level = pino({ level: 'silent' });\r\n\t\r\n\ttry {\r\n\t\tconst loadData = await database.read()\r\n\t\tconst storeLoadData = await storeDB.read()\r\n\t\tif (!loadData || Object.keys(loadData).length === 0) {\r\n\t\t\tglobal.db = {\r\n\t\t\t\thit: {},\r\n\t\t\t\tset: {},\r\n\t\t\t\tcmd: {},\r\n\t\t\t\tstore: {},\r\n\t\t\t\tusers: {},\r\n\t\t\t\tgame: {},\r\n\t\t\t\tgroups: {},\r\n\t\t\t\tdatabase: {},\r\n\t\t\t\tpremium: [],\r\n\t\t\t\tsewa: [],\r\n\t\t\t\t...(loadData || {}),\r\n\t\t\t}\r\n\t\t\tawait database.write(global.db)\r\n\t\t} else {\r\n\t\t\tglobal.db = loadData\r\n\t\t}\r\n\t\tif (!storeLoadData || Object.keys(storeLoadData).length === 0) {\r\n\t\t\tglobal.store = {\r\n\t\t\t\tcontacts: {},\r\n\t\t\t\tpresences: {},\r\n\t\t\t\tmessages: {},\r\n\t\t\t\tgroupMetadata: {},\r\n\t\t\t\t...(storeLoadData || {}),\r\n\t\t\t}\r\n\t\t\tawait storeDB.write(global.store)\r\n\t\t} else {\r\n\t\t\tglobal.store = storeLoadData\r\n\t\t}\r\n\t\t\r\n\t\tsetInterval(async () => {\r\n\t\t\tif (global.db) await database.write(global.db)\r\n\t\t\tif (global.store) await storeDB.write(global.store)\r\n\t\t}, 30 * 1000)\r\n\t} catch (e) {\r\n\t\tconsole.log(e)\r\n\t\tprocess.exit(1)\r\n\t}\r\n\t\r\n\tstore.loadMessage = function (remoteJid, id) {\r\n\t\tconst messages = store.messages?.[remoteJid]?.array;\r\n\t\tif (!messages) return null;\r\n\t\treturn messages.find(msg => msg?.key?.id === id) || null;\r\n\t}\r\n\t\r\n\tconst getMessage = async (key) => {\r\n\t\tif (store) {\r\n\t\t\tconst msg = await store.loadMessage(key.remoteJid, key.id);\r\n\t\t\treturn msg?.message || ''\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tconversation: 'Halo Saya Naze Bot'\r\n\t\t}\r\n\t}\r\n\t\r\n\tconst naze = WAConnection({\r\n\t\tlogger: level,\r\n\t\tgetMessage,\r\n\t\tsyncFullHistory: true,\r\n\t\tmaxMsgRetryCount: 15,\r\n\t\tmsgRetryCounterCache,\r\n\t\tretryRequestDelayMs: 10,\r\n\t\tdefaultQueryTimeoutMs: 0,\r\n\t\tconnectTimeoutMs: 60000,\r\n\t\tbrowser: Browsers.ubuntu('Chrome'),\r\n\t\tgenerateHighQualityLinkPreview: true,\r\n\t\tshouldSyncHistoryMessage: msg => {\r\n\t\t\tconsole.log(`\\x1b[32mMemuat Chat [${msg.progress || 0}%]\\x1b[39m`);\r\n\t\t\treturn !!msg.syncType;\r\n\t\t},\r\n\t\ttransactionOpts: {\r\n\t\t\tmaxCommitRetries: 10,\r\n\t\t\tdelayBetweenTriesMs: 10,\r\n\t\t},\r\n\t\tappStateMacVerification: {\r\n\t\t\tpatch: true,\r\n\t\t\tsnapshot: true,\r\n\t\t},\r\n\t\tauth: {\r\n\t\t\tcreds: state.creds,\r\n\t\t\tkeys: makeCacheableSignalKeyStore(state.keys, level),\r\n\t\t},\r\n\t})\r\n\t\r\n\tif (pairingCode && !phoneNumber && !naze.authState.creds.registered) {\r\n\t\tasync function getPhoneNumber() {\r\n\t\t\tphoneNumber = global.number_bot ? global.number_bot : process.env.BOT_NUMBER || await question('Please type your WhatsApp number : ');\r\n\t\t\tphoneNumber = phoneNumber.replace(/[^0-9]/g, '')\r\n\t\t\t\r\n\t\t\tif (!parsePhoneNumber('+' + phoneNumber).valid && phoneNumber.length < 6) {\r\n\t\t\t\tconsole.log(chalk.bgBlack(chalk.redBright('Start with your Country WhatsApp code') + chalk.whiteBright(',') + chalk.greenBright(' Example : 62xxx')));\r\n\t\t\t\tawait getPhoneNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t\t(async () => {\r\n\t\t\tawait getPhoneNumber();\r\n\t\t\tawait exec('rm -rf ./nazedev/*');\r\n\t\t\tconsole.log('Phone number captured. Waiting for Connection...\\n' + chalk.blueBright('Estimated time: around 2 ~ 5 minutes'))\r\n\t\t})()\r\n\t}\r\n\t\r\n\tawait Solving(naze, store)\r\n\t\r\n\tnaze.ev.on('creds.update', saveCreds)\r\n\t\r\n\tnaze.ev.on('connection.update', async (update) => {\r\n\t\tconst { qr, connection, lastDisconnect, isNewLogin, receivedPendingNotifications } = update\r\n\t\tif (!naze.authState.creds.registered) console.log('Connection: ', connection || false);\r\n\t\tif ((connection === 'connecting' || !!qr) && pairingCode && phoneNumber && !naze.authState.creds.registered && !pairingStarted) {\r\n\t\t\tsetTimeout(async () => {\r\n\t\t\t\tpairingStarted = true;\r\n\t\t\t\tconsole.log('Requesting Pairing Code...')\r\n\t\t\t\tlet code = await naze.requestPairingCode(phoneNumber);\r\n\t\t\t\tconsole.log(chalk.blue('Your Pairing Code :'), chalk.green(code), '\\n', chalk.yellow('Expires in 15 second'));\r\n\t\t\t}, 3000)\r\n\t\t}\r\n\t\tif (connection === 'close') {\r\n\t\t\tconst reason = new Boom(lastDisconnect?.error)?.output.statusCode\r\n\t\t\tif (reason === DisconnectReason.connectionLost) {\r\n\t\t\t\tconsole.log('Connection to Server Lost, Attempting to Reconnect...');\r\n\t\t\t\tstartNazeBot()\r\n\t\t\t} else if (reason === DisconnectReason.connectionClosed) {\r\n\t\t\t\tconsole.log('Connection closed, Attempting to Reconnect...');\r\n\t\t\t\tstartNazeBot()\r\n\t\t\t} else if (reason === DisconnectReason.restartRequired) {\r\n\t\t\t\tconsole.log('Restart Required...');\r\n\t\t\t\tstartNazeBot()\r\n\t\t\t} else if (reason === DisconnectReason.timedOut) {\r\n\t\t\t\tconsole.log('Connection Timed Out, Attempting to Reconnect...');\r\n\t\t\t\tstartNazeBot()\r\n\t\t\t} else if (reason === DisconnectReason.badSession) {\r\n\t\t\t\tconsole.log('Delete Session and Scan again...');\r\n\t\t\t\tstartNazeBot()\r\n\t\t\t} else if (reason === DisconnectReason.connectionReplaced) {\r\n\t\t\t\tconsole.log('Close current Session first...');\r\n\t\t\t} else if (reason === DisconnectReason.loggedOut) {\r\n\t\t\t\tconsole.log('Scan again and Run...');\r\n\t\t\t\texec('rm -rf ./nazedev/*')\r\n\t\t\t\tprocess.exit(1)\r\n\t\t\t} else if (reason === DisconnectReason.forbidden) {\r\n\t\t\t\tconsole.log('Connection Failure, Scan again and Run...');\r\n\t\t\t\texec('rm -rf ./nazedev/*')\r\n\t\t\t\tprocess.exit(1)\r\n\t\t\t} else if (reason === DisconnectReason.multideviceMismatch) {\r\n\t\t\t\tconsole.log('Scan again...');\r\n\t\t\t\texec('rm -rf ./nazedev/*')\r\n\t\t\t\tprocess.exit(0)\r\n\t\t\t} else {\r\n\t\t\t\tnaze.end(`Unknown DisconnectReason : ${reason}|${connection}`)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (connection == 'open') {\r\n\t\t\tconsole.log('Connected to : ' + JSON.stringify(naze.user, null, 2));\r\n\t\t\tlet botNumber = await naze.decodeJid(naze.user.id);\r\n\t\t\tif (global.db?.set[botNumber] && !global.db?.set[botNumber]?.join) {\r\n\t\t\t\tif (my.ch.length > 0 && my.ch.includes('@newsletter')) {\r\n\t\t\t\t\tif (my.ch) await naze.newsletterMsg(my.ch, { type: 'follow' }).catch(e => {})\r\n\t\t\t\t\tdb.set[botNumber].join = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (qr) {\r\n\t\t\tif (!pairingCode) qrcode.generate(qr, { small: true })\r\n\t\t\tapp.use('/qr', async (req, res) => {\r\n\t\t\t\tres.setHeader('content-type', 'image/png')\r\n\t\t\t\tres.end(await toBuffer(qr))\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (isNewLogin) console.log(chalk.green('New device login detected...'))\r\n\t\tif (receivedPendingNotifications == 'true') {\r\n\t\t\tconsole.log('Please wait About 1 Minute...')\r\n\t\t\tnaze.ev.flush()\r\n\t\t}\r\n\t});\r\n\t\r\n\tnaze.ev.on('contacts.update', (update) => {\r\n\t\tfor (let contact of update) {\r\n\t\t\tlet trueJid;\r\n\t\t\tif (!trueJid) continue;\r\n\t\t\tif (contact.id.endsWith('@lid')) {\r\n\t\t\t\ttrueJid = naze.findJidByLid(contact.id, store);\r\n\t\t\t} else {\r\n\t\t\t\ttrueJid = jidNormalizedUser(contact.id);\r\n\t\t\t}\r\n\t\t\tstore.contacts[trueJid] = {\r\n\t\t\t\t...store.contacts[trueJid],\r\n\t\t\t\tid: trueJid,\r\n\t\t\t\tname: contact.notify\r\n\t\t\t}\r\n\t\t\tif (contact.id.endsWith('@lid')) {\r\n\t\t\t\tstore.contacts[trueJid].lid = jidNormalizedUser(contact.id);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tnaze.ev.on('call', async (call) => {\r\n\t\tlet botNumber = await naze.decodeJid(naze.user.id);\r\n\t\tif (global.db?.set[botNumber]?.anticall) {\r\n\t\t\tfor (let id of call) {\r\n\t\t\t\tif (id.status === 'offer') {\r\n\t\t\t\t\tlet msg = await naze.sendMessage(id.from, { text: `Saat Ini, Kami Tidak Dapat Menerima Panggilan ${id.isVideo ? 'Video' : 'Suara'}.\\nJika @${id.from.split('@')[0]} Memerlukan Bantuan, Silakan Hubungi Owner :)`, mentions: [id.from]});\r\n\t\t\t\t\tawait naze.sendContact(id.from, global.owner, msg);\r\n\t\t\t\t\tawait naze.rejectCall(id.id, id.from)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tnaze.ev.on('messages.upsert', async (message) => {\r\n\t\tawait MessagesUpsert(naze, message, store);\r\n\t});\r\n\t\r\n\tnaze.ev.on('group-participants.update', async (update) => {\r\n\t\tawait GroupParticipantsUpdate(naze, update, store);\r\n\t});\r\n\t\r\n\tnaze.ev.on('groups.update', (update) => {\r\n\t\tfor (const n of update) {\r\n\t\t\tif (store.groupMetadata[n.id]) {\r\n\t\t\t\tObject.assign(store.groupMetadata[n.id], n);\r\n\t\t\t} else store.groupMetadata[n.id] = n;\r\n\t\t}\r\n\t});\r\n\t\r\n\tnaze.ev.on('presence.update', ({ id, presences: update }) => {\r\n\t\tstore.presences[id] = store.presences?.[id] || {};\r\n\t\tObject.assign(store.presences[id], update);\r\n\t});\r\n\t\r\n\tsetInterval(async () => {\r\n\t\tif (naze?.user?.id) await naze.sendPresenceUpdate('available', naze.decodeJid(naze.user.id)).catch(e => {})\r\n\t}, 10 * 60 * 1000);\r\n\r\n\treturn naze\r\n}\r\n\r\nstartNazeBot()\r\n\r\n// Process Exit\r\nconst cleanup = async (signal) => {\r\n\tconsole.log(`Received ${signal}. Menyimpan database...`)\r\n\tif (global.db) await database.write(global.db)\r\n\tif (global.store) await storeDB.write(global.store)\r\n\tserver.close(() => {\r\n\t\tconsole.log('Server closed. Exiting...')\r\n\t\tprocess.exit(0)\r\n\t})\r\n}\r\n\r\nprocess.on('SIGINT', () => cleanup('SIGINT'))\r\nprocess.on('SIGTERM', () => cleanup('SIGTERM'))\r\nprocess.on('exit', () => cleanup('exit'))\r\n\r\nserver.on('error', (error) => {\r\n\tif (error.code === 'EADDRINUSE') {\r\n\t\tconsole.log(`Address localhost:${PORT} in use. Please retry when the port is available!`);\r\n\t\tserver.close();\r\n\t} else console.error('Server error:', error);\r\n});\r\n\r\nsetInterval(() => {}, 1000 * 60 * 10);\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});\r\n\r\n","path":null,"size_bytes":12920,"size_tokens":null},"ciel/railway.toml":{"content":"[build]\nbuilder = \"nixpacks\"\nbuildCommand = \"npm install && npx prisma generate\"\n\n[deploy]\nstartCommand = \"npm start\"\nhealthcheckPath = \"/health\"\nrestartPolicyType = \"on_failure\"\nrestartPolicyMaxRetries = 10\n\n[healthcheck]\nport = 5000\npath = \"/health\"\ninterval = \"30s\"\ntimeout = \"5s\"\n","path":null,"size_bytes":284,"size_tokens":null},"source-2/lib/handlers/tiktokHandler.js":{"content":"const { tmate } = require('../tmate.js');\nconst axios = require('axios');\nconst { logger } = require('../utils/logger.js');\n\nasync function handleTiktokUrl(conn, m, url) {\n    try {\n        const res = await tmate.download(url);\n        \n        if (res.isSlide) {\n            const totalPhotos = res.mediaUrls.length;\n            logger.info(`üì∏ Processing slideshow (${totalPhotos} images)`);\n\n            for (let i = 0; i < totalPhotos; i++) {\n                const photo = res.mediaUrls[i];\n                \n                if (i === 0) {\n                    await conn.sendMessage(m.key.remoteJid, {\n                        image: { url: photo },\n                        caption: `Mengirim 1 dari ${totalPhotos} slide gambar.\\n_(Sisanya akan dikirim via chat pribadi.)_`\n                    });\n                } else {\n                    await conn.sendMessage(m.key.remoteJid, { \n                        image: { url: photo },\n                        caption: `Slide ${i+1} dari ${totalPhotos}`\n                    });\n                }\n                \n                logger.success(`‚úÖ Sent slide ${i+1}/${totalPhotos}`);\n                await conn.readMessages([m.key]);\n            }\n        } else {\n            const video = res.downloadLinks.find(l => l.linkText.includes('without Watermark'));\n            if (!video) throw new Error('No video found');\n            \n            await conn.sendMessage(m.key.remoteJid, {\n                video: { url: video.link },\n                caption: `üé¨ ${res.title || 'No title'}\\nüë§ @${res.username || 'unknown'}`\n            });\n\n            logger.success(`‚úÖ Sent TikTok video: ${res.title || 'No title'}`);\n\n            const audio = res.downloadLinks.find(l => l.linkText.includes('MP3'));\n            if (audio) {\n                await conn.sendMessage(m.key.remoteJid, {\n                    audio: { url: audio.link },\n                    mimetype: 'audio/mpeg'\n                });\n                logger.success(`üîä Sent audio track`);\n            }\n            \n            await conn.readMessages([m.key]);\n        }\n    } catch (e) {\n        logger.error(`TikTok download failed: ${e.message}`);\n        throw e;\n    }\n}\n\nmodule.exports = {\n    handleTiktokUrl\n};","path":null,"size_bytes":2243,"size_tokens":null},"ciel/lib/scraper.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\nconst FormData = require('form-data');\n\nasync function bytesToSize(bytes) {\n    const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\n    if (bytes === 0) return \"n/a\";\n    const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)), 10);\n    if (i === 0) return `${bytes} ${sizes[i]}`;\n    return `${(bytes / 1024 ** i).toFixed(1)} ${sizes[i]}`;\n}\n\nasync function mediafireDl(url) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const res = await axios.get('https://r.jina.ai/' + url, {\n                headers: { 'x-return-format': 'html' }\n            });\n            const data = res.data;\n            const $ = cheerio.load(data);\n            const link = $('a#downloadButton').attr('href');\n            const size = $('a#downloadButton').text().replace('Download', '').replace('(', '').replace(')', '').trim();\n            const upload_date = $('.dl-info .details li').last().find('span').text().trim();\n            const name = $('div.dl-btn-label').attr('title') || link?.split('/')[5] || 'Unknown';\n            const type = name.split('.')[1] || '';\n            resolve({ name, type, upload_date, size, link });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function pinterest(query) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const baseUrl = 'https://www.pinterest.com/resource/BaseSearchResource/get/';\n            const params = {\n                source_url: '/search/pins/?q=' + encodeURIComponent(query),\n                data: JSON.stringify({\n                    options: {\n                        isPrefetch: false,\n                        query,\n                        scope: 'pins',\n                        no_fetch_context_on_resource: false\n                    },\n                    context: {}\n                }),\n                _: Date.now()\n            };\n            const headers = {\n                'accept': 'application/json, text/javascript, */*, q=0.01',\n                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n                'x-requested-with': 'XMLHttpRequest'\n            };\n            const { data } = await axios.get(baseUrl, { headers, params });\n            const results = data.resource_response?.data?.results ?? [];\n            const result = results.map(item => ({\n                pin: 'https://www.pinterest.com/pin/' + item.id ?? '',\n                link: item.link ?? '',\n                id: item.id ?? '',\n                images_url: item.images?.['736x']?.url ?? '',\n                grid_title: item.grid_title ?? ''\n            }));\n            resolve(result);\n        } catch (e) {\n            reject([]);\n        }\n    });\n}\n\nasync function remini(buffer, method = 'enhance') {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const form = new FormData();\n            form.append('model_version', 1);\n            form.append('image', buffer, { filename: 'enhance_image_body.jpg', contentType: 'image/jpeg' });\n            const { data } = await axios.post('https://inferenceengine.vyro.ai/' + method, form, {\n                headers: {\n                    ...form.getHeaders(),\n                    'accept-encoding': 'gzip',\n                    'user-agent': 'Postify/1.0.0',\n                },\n                responseType: 'arraybuffer',\n            });\n            resolve(data);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function styletext(teks) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get('http://qaz.wtf/u/convert.cgi?text=' + encodeURIComponent(teks));\n            const $ = cheerio.load(data);\n            const hasil = [];\n            $('table > tbody > tr').each(function (a, b) {\n                hasil.push({ \n                    name: $(b).find('td:nth-child(1) > span').text(), \n                    result: $(b).find('td:nth-child(2)').text().trim() \n                });\n            });\n            resolve(hasil);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function ringtone(title) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get('https://meloboom.com/en/search/' + encodeURIComponent(title));\n            const $ = cheerio.load(data);\n            const hasil = [];\n            $('#__next > main > section > div.jsx-2244708474.container > div > div > div > div:nth-child(4) > div > div > div > ul > li').each(function (a, b) {\n                hasil.push({ \n                    title: $(b).find('h4').text(), \n                    source: 'https://meloboom.com/' + $(b).find('a').attr('href'), \n                    audio: $(b).find('audio').attr('src') \n                });\n            });\n            resolve(hasil);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function wallpaper(title, page = '1') {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get(`https://www.besthdwallpaper.com/search?CurrentPage=${page}&q=${encodeURIComponent(title)}`);\n            const $ = cheerio.load(data);\n            const hasil = [];\n            $('div.grid-item').each(function (a, b) {\n                hasil.push({\n                    title: $(b).find('div.info > p').attr('title'),\n                    type: $(b).find('div.info > a:nth-child(2)').text(),\n                    source: 'https://www.besthdwallpaper.com' + $(b).find('a').attr('href'),\n                    image: [\n                        $(b).find('picture > img').attr('data-src') || $(b).find('picture > img').attr('src'),\n                        $(b).find('picture > source:nth-child(1)').attr('srcset'),\n                        $(b).find('picture > source:nth-child(2)').attr('srcset')\n                    ]\n                });\n            });\n            resolve(hasil);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function wikimedia(title) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get(`https://commons.wikimedia.org/w/index.php?search=${encodeURIComponent(title)}&title=Special:MediaSearch&go=Go&type=image`);\n            const $ = cheerio.load(data);\n            const hasil = [];\n            $('.sdms-search-results__list-wrapper > div > a').each(function (a, b) {\n                hasil.push({ \n                    title: $(b).find('img').attr('alt'), \n                    source: $(b).attr('href'), \n                    image: $(b).find('img').attr('data-src') || $(b).find('img').attr('src') \n                });\n            });\n            resolve(hasil);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function instagramDl(url) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.post('https://yt1s.io/api/ajaxSearch', \n                new URLSearchParams({ q: url, w: '', p: 'home', lang: 'en' }), {\n                headers: {\n                    'Accept': 'application/json, text/plain, */*',\n                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',\n                    'Origin': 'https://yt1s.io',\n                    'Referer': 'https://yt1s.io/',\n                    'User-Agent': 'Postify/1.0.0',\n                }\n            });\n            const $ = cheerio.load(data.data);\n            const result = $('a.abutton.is-success.is-fullwidth.btn-premium').map((_, b) => ({\n                title: $(b).attr('title'),\n                url: $(b).attr('href')\n            })).get();\n            resolve(result);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function facebookDl(url) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.post('https://getmyfb.com/process', new URLSearchParams({\n                id: decodeURIComponent(url),\n                locale: 'en',\n            }), {\n                headers: {\n                    'hx-current-url': 'https://getmyfb.com/',\n                    'hx-request': 'true',\n                    'hx-target': url.includes('share') ? '#private-video-downloader' : '#target',\n                    'hx-trigger': 'form',\n                    'hx-post': '/process',\n                    'hx-swap': 'innerHTML',\n                }\n            });\n            const $ = cheerio.load(data);\n            resolve({\n                caption: $('.results-item-text').length > 0 ? $('.results-item-text').text().trim() : '',\n                preview: $('.results-item-image').attr('src') || '',\n                results: $('.results-list-item').get().map(el => ({\n                    quality: parseInt($(el).text().trim()) || '',\n                    type: $(el).text().includes('HD') ? 'HD' : 'SD',\n                    url: $(el).find('a').attr('href') || '',\n                }))\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function instaStalk(username) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get('https://greatfon.com/v/' + username.toLowerCase(), {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n                }\n            });\n            const $ = cheerio.load(data);\n            const list_post = [];\n            $('.card').each((a, b) => {\n                const imageUrl = $(b).find('img').attr('src');\n                const description = $(b).find('img').attr('alt')?.replace(/.*Instagram post:\\s*/, '') || '';\n                const detailUrl = 'https://greatfon.io' + $(b).find('a').attr('href');\n                list_post.push({ imageUrl, description, detailUrl });\n            });\n            resolve({\n                avatar: $('.avatar img').attr('src') || '',\n                username: $('h1.text-4xl').text().trim() || '',\n                nickname: $('h2.text-2xl').text().trim() || '',\n                description: $('.text-sm.font-serif').text().trim() || '',\n                posts: $('.stat').eq(0).find('.stat-value').text().trim() || 0,\n                followers: $('.stat').eq(1).find('.stat-value').text().trim() || 0,\n                following: $('.stat').eq(2).find('.stat-value').text().trim() || 0,\n                list_post\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function tiktokStalk(username) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const headers = { \n                'referer': 'https://countik.com/user/@' + username, \n                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' \n            };\n            const { data } = await axios.get('https://www.tiktok.com/oembed?url=https://www.tiktok.com/@' + username);\n            const { data: res } = await axios.get('https://countik.com/api/exist/' + username, { headers });\n            const { data: wet } = await axios.get('https://countik.com/api/userinfo?sec_user_id=' + res.sec_uid, { headers });\n            resolve({\n                ...res,\n                ...wet,\n                author_name: data.author_name,\n                author_url: data.author_url\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function quotesAnime() {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get('https://animechan.io/api/v1/quotes/random');\n            resolve(data.data);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function faktaUnik() {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const { data } = await axios.get('https://uselessfacts.jsph.pl/api/v2/facts/random');\n            resolve(data.text);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nmodule.exports = {\n    bytesToSize,\n    mediafireDl,\n    pinterest,\n    remini,\n    styletext,\n    ringtone,\n    wallpaper,\n    wikimedia,\n    instagramDl,\n    facebookDl,\n    instaStalk,\n    tiktokStalk,\n    quotesAnime,\n    faktaUnik\n};\n","path":null,"size_bytes":12307,"size_tokens":null},"source-1/lib/converter.js":{"content":"const fs = require('fs')\nconst path = require('path')\nconst { spawn } = require('child_process')\n\nfunction ffmpeg(buffer, args = [], ext = '', ext2 = '') {\n  return new Promise(async (resolve, reject) => {\n    try {\n      let tmp = path.join(__dirname, '../database/sampah', + new Date + '.' + ext)\n      let out = tmp + '.' + ext2\n      await fs.promises.writeFile(tmp, buffer)\n      spawn('ffmpeg', [\n        '-y',\n        '-i', tmp,\n        ...args,\n        out\n      ])\n        .on('error', reject)\n        .on('close', async (code) => {\n          try {\n            await fs.promises.unlink(tmp)\n            if (code !== 0) return reject(code)\n            resolve(await fs.promises.readFile(out))\n            await fs.promises.unlink(out)\n          } catch (e) {\n            reject(e)\n          }\n        })\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n\n/**\n * Convert Audio to Playable WhatsApp Audio\n * @param {Buffer} buffer Audio Buffer\n * @param {String} ext File Extension \n */\nfunction toAudio(buffer, ext) {\n  return ffmpeg(buffer, [\n    '-vn',\n    '-ac', '2',\n    '-b:a', '128k',\n    '-ar', '44100',\n    '-f', 'mp3'\n  ], ext, 'mp3')\n}\n\n/**\n * Convert Audio to Playable WhatsApp PTT\n * @param {Buffer} buffer Audio Buffer\n * @param {String} ext File Extension \n */\nfunction toPTT(buffer, ext) {\n  return ffmpeg(buffer, [\n    '-vn',\n    '-c:a', 'libopus',\n    '-b:a', '128k',\n    '-vbr', 'on',\n    '-compression_level', '10'\n  ], ext, 'opus')\n}\n\n/**\n * Convert Audio to Playable WhatsApp Video\n * @param {Buffer} buffer Video Buffer\n * @param {String} ext File Extension \n */\nfunction toVideo(buffer, ext) {\n  return ffmpeg(buffer, [\n    '-c:v', 'libx264',\n    '-c:a', 'aac',\n    '-ab', '128k',\n    '-ar', '44100',\n    '-crf', '32',\n    '-preset', 'slow'\n  ], ext, 'mp4')\n}\n\nmodule.exports = {\n  toAudio,\n  toPTT,\n  toVideo,\n  ffmpeg,\n}\n","path":null,"size_bytes":1850,"size_tokens":null},"ciel/src/handlers/commands/group.js":{"content":"const settings = require('../../../config/settings');\nconst { updateGroup, getOrCreateGroup, addWarn, getWarn, removeWarn } = require('../../services/database');\n\nconst kick = async (conn, m, { args, isOwner, botSettings }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    let target = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || null);\n    if (!target && args[0]) {\n        target = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    }\n    if (!target) return m.reply('Tag atau balas pesan member yang akan di kick!');\n    \n    const participants = m.metadata.participants.map(p => p.id);\n    if (!participants.includes(target)) return m.reply('Member tidak ditemukan di grup!');\n    \n    await conn.groupParticipantsUpdate(m.chat, [target], 'remove');\n    m.reply(`‚úÖ Berhasil mengeluarkan @${target.split('@')[0]}!`, { mentions: [target] });\n};\n\nconst add = async (conn, m, { args, isOwner, botSettings }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    if (!args[0]) return m.reply('Masukkan nomor yang akan ditambahkan!\\nContoh: .add 628xxx');\n    \n    const target = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    \n    try {\n        await conn.groupParticipantsUpdate(m.chat, [target], 'add');\n        m.reply(`‚úÖ Berhasil menambahkan @${target.split('@')[0]}!`, { mentions: [target] });\n    } catch (e) {\n        if (e.message.includes('not-authorized')) {\n            m.reply('Tidak dapat menambahkan member karena pengaturan privasi!');\n        } else {\n            m.reply('Gagal menambahkan member!');\n        }\n    }\n};\n\nconst promote = async (conn, m, { args, isOwner, botSettings }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    let target = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || null);\n    if (!target && args[0]) {\n        target = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    }\n    if (!target) return m.reply('Tag atau balas pesan member yang akan di promote!');\n    \n    await conn.groupParticipantsUpdate(m.chat, [target], 'promote');\n    m.reply(`‚úÖ @${target.split('@')[0]} sekarang menjadi Admin!`, { mentions: [target] });\n};\n\nconst demote = async (conn, m, { args, isOwner, botSettings }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    let target = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || null);\n    if (!target && args[0]) {\n        target = args[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net';\n    }\n    if (!target) return m.reply('Tag atau balas pesan admin yang akan di demote!');\n    \n    await conn.groupParticipantsUpdate(m.chat, [target], 'demote');\n    m.reply(`‚úÖ @${target.split('@')[0]} bukan Admin lagi!`, { mentions: [target] });\n};\n\nconst setwelcome = async (conn, m, { text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    if (!text) return m.reply('Masukkan pesan welcome!\\nGunakan variabel:\\n@user - mention member\\n@group - nama grup\\n@desc - deskripsi grup');\n    \n    await updateGroup(m.chat, { welcomeMessage: text });\n    m.reply(`‚úÖ Pesan Welcome berhasil diset!\\n\\n${text}`);\n};\n\nconst setleave = async (conn, m, { text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    if (!text) return m.reply('Masukkan pesan leave!\\nGunakan variabel:\\n@user - mention member\\n@group - nama grup');\n    \n    await updateGroup(m.chat, { leaveMessage: text });\n    m.reply(`‚úÖ Pesan Leave berhasil diset!\\n\\n${text}`);\n};\n\nconst welcome = async (conn, m, { args, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    const status = args[0]?.toLowerCase();\n    if (!['on', 'off'].includes(status)) return m.reply('Gunakan: .welcome on/off');\n    \n    await updateGroup(m.chat, { welcome: status === 'on' });\n    m.reply(`‚úÖ Welcome ${status === 'on' ? 'diaktifkan' : 'dinonaktifkan'}!`);\n};\n\nconst leave = async (conn, m, { args, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    const status = args[0]?.toLowerCase();\n    if (!['on', 'off'].includes(status)) return m.reply('Gunakan: .leave on/off');\n    \n    await updateGroup(m.chat, { leave: status === 'on' });\n    m.reply(`‚úÖ Leave message ${status === 'on' ? 'diaktifkan' : 'dinonaktifkan'}!`);\n};\n\nconst antilink = async (conn, m, { args, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    const status = args[0]?.toLowerCase();\n    if (!['on', 'off'].includes(status)) return m.reply('Gunakan: .antilink on/off');\n    \n    await updateGroup(m.chat, { antilink: status === 'on' });\n    m.reply(`‚úÖ Anti-link ${status === 'on' ? 'diaktifkan' : 'dinonaktifkan'}!`);\n};\n\nconst antitoxic = async (conn, m, { args, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    const status = args[0]?.toLowerCase();\n    if (!['on', 'off'].includes(status)) return m.reply('Gunakan: .antitoxic on/off');\n    \n    await updateGroup(m.chat, { antitoxic: status === 'on' });\n    m.reply(`‚úÖ Anti-toxic ${status === 'on' ? 'diaktifkan' : 'dinonaktifkan'}!`);\n};\n\nconst antivirtex = async (conn, m, { args, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    const status = args[0]?.toLowerCase();\n    if (!['on', 'off'].includes(status)) return m.reply('Gunakan: .antivirtex on/off');\n    \n    await updateGroup(m.chat, { antivirtex: status === 'on' });\n    m.reply(`‚úÖ Anti-virtex ${status === 'on' ? 'diaktifkan' : 'dinonaktifkan'}!`);\n};\n\nconst mute = async (conn, m, { args, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    const status = args[0]?.toLowerCase();\n    if (!['on', 'off'].includes(status)) return m.reply('Gunakan: .mute on/off');\n    \n    await updateGroup(m.chat, { mute: status === 'on' });\n    m.reply(`‚úÖ Mute grup ${status === 'on' ? 'diaktifkan (bot tidak merespon)' : 'dinonaktifkan'}!`);\n};\n\nconst groupinfo = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    \n    const group = await getOrCreateGroup(m.chat, m.metadata?.subject);\n    \n    const info = `*üìã Info Grup*\n    \n*Nama:* ${m.metadata?.subject || 'Unknown'}\n*ID:* ${m.chat}\n*Members:* ${m.metadata?.participants?.length || 0}\n*Admins:* ${m.metadata?.participants?.filter(p => p.admin)?.length || 0}\n\n*‚öôÔ∏è Pengaturan:*\n‚Ä¢ Welcome: ${group?.welcome ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Leave: ${group?.leave ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Anti-link: ${group?.antilink ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Anti-toxic: ${group?.antitoxic ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Anti-virtex: ${group?.antivirtex ? '‚úÖ' : '‚ùå'}\n‚Ä¢ Mute: ${group?.mute ? '‚úÖ' : '‚ùå'}`;\n    \n    m.reply(info);\n};\n\nconst linkgroup = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    const code = await conn.groupInviteCode(m.chat);\n    m.reply(`*üîó Link Grup*\\n\\nhttps://chat.whatsapp.com/${code}`);\n};\n\nconst revoke = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    await conn.groupRevokeInvite(m.chat);\n    m.reply('‚úÖ Link grup berhasil di reset!');\n};\n\nconst tagall = async (conn, m, { text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    const participants = m.metadata.participants.map(p => p.id);\n    \n    let message = text || 'Tag All';\n    message += '\\n\\n';\n    \n    for (const jid of participants) {\n        message += `@${jid.split('@')[0]}\\n`;\n    }\n    \n    await conn.sendMessage(m.chat, { text: message, mentions: participants });\n};\n\nconst hidetag = async (conn, m, { text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    if (!text) return m.reply('Masukkan pesan untuk hidetag!');\n    \n    const participants = m.metadata.participants.map(p => p.id);\n    await conn.sendMessage(m.chat, { text, mentions: participants });\n};\n\nconst warn = async (conn, m, { args, text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    let target = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || null);\n    if (!target) return m.reply('Tag atau balas pesan member yang akan diberi warning!');\n    \n    const reason = text.replace(/@\\d+/g, '').trim() || 'Tidak ada alasan';\n    \n    const warnData = await addWarn(m.chat, target, reason);\n    \n    if (warnData.count >= 3) {\n        await conn.groupParticipantsUpdate(m.chat, [target], 'remove');\n        await removeWarn(m.chat, target);\n        return m.reply(`‚ö†Ô∏è @${target.split('@')[0]} telah mencapai 3 warning dan dikeluarkan dari grup!`, { mentions: [target] });\n    }\n    \n    m.reply(`‚ö†Ô∏è Warning ${warnData.count}/3 untuk @${target.split('@')[0]}\\nAlasan: ${reason}`, { mentions: [target] });\n};\n\nconst unwarn = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    let target = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || null);\n    if (!target) return m.reply('Tag atau balas pesan member yang akan dihapus warningnya!');\n    \n    await removeWarn(m.chat, target);\n    m.reply(`‚úÖ Warning @${target.split('@')[0]} telah direset!`, { mentions: [target] });\n};\n\nconst cekwarn = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    \n    let target = m.quoted ? m.quoted.sender : (m.mentionedJid[0] || m.sender);\n    \n    const warnData = await getWarn(m.chat, target);\n    \n    if (!warnData || warnData.count === 0) {\n        return m.reply(`‚úÖ @${target.split('@')[0]} tidak memiliki warning!`, { mentions: [target] });\n    }\n    \n    m.reply(`‚ö†Ô∏è @${target.split('@')[0]} memiliki ${warnData.count}/3 warning\\nAlasan terakhir: ${warnData.reason || '-'}`, { mentions: [target] });\n};\n\nconst open = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    await conn.groupSettingUpdate(m.chat, 'not_announcement');\n    m.reply('‚úÖ Grup telah dibuka! Semua member dapat mengirim pesan.');\n};\n\nconst close = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    await conn.groupSettingUpdate(m.chat, 'announcement');\n    m.reply('‚úÖ Grup telah ditutup! Hanya admin yang dapat mengirim pesan.');\n};\n\nconst setname = async (conn, m, { text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    if (!text) return m.reply('Masukkan nama grup baru!');\n    \n    await conn.groupUpdateSubject(m.chat, text);\n    m.reply(`‚úÖ Nama grup berhasil diubah menjadi: ${text}`);\n};\n\nconst setdesc = async (conn, m, { text, isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    if (!text) return m.reply('Masukkan deskripsi grup baru!');\n    \n    await conn.groupUpdateDescription(m.chat, text);\n    m.reply(`‚úÖ Deskripsi grup berhasil diubah!`);\n};\n\nconst setppgroup = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    if (!m.isBotAdmin) return m.reply(settings.messages.botAdmin);\n    \n    const quoted = m.quoted || m;\n    if (!quoted.isMedia || !quoted.isImage) return m.reply('Reply foto untuk dijadikan foto profil grup!');\n    \n    try {\n        const buffer = await quoted.download();\n        await conn.updateProfilePicture(m.chat, buffer);\n        m.reply('‚úÖ Foto profil grup berhasil diubah!');\n    } catch (e) {\n        m.reply('Gagal mengubah foto profil grup!');\n    }\n};\n\nmodule.exports = {\n    kick,\n    add,\n    promote,\n    demote,\n    setwelcome,\n    setleave,\n    welcome,\n    leave,\n    antilink,\n    antitoxic,\n    antivirtex,\n    mute,\n    groupinfo,\n    linkgroup,\n    linkgrup: linkgroup,\n    revoke,\n    tagall,\n    hidetag,\n    warn,\n    unwarn,\n    cekwarn,\n    open,\n    close,\n    setname,\n    setdesc,\n    setppgroup,\n    setppgrup: setppgroup\n};\n","path":null,"size_bytes":14493,"size_tokens":null},"source-1/src/message.js":{"content":"require('../settings');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst https = require('https');\r\nconst axios = require('axios');\r\nconst chalk = require('chalk');\r\nconst crypto = require('crypto');\r\nconst FileType = require('file-type');\r\nconst PhoneNumber = require('awesome-phonenumber');\r\n\r\nconst { checkStatus } = require('./database');\r\nconst { imageToWebp, videoToWebp, writeExif, gifToWebp } = require('../lib/exif');\r\nconst { isUrl, getGroupAdmins, generateMessageTag, getBuffer, getSizeMedia, fetchJson, sleep, getTypeUrlMedia } = require('../lib/function');\r\nconst { jidNormalizedUser, proto, getBinaryNodeChildren, getBinaryNodeChildString, getBinaryNodeChild, generateMessageIDV2, jidEncode, encodeSignedDeviceIdentity, generateWAMessageContent, generateForwardMessageContent, prepareWAMessageMedia, delay, areJidsSameUser, extractMessageContent, generateMessageID, downloadContentFromMessage, generateWAMessageFromContent, jidDecode, generateWAMessage, toBuffer, getContentType, WAMessageStubType, getDevice } = require('baileys');\r\n\r\n/*\r\n\t* Create By Naze\r\n\t* Follow https://github.com/nazedev\r\n\t* Whatsapp : https://whatsapp.com/channel/0029VaWOkNm7DAWtkvkJBK43\r\n*/\r\n\r\nasync function GroupUpdate(naze, m, store) {\r\n\tif (!m.messageStubType || !m.isGroup) return\r\n\tif (global.db?.groups?.[m.chat] && store?.groupMetadata?.[m.chat] && naze.public) {\r\n\t\tconst admin = `@${m.sender.split('@')[0]}`\r\n\t\tconst metadata = store.groupMetadata[m.chat];\r\n\t\tconst normalizedTarget = m.messageStubParameters[0]\r\n\t\tconst messages = {\r\n\t\t\t1: 'mereset link grup!',\r\n\t\t\t21: `mengubah Subject Grup menjadi :\\n*${normalizedTarget}*`,\r\n\t\t\t22: 'telah mengubah icon grup.',\r\n\t\t\t23: 'mereset link grup!',\r\n\t\t\t24: `mengubah deskripsi grup.\\n\\n${normalizedTarget}`,\r\n\t\t\t25: `telah mengatur agar *${normalizedTarget == 'on' ? 'hanya admin' : 'semua peserta'}* yang dapat mengedit info grup.`,\r\n\t\t\t26: `telah *${normalizedTarget == 'on' ? 'menutup' : 'membuka'}* grup!\\nSekarang ${normalizedTarget == 'on' ? 'hanya admin yang' : 'semua peserta'} dapat mengirim pesan.`,\r\n\t\t\t29: `telah menjadikan @${normalizedTarget?.split('@')?.[0]} sebagai admin.`,\r\n\t\t\t30: `telah memberhentikan @${normalizedTarget?.split('@')?.[0]} dari admin.`,\r\n\t\t\t72: `mengubah durasi pesan sementara menjadi *@${normalizedTarget}*`,\r\n\t\t\t123: 'menonaktifkan pesan sementara.',\r\n\t\t\t132: 'mereset link grup!',\r\n\t\t}\r\n\t\tif (global.db?.groups?.[m.chat]?.setinfo && messages[m.messageStubType]) {\r\n\t\t\tawait naze.sendMessage(m.chat, { text: `${admin} ${messages[m.messageStubType]}`, mentions: [m.sender, ...(normalizedTarget?.includes('@') ? [`${normalizedTarget}`] : [])]}, { ephemeralExpiration: m.expiration || m?.metadata?.ephemeralDuration || store?.messages[m.chat]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 })\r\n\t\t} else if (m.messageStubType == 20) {\r\n\t\t\tstore.groupMetadata[m.chat] = await naze.groupMetadata(m.chat).catch(e => ({}));\r\n\t\t} else if (m.messageStubType == 27) {\r\n\t\t\tif (!metadata.participants.some(a => a.id == normalizedTarget)) metadata.participants.push({ ...(metadata.addressingMode === 'lid' ? { id: '', lid: normalizedTarget } : { id: normalizedTarget, lid: '' }), admin: null });\r\n\t\t} else if (m.messageStubType == 28 || m.messageStubType == 32) {\r\n\t\t\tif (m.fromMe && ((jidNormalizedUser(naze.user.id) == normalizedTarget) || (jidNormalizedUser(naze.user.lid) == normalizedTarget))) {\r\n\t\t\t\tdelete store.messages[m.chat];\r\n\t\t\t\tdelete store.presences[m.chat];\r\n\t\t\t\tdelete store.groupMetadata[m.chat];\r\n\t\t\t}\r\n\t\t\tif(!!metadata) metadata.participants = metadata.participants.filter(p => {\r\n\t\t\t\tconst key = metadata.addressingMode === 'lid' ? jidNormalizedUser(p.lid) : jidNormalizedUser(p.id)\r\n\t\t\t\treturn key !== normalizedTarget\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tconsole.log({\r\n\t\t\t\tmessageStubType: m.messageStubType,\r\n\t\t\t\tmessageStubParameters: m.messageStubParameters,\r\n\t\t\t\ttype: WAMessageStubType[m.messageStubType],\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function GroupParticipantsUpdate(naze, { id, participants, author, action }, store) {\r\n\ttry {\r\n\t\tfunction updateAdminStatus(participants, metadataParticipants, status) {\r\n\t\t\tfor (const participant of metadataParticipants) {\r\n\t\t\t\tif (participants.includes(jidNormalizedUser(participant.id)) || participants.includes(jidNormalizedUser(participant.lid))) {\r\n\t\t\t\t\tparticipant.admin = status;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (global.db?.groups?.[id] && store?.groupMetadata?.[id]) {\r\n\t\t\tconst metadata = store.groupMetadata[id];\r\n\t\t\tfor (let n of participants) {\r\n\t\t\t\tconst participant = metadata.participants.find(a => a.id == jidNormalizedUser(n))\r\n\t\t\t\tlet profile;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tprofile = await naze.profilePictureUrl(n, 'image');\r\n\t\t\t\t} catch {\r\n\t\t\t\t\tprofile = 'https://telegra.ph/file/95670d63378f7f4210f03.png';\r\n\t\t\t\t}\r\n\t\t\t\tlet messageText;\r\n\t\t\t\tif (action === 'add') {\r\n\t\t\t\t\tif (db.groups[id].welcome) messageText = db.groups[id]?.text?.setwelcome || `Welcome to ${metadata.subject}\\n@`;\r\n\t\t\t\t\tif (!participant) metadata.participants.push({ ...(metadata.addressingMode === 'lid' ? { id: '', lid: jidNormalizedUser(n) } : { id: jidNormalizedUser(n), lid: '' }), admin: null });\r\n\t\t\t\t} else if (action === 'remove') {\r\n\t\t\t\t\tif (db.groups[id].leave) messageText = db.groups[id]?.text?.setleave || `@\\nLeaving From ${metadata.subject}`;\r\n\t\t\t\t\tif ((jidNormalizedUser(naze.user.lid) == jidNormalizedUser(n)) || (jidNormalizedUser(naze.user.id) == jidNormalizedUser(n))) {\r\n\t\t\t\t\t\tdelete store.messages[id];\r\n\t\t\t\t\t\tdelete store.presences[id];\r\n\t\t\t\t\t\tdelete store.groupMetadata[id];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(metadata) metadata.participants = metadata.participants.filter(p => !participants.includes(metadata.addressingMode === 'lid' ? jidNormalizedUser(p.lid) : jidNormalizedUser(p.id)));\r\n\t\t\t\t} else if (action === 'promote') {\r\n\t\t\t\t\tif (db.groups[id].promote) messageText = db.groups[id]?.text?.setpromote || `@\\nPromote From ${metadata.subject}\\nBy @admin`;\r\n\t\t\t\t\tupdateAdminStatus(participants, metadata.participants, 'admin');\r\n\t\t\t\t} else if (action === 'demote') {\r\n\t\t\t\t\tif (db.groups[id].demote) messageText = db.groups[id]?.text?.setdemote || `@\\nDemote From ${metadata.subject}\\nBy @admin`;\r\n\t\t\t\t\tupdateAdminStatus(participants, metadata.participants, null);\r\n\t\t\t\t}\r\n\t\t\t\tif (messageText && naze.public) {\r\n\t\t\t\t\tawait naze.sendMessage(id, {\r\n\t\t\t\t\t\ttext: messageText.replace('@subject', author ? `${metadata.subject}` : '@subject').replace('@admin', author ? `@${author.split('@')[0]}` : '@admin').replace(/(?<=\\s|^)@(?!\\w)/g, `@${n.split('@')[0]}`),\r\n\t\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\t\tmentionedJid: [n, author],\r\n\t\t\t\t\t\t\texternalAdReply: {\r\n\t\t\t\t\t\t\t\ttitle: action == 'add' ? 'Welcome' : action == 'remove' ? 'Leaving' : action.charAt(0).toUpperCase() + action.slice(1),\r\n\t\t\t\t\t\t\t\tmediaType: 1,\r\n\t\t\t\t\t\t\t\tpreviewType: 0,\r\n\t\t\t\t\t\t\t\tthumbnailUrl: profile,\r\n\t\t\t\t\t\t\t\trenderLargerThumbnail: true,\r\n\t\t\t\t\t\t\t\tsourceUrl: global.my.gh\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, { ephemeralExpiration: metadata?.ephemeralDuration || store?.messages[id]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (e) {\r\n\t\tthrow e;\r\n\t}\r\n}\r\n\r\nasync function LoadDataBase(naze, m) {\r\n\ttry {\r\n\t\tconst botNumber = await naze.decodeJid(naze.user.id);\r\n\t\tlet game = global.db.game || {};\r\n\t\tlet premium = global.db.premium || [];\r\n\t\tlet user = global.db.users[m.sender] || {};\r\n\t\tlet setBot = global.db.set[botNumber] || {};\r\n\t\t\r\n\t\tglobal.db.game = game;\r\n\t\tglobal.db.users[m.sender] = user;\r\n\t\tglobal.db.set[botNumber] = setBot;\r\n\t\t\r\n\t\tconst defaultSetBot = {\r\n\t\t\tlang: 'id',\r\n\t\t\tlimit: 0,\r\n\t\t\tmoney: 0,\r\n\t\t\tstatus: 0,\r\n\t\t\tjoin: false,\r\n\t\t\tpublic: true,\r\n\t\t\tanticall: true,\r\n\t\t\toriginal: true,\r\n\t\t\treadsw: false,\r\n\t\t\tautobio: false,\r\n\t\t\tautoread: true,\r\n\t\t\tantispam: false,\r\n\t\t\tautotyping: true,\r\n\t\t\tgrouponly: true,\r\n\t\t\tmultiprefix: false,\r\n\t\t\tprivateonly: true,\r\n\t\t\tauthor: global.author || 'Nazedev',\r\n\t\t\tautobackup: false,\r\n\t\t\tbotname: global.botname || 'Hitori Bot',\r\n\t\t\tpackname: global.packname || 'Bot WhatsApp',\r\n\t\t\ttemplate: 'documentMessage',\r\n\t\t\towner: global.owner.map(id => ({ id, lock: true })),\r\n\t\t};\r\n\t\tfor (let key in defaultSetBot) {\r\n\t\t\tif (!(key in setBot)) setBot[key] = defaultSetBot[key];\r\n\t\t}\r\n\t\t\r\n\t\tconst limitUser = user.vip ? global.limit.vip : checkStatus(m.sender, premium) ? global.limit.premium : global.limit.free;\r\n\t\tconst moneyUser = user.vip ? global.money.vip : checkStatus(m.sender, premium) ? global.money.premium : global.money.free;\r\n\t\t\r\n\t\tconst defaultUser = {\r\n\t\t\tvip: false,\r\n\t\t\tban: false,\r\n\t\t\tafkTime: -1,\r\n\t\t\tafkReason: '',\r\n\t\t\tregister: false,\r\n\t\t\tlimit: limitUser,\r\n\t\t\tmoney: moneyUser,\r\n\t\t\tlastclaim: Date.now(),\r\n\t\t\tlastbegal: Date.now(),\r\n\t\t\tlastrampok: Date.now(),\r\n\t\t};\r\n\t\tfor (let key in defaultUser) {\r\n\t\t\tif (!(key in user)) user[key] = defaultUser[key];\r\n\t\t}\r\n\t\t\r\n\t\tif (m.isGroup) {\r\n\t\t\tlet group = global.db.groups[m.chat] || {};\r\n\t\t\tglobal.db.groups[m.chat] = group;\r\n\t\t\t\r\n\t\t\tconst defaultGroup = {\r\n\t\t\t\turl: '',\r\n\t\t\t\ttext: {},\r\n\t\t\t\twarn: {},\r\n\t\t\t\ttagsw: {},\r\n\t\t\t\tnsfw: false,\r\n\t\t\t\tmute: false,\r\n\t\t\t\tleave: false,\r\n\t\t\t\tsetinfo: false,\r\n\t\t\t\tantilink: false,\r\n\t\t\t\tdemote: false,\r\n\t\t\t\tantitoxic: false,\r\n\t\t\t\tpromote: false,\r\n\t\t\t\twelcome: false,\r\n\t\t\t\tantivirtex: false,\r\n\t\t\t\tantitagsw: false,\r\n\t\t\t\tantidelete: false,\r\n\t\t\t\tantihidetag: false,\r\n\t\t\t\twaktusholat: false,\r\n\t\t\t};\r\n\t\t\tfor (let key in defaultGroup) {\r\n\t\t\t\tif (!(key in group)) group[key] = defaultGroup[key];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tconst defaultGame = {\r\n\t\t\tsuit: {},\r\n\t\t\tchess: {},\r\n\t\t\tchat_ai: {},\r\n\t\t\tmenfes: {},\r\n\t\t\ttekateki: {},\r\n\t\t\takinator: {},\r\n\t\t\ttictactoe: {},\r\n\t\t\ttebaklirik: {},\r\n\t\t\tkuismath: {},\r\n\t\t\tblackjack: {},\r\n\t\t\ttebaklagu: {},\r\n\t\t\ttebakkata: {},\r\n\t\t\tfamily100: {},\r\n\t\t\tsusunkata: {},\r\n\t\t\ttebakbom: {},\r\n\t\t\tulartangga: {},\r\n\t\t\ttebakkimia: {},\r\n\t\t\tcaklontong: {},\r\n\t\t\ttebakangka: {},\r\n\t\t\ttebaknegara: {},\r\n\t\t\ttebakgambar: {},\r\n\t\t\ttebakbendera: {},\r\n\t\t};\r\n\t\tfor (let key in defaultGame) {\r\n\t\t\tif (!(key in game)) game[key] = defaultGame[key];\r\n\t\t}\r\n\t\t\r\n\t} catch (e) {\r\n\t\tthrow e\r\n\t}\r\n}\r\n\r\nasync function MessagesUpsert(naze, message, store) {\r\n\ttry {\r\n\t\tlet botNumber = await naze.decodeJid(naze.user.id);\r\n\t\tconst msg = message.messages[0];\r\n\t\tconst remoteJid = msg.key.remoteJid;\r\n\t\tstore.messages[remoteJid] ??= {};\r\n\t\tstore.messages[remoteJid].array ??= [];\r\n\t\tstore.messages[remoteJid].keyId ??= new Set();\r\n\t\tif (!(store.messages[remoteJid].keyId instanceof Set)) {\r\n\t\t\tstore.messages[remoteJid].keyId = new Set(store.messages[remoteJid].array.map(m => m.key.id));\r\n\t\t}\r\n\t\tif (store.messages[remoteJid].keyId.has(msg.key.id)) return;\r\n\t\tstore.messages[remoteJid].array.push(msg);\r\n\t\tstore.messages[remoteJid].keyId.add(msg.key.id);\r\n\t\tif (store.messages[remoteJid].array.length > (global.chatLength || 250)) {\r\n\t\t\tconst removed = store.messages[remoteJid].array.shift();\r\n\t\t\tstore.messages[remoteJid].keyId.delete(removed.key.id);\r\n\t\t}\r\n\t\tif (!store.groupMetadata || Object.keys(store.groupMetadata).length === 0) store.groupMetadata ??= await naze.groupFetchAllParticipating().catch(e => ({}));\r\n\t\tconst type = msg.message ? (getContentType(msg.message) || Object.keys(msg.message)[0]) : '';\r\n\t\tconst m = await Serialize(naze, msg, store)\r\n\t\trequire('../naze')(naze, m, msg, store);\r\n\t\tif (db?.set?.[botNumber]?.readsw && msg.key.remoteJid === 'status@broadcast') {\r\n\t\t\tawait naze.readMessages([msg.key]);\r\n\t\t\tif (/protocolMessage/i.test(type)) await naze.sendFromOwner(global.db?.set?.[botNumber]?.owner?.map(x => x.id) || global.owner, 'Status dari @' + msg.key.participant.split('@')[0] + ' Telah dihapus', msg, { mentions: [msg.key.participant] });\r\n\t\t\tif (/(audioMessage|imageMessage|videoMessage|extendedTextMessage)/i.test(type)) {\r\n\t\t\t\tlet keke = (type == 'extendedTextMessage') ? `Story Teks Berisi : ${msg.message.extendedTextMessage.text ? msg.message.extendedTextMessage.text : ''}` : (type == 'imageMessage') ? `Story Gambar ${msg.message.imageMessage.caption ? 'dengan Caption : ' + msg.message.imageMessage.caption : ''}` : (type == 'videoMessage') ? `Story Video ${msg.message.videoMessage.caption ? 'dengan Caption : ' + msg.message.videoMessage.caption : ''}` : (type == 'audioMessage') ? 'Story Audio' : '\\nTidak diketahui cek saja langsung'\r\n\t\t\t\tawait naze.sendFromOwner(global.db?.set?.[botNumber]?.owner?.map(x => x.id) || global.owner, `Melihat story dari @${msg.key.participant.split('@')[0]}\\n${keke}`, msg, { mentions: [msg.key.participant] });\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (e) {\r\n\t\tthrow e;\r\n\t}\r\n}\r\n\r\nasync function Solving(naze, store) {\r\n\tnaze.serializeM = (m) => MessagesUpsert(naze, m, store)\r\n\t\r\n\tnaze.decodeJid = (jid) => {\r\n\t\tif (!jid) return jid\r\n\t\tif (/:\\d+@/gi.test(jid)) {\r\n\t\t\tlet decode = jidDecode(jid) || {}\r\n\t\t\treturn decode.user && decode.server && decode.user + '@' + decode.server || jid\r\n\t\t} else return jid\r\n\t}\r\n\t\r\n\tnaze.findJidByLid = (lid, store) => {\r\n\t\tfor (const contact of Object.values(store.contacts)) {\r\n\t\t\tif (contact.lid === lid) {\r\n\t\t\t\treturn contact.id;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\tnaze.getName = (jid, withoutContact  = false) => {\r\n\t\tconst id = naze.decodeJid(jid);\r\n\t\tif (id.endsWith('@g.us')) {\r\n\t\t\tconst groupInfo = store.contacts[id] || (store.groupMetadata[id] ? store.groupMetadata[id] : (store.groupMetadata[id] = naze.groupMetadata(id))) || {};\r\n\t\t\treturn Promise.resolve(groupInfo.name || groupInfo.subject || PhoneNumber('+' + id.replace('@g.us', '')).getNumber('international'));\r\n\t\t} else {\r\n\t\t\tif (id === '0@s.whatsapp.net') {\r\n\t\t\t\treturn 'WhatsApp';\r\n\t\t\t}\r\n\t\tconst contactInfo = store.contacts[id] || {};\r\n\t\treturn withoutContact ? '' : contactInfo.name || contactInfo.subject || contactInfo.verifiedName || PhoneNumber('+' + id.replace('@s.whatsapp.net', '')).getNumber('international');\r\n\t\t}\r\n\t}\r\n\t\r\n\tnaze.sendContact = async (jid, kon, quoted = '', opts = {}) => {\r\n\t\tlet list = []\r\n\t\tfor (let i of kon) {\r\n\t\t\tlist.push({\r\n\t\t\t\tdisplayName: await naze.getName(i + '@s.whatsapp.net'),\r\n\t\t\t\tvcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:${await naze.getName(i + '@s.whatsapp.net')}\\nFN:${await naze.getName(i + '@s.whatsapp.net')}\\nitem1.TEL;waid=${i}:${i}\\nitem1.X-ABLabel:Ponsel\\nitem2.ADR:;;Indonesia;;;;\\nitem2.X-ABLabel:Region\\nEND:VCARD` //vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:${await naze.getName(i + '@s.whatsapp.net')}\\nFN:${await naze.getName(i + '@s.whatsapp.net')}\\nitem1.TEL;waid=${i}:${i}\\nitem1.X-ABLabel:Ponsel\\nitem2.EMAIL;type=INTERNET:whatsapp@gmail.com\\nitem2.X-ABLabel:Email\\nitem3.URL:https://instagram.com/naze_dev\\nitem3.X-ABLabel:Instagram\\nitem4.ADR:;;Indonesia;;;;\\nitem4.X-ABLabel:Region\\nEND:VCARD`\r\n\t\t\t})\r\n\t\t}\r\n\t\tnaze.sendMessage(jid, { contacts: { displayName: `${list.length} Kontak`, contacts: list }, ...opts }, { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 });\r\n\t}\r\n\t\r\n\tnaze.profilePictureUrl = async (jid, type = 'image', timeoutMs) => {\r\n\t\tconst result = await naze.query({\r\n\t\t\ttag: 'iq',\r\n\t\t\tattrs: {\r\n\t\t\t\ttarget: jidNormalizedUser(jid),\r\n\t\t\t\tto: '@s.whatsapp.net',\r\n\t\t\t\ttype: 'get',\r\n\t\t\t\txmlns: 'w:profile:picture'\r\n\t\t\t},\r\n\t\t\tcontent: [{\r\n\t\t\t\ttag: 'picture',\r\n\t\t\t\tattrs: {\r\n\t\t\t\t\ttype, query: 'url'\r\n\t\t\t\t},\r\n\t\t\t}]\r\n\t\t}, timeoutMs);\r\n\t\tconst child = getBinaryNodeChild(result, 'picture');\r\n\t\treturn child?.attrs?.url;\r\n\t}\r\n\t\r\n\tnaze.setStatus = (status) => {\r\n\t\tnaze.query({\r\n\t\t\ttag: 'iq',\r\n\t\t\tattrs: {\r\n\t\t\t\tto: '@s.whatsapp.net',\r\n\t\t\t\ttype: 'set',\r\n\t\t\t\txmlns: 'status',\r\n\t\t\t},\r\n\t\t\tcontent: [{\r\n\t\t\t\ttag: 'status',\r\n\t\t\t\tattrs: {},\r\n\t\t\t\tcontent: Buffer.from(status, 'utf-8')\r\n\t\t\t}]\r\n\t\t})\r\n\t\treturn status\r\n\t}\r\n\t\r\n\tnaze.extractGroupMetadata = (result) => {\r\n\t\tconst group = getBinaryNodeChild(result, 'group');\r\n\t\tconst descChild = getBinaryNodeChild(group, 'description');\r\n\t\tconst desc = descChild ? getBinaryNodeChildString(descChild, 'body') : undefined;\r\n\t\tconst descId = descChild?.attrs?.id;\r\n\t\tconst groupId = group.attrs.id.includes('@') ? group.attrs.id : jidEncode(group.attrs.id, 'g.us');\r\n\t\tconst eph = getBinaryNodeChild(group, 'ephemeral')?.attrs?.expiration;\r\n\t\tconst participants = getBinaryNodeChildren(group, 'participant') || [];\r\n\t\treturn {\r\n\t\t\tid: groupId,\r\n\t\t\taddressingMode: group.attrs.addressing_mode,\r\n\t\t\tsubject: group.attrs.subject,\r\n\t\t\tsubjectOwner: group.attrs.s_o,\r\n\t\t\tsubjectTime: +group.attrs.s_t,\r\n\t\t\tcreation: +group.attrs.creation,\r\n\t\t\tsize: participants.length,\r\n\t\t\towner: group.attrs.creator ? jidNormalizedUser(group.attrs.creator) : undefined,\r\n\t\t\tdesc,\r\n\t\t\tdescId,\r\n\t\t\tlinkedParent: getBinaryNodeChild(group, 'linked_parent')?.attrs?.jid,\r\n\t\t\trestrict: !!getBinaryNodeChild(group, 'locked'),\r\n\t\t\tannounce: !!getBinaryNodeChild(group, 'announcement'),\r\n\t\t\tisCommunity: !!getBinaryNodeChild(group, 'parent'),\r\n\t\t\tisCommunityAnnounce: !!getBinaryNodeChild(group, 'default_sub_group'),\r\n\t\t\tjoinApprovalMode: !!getBinaryNodeChild(group, 'membership_approval_mode'),\r\n\t\t\tmemberAddMode: getBinaryNodeChildString(group, 'member_add_mode') === 'all_member_add',\r\n\t\t\tephemeralDuration: eph ? +eph : undefined,\r\n\t\t\tparticipants: participants.map(({ attrs }) => ({\r\n\t\t\t\tid: attrs.jid.endsWith('@lid') ? attrs.phone_number : attrs.jid,\r\n\t\t\t\tlid: attrs.jid.endsWith('@lid') ? attrs.jid : attrs.lid,\r\n\t\t\t\tadmin: attrs.type || null\r\n\t\t\t}))\r\n\t\t};\r\n\t}\r\n\t\r\n\t\r\n\tnaze.groupMetadata = async (jid) => {\r\n\t\tconst result = await naze.query({\r\n\t\t\ttag: 'iq',\r\n\t\t\tattrs: {\r\n\t\t\t\ttype: 'get',\r\n\t\t\t\txmlns: 'w:g2',\r\n\t\t\t\tto: jid\r\n\t\t\t},\r\n\t\t\tcontent: [{ tag: 'query', attrs: { request: 'interactive' }}]\r\n\t\t});\r\n\t\treturn naze.extractGroupMetadata(result);\r\n\t};\r\n\t\r\n\tnaze.groupFetchAllParticipating = async () => {\r\n\t\tconst result = await naze.query({ tag: 'iq', attrs: { to: '@g.us', xmlns: 'w:g2', type: 'get' }, content: [{ tag: 'participating', attrs: {}, content: [{ tag: 'participants', attrs: {}}, { tag: 'description', attrs: {}}]}]});\r\n\t\tconst data = {};\r\n\t\tconst groupsChild = getBinaryNodeChild(result, 'groups');\r\n\t\tif (groupsChild) {\r\n\t\t\tconst groups = getBinaryNodeChildren(groupsChild, 'group');\r\n\t\t\tfor (const groupNode of groups) {\r\n\t\t\t\tconst meta = naze.extractGroupMetadata({\r\n\t\t\t\t\ttag: 'result',\r\n\t\t\t\t\tattrs: {},\r\n\t\t\t\t\tcontent: [groupNode]\r\n\t\t\t\t});\r\n\t\t\t\tdata[meta.id] = meta;\r\n\t\t\t}\r\n\t\t}\r\n\t\tnaze.ev.emit('groups.update', Object.values(data));\r\n\t\treturn data;\r\n\t}\r\n\r\n\tnaze.sendPoll = (jid, name = '', values = [], quoted, selectableCount = 1) => {\r\n\t\treturn naze.sendMessage(jid, { poll: { name, values, selectableCount }}, { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 })\r\n\t}\r\n\t\r\n\tnaze.sendFileUrl = async (jid, url, caption, quoted, options = {}) => {\r\n\t\tconst quotedOptions = { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 }\r\n\t\tasync function getFileUrl(res, mime) {\r\n\t\t\tif (mime && mime.includes('gif')) {\r\n\t\t\t\treturn naze.sendMessage(jid, { video: res.data, caption: caption, gifPlayback: true, ...options }, quotedOptions);\r\n\t\t\t} else if (mime && mime === 'application/pdf') {\r\n\t\t\t\treturn naze.sendMessage(jid, { document: res.data, mimetype: 'application/pdf', caption: caption, ...options }, quotedOptions);\r\n\t\t\t} else if (mime && mime.includes('image')) {\r\n\t\t\t\treturn naze.sendMessage(jid, { image: res.data, caption: caption, ...options }, quotedOptions);\r\n\t\t\t} else if (mime && mime.includes('video')) {\r\n\t\t\t\treturn naze.sendMessage(jid, { video: res.data, caption: caption, mimetype: 'video/mp4', ...options }, quotedOptions);\r\n\t\t\t} else if (mime && mime.includes('webp') && !/.jpg|.jpeg|.png/.test(url)) {\r\n\t\t\t\treturn naze.sendAsSticker(jid, res.data, quoted, options);\r\n\t\t\t} else if (mime && mime.includes('audio')) {\r\n\t\t\t\treturn naze.sendMessage(jid, { audio: res.data, mimetype: 'audio/mpeg', ...options }, quotedOptions);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst axioss = axios.create({\r\n\t\t\thttpsAgent: new https.Agent({ rejectUnauthorized: false }),\r\n\t\t});\r\n\t\tconst res = await axioss.get(url, { responseType: 'arraybuffer' });\r\n\t\tlet mime = res.headers['content-type'];\r\n\t\tif (!mime || mime.includes('octet-stream')) {\r\n\t\t\tconst fileType = await FileType.fromBuffer(res.data);\r\n\t\t\tmime = fileType ? fileType.mime : null;\r\n\t\t}\r\n\t\tconst hasil = await getFileUrl(res, mime);\r\n\t\treturn hasil\r\n\t}\r\n\t\r\n\tnaze.sendGroupInvite = async (jid, participant, inviteCode, inviteExpiration, groupName = 'Unknown Subject', caption = 'Invitation to join my WhatsApp group', jpegThumbnail = null, options = {}) => {\r\n\t\tconst msg = proto.Message.fromObject({\r\n\t\t\tgroupInviteMessage: {\r\n\t\t\t\tinviteCode,\r\n\t\t\t\tinviteExpiration: parseInt(inviteExpiration) || + new Date(new Date + (3 * 86400000)),\r\n\t\t\t\tgroupJid: jid,\r\n\t\t\t\tgroupName,\r\n\t\t\t\tjpegThumbnail: Buffer.isBuffer(jpegThumbnail) ? jpegThumbnail : null,\r\n\t\t\t\tcaption,\r\n\t\t\t\tcontextInfo: {\r\n\t\t\t\t\tmentionedJid: options.mentions || []\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tconst message = generateWAMessageFromContent(participant, msg, options);\r\n\t\tconst invite = await naze.relayMessage(participant, message.message, { messageId: message.key.id })\r\n\t\treturn invite\r\n\t}\r\n\t\r\n\tnaze.sendFromOwner = async (jid, text, quoted, options = {}) => {\r\n\t\tfor (const a of jid) {\r\n\t\t\tawait naze.sendMessage(a.replace(/[^0-9]/g, '') + '@s.whatsapp.net', { text, ...options }, { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 })\r\n\t\t}\r\n\t}\r\n\t\r\n\tnaze.sendText = async (jid, text, quoted, options = {}) => naze.sendMessage(jid, { text: text, mentions: [...text.matchAll(/@(\\d{0,16})/g)].map(v => v[1] + '@s.whatsapp.net'), ...options }, { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 })\r\n\t\r\n\tnaze.sendAsSticker = async (jid, path, quoted, options = {}) => {\r\n\t\tconst buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0);\r\n\t\tconst result = await writeExif(buff, options);\r\n\t\treturn naze.sendMessage(jid, { sticker: { url: result }, ...options }, { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 });\r\n\t}\r\n\t\r\n\tnaze.downloadMediaMessage = async (message) => {\r\n\t\tconst msg = message.msg || message;\r\n\t\tconst mime = msg.mimetype || '';\r\n\t\tconst messageType = (message.type || mime.split('/')[0]).replace(/Message/gi, '');\r\n\t\tconst stream = await downloadContentFromMessage(msg, messageType);\r\n\t\tlet buffer = Buffer.from([]);\r\n\t\tfor await (const chunk of stream) {\r\n\t\t\tbuffer = Buffer.concat([buffer, chunk]);\r\n\t\t}\r\n\t\treturn buffer\r\n\t}\r\n\t\r\n\tnaze.downloadAndSaveMediaMessage = async (message, filename, attachExtension = true) => {\r\n\t\tconst buffer = await naze.downloadMediaMessage(message);\r\n\t\tconst type = await FileType.fromBuffer(buffer);\r\n\t\tconst trueFileName = attachExtension ? `./database/sampah/${filename ? filename : Date.now()}.${type.ext}` : filename;\r\n\t\tawait fs.promises.writeFile(trueFileName, buffer);\r\n\t\treturn trueFileName;\r\n\t}\r\n\t\r\n\tnaze.getFile = async (PATH, save) => {\r\n\t\tlet res;\r\n\t\tlet filename;\r\n\t\tlet data = Buffer.isBuffer(PATH) ? PATH : /^data:.*?\\/.*?;base64,/i.test(PATH) ? Buffer.from(PATH.split`,`[1], 'base64') : /^https?:\\/\\//.test(PATH) ? await (res = await getBuffer(PATH)) : fs.existsSync(PATH) ? (filename = PATH, fs.readFileSync(PATH)) : typeof PATH === 'string' ? PATH : Buffer.alloc(0)\r\n\t\tlet type = await FileType.fromBuffer(data) || { mime: 'application/octet-stream', ext: '.bin' }\r\n\t\tfilename = path.join(__dirname, '../database/sampah/' + new Date * 1 + '.' + type.ext)\r\n\t\tif (data && save) fs.promises.writeFile(filename, data)\r\n\t\treturn {\r\n\t\t\tres,\r\n\t\t\tfilename,\r\n\t\t\tsize: await getSizeMedia(data),\r\n\t\t\t...type,\r\n\t\t\tdata\r\n\t\t}\r\n\t}\r\n\t\r\n\tnaze.appendResponseMessage = async (m, text) => {\r\n\t\tlet apb = await generateWAMessage(m.chat, { text, mentions: m.mentionedJid }, { userJid: naze.user.id, quoted: m.quoted && m.quoted.fakeObj, ephemeralExpiration: m.expiration || m?.metadata?.ephemeralDuration || store?.messages[m.chat]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0 });\r\n\t\tapb.key = m.key\r\n\t\tapb.key.id = [...Array(32)].map(() => '0123456789ABCDEF'[Math.floor(Math.random() * 16)]).join('');\r\n\t\tapb.key.fromMe = areJidsSameUser(m.sender, naze.user.id);\r\n\t\tif (m.isGroup) apb.participant = m.sender;\r\n\t\tnaze.ev.emit('messages.upsert', {\r\n\t\t\t...m,\r\n\t\t\tmessages: [proto.WebMessageInfo.fromObject(apb)],\r\n\t\t\ttype: 'append'\r\n\t\t});\r\n\t}\r\n\t\r\n\tnaze.sendMedia = async (jid, path, fileName = '', caption = '', quoted = '', options = {}) => {\r\n\t\tconst { mime, data, filename } = await naze.getFile(path, true);\r\n\t\tconst botNumber = naze.decodeJid(naze.user.id);\r\n\t\tconst isWebpSticker = options.asSticker || /webp/.test(mime);\r\n\t\tlet type = 'document', mimetype = mime, pathFile = filename;\r\n\t\tif (isWebpSticker) {\r\n\t\t\tpathFile = await writeExif(data, {\r\n\t\t\t\tpackname: options.packname || db?.set?.[botNumber]?.packname || 'Bot WhatsApp',\r\n\t\t\t\tauthor: options.author || db?.set?.[botNumber]?.author || 'Nazedev',\r\n\t\t\t\tcategories: options.categories || [],\r\n\t\t\t})\r\n\t\t\tawait fs.unlinkSync(filename);\r\n\t\t\ttype = 'sticker';\r\n\t\t\tmimetype = 'image/webp';\r\n\t\t} else if (/image|video|audio/.test(mime)) {\r\n\t\t\ttype = mime.split('/')[0];\r\n\t\t\tmimetype = type == 'video' ? 'video/mp4' : type == 'audio' ? 'audio/mpeg' : mime\r\n\t\t}\r\n\t\tlet anu = await naze.sendMessage(jid, { [type]: { url: pathFile }, caption, mimetype, fileName, ...options }, { quoted, ephemeralExpiration: quoted?.expiration || quoted?.metadata?.ephemeralDuration || store?.messages[jid]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0, ...options });\r\n\t\tawait fs.unlinkSync(pathFile);\r\n\t\treturn anu;\r\n\t}\r\n\t\r\n\tnaze.sendAlbumMessage = async (jid, content = {}, options = {}) => {\r\n\t\tconst { album, mentions, contextInfo, ...others } = content;\r\n\t\tfor (const media of album) {\r\n\t\t\tif (!media.image && !media.video) throw new TypeError(`album[i] must have image or video property`);\r\n\t\t}\r\n\t\tif (album.length < 2) throw new RangeError(\"Minimum 2 media\");\r\n\t\tconst medias = await generateWAMessageFromContent(jid, {\r\n\t\t\talbumMessage: {\r\n\t\t\t\texpectedImageCount: album.filter(m => m.image).length,\r\n\t\t\t\texpectedVideoCount: album.filter(m => m.video).length,\r\n\t\t\t}\r\n\t\t}, {});\r\n\t\tawait naze.relayMessage(jid, medias.message, { messageId: medias.key.id });\r\n\t\tfor (const media of album) {\r\n\t\t\tconst msg = await generateWAMessage(jid, { ...others, ...media }, { upload: naze.waUploadToServer });\r\n\t\t\tmsg.message.messageContextInfo = {\r\n\t\t\t\tmessageAssociation: {\r\n\t\t\t\t\tassociationType: 1,\r\n\t\t\t\t\tparentMessageKey: medias.key\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tawait naze.relayMessage(jid, msg.message, { messageId: msg.key.id });\r\n\t\t}\r\n\t\treturn medias;\r\n\t}\r\n\t\r\n\tnaze.sendListMsg = async (jid, content = {}, options = {}) => {\r\n\t\tconst { text, caption, footer = '', title, subtitle, ai, contextInfo = {}, buttons = [], mentions = [], ...media } = content;\r\n\t\tconst msg = await generateWAMessageFromContent(jid, {\r\n\t\t\tviewOnceMessage: {\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tmessageContextInfo: {\r\n\t\t\t\t\t\tdeviceListMetadata: {},\r\n\t\t\t\t\t\tdeviceListMetadataVersion: 2,\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinteractiveMessage: proto.Message.InteractiveMessage.create({\r\n\t\t\t\t\t\tbody: proto.Message.InteractiveMessage.Body.create({ text: text || caption || '' }),\r\n\t\t\t\t\t\tfooter: proto.Message.InteractiveMessage.Footer.create({ text: footer }),\r\n\t\t\t\t\t\theader: proto.Message.InteractiveMessage.Header.fromObject({\r\n\t\t\t\t\t\t\ttitle,\r\n\t\t\t\t\t\t\tsubtitle,\r\n\t\t\t\t\t\t\thasMediaAttachment: Object.keys(media).length > 0,\r\n\t\t\t\t\t\t\t...(media && typeof media === 'object' && Object.keys(media).length > 0 ? await generateWAMessageContent(media, {\r\n\t\t\t\t\t\t\t\tupload: naze.waUploadToServer\r\n\t\t\t\t\t\t\t}) : {})\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tnativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({\r\n\t\t\t\t\t\t\tbuttons: buttons.map(a => {\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\tname: a.name,\r\n\t\t\t\t\t\t\t\t\tbuttonParamsJson: JSON.stringify(a.buttonParamsJson ? (typeof a.buttonParamsJson === 'string' ? JSON.parse(a.buttonParamsJson) : a.buttonParamsJson) : '')\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\t\t...contextInfo,\r\n\t\t\t\t\t\t\t...options.contextInfo,\r\n\t\t\t\t\t\t\tmentionedJid: options.mentions || mentions,\r\n\t\t\t\t\t\t\t...(options.quoted ? {\r\n\t\t\t\t\t\t\t\tstanzaId: options.quoted.key.id,\r\n\t\t\t\t\t\t\t\tremoteJid: options.quoted.key.remoteJid,\r\n\t\t\t\t\t\t\t\tparticipant: options.quoted.key.participant || options.quoted.key.remoteJid,\r\n\t\t\t\t\t\t\t\tfromMe: options.quoted.key.fromMe,\r\n\t\t\t\t\t\t\t\tquotedMessage: options.quoted.message\r\n\t\t\t\t\t\t\t} : {})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, {});\r\n\t\tconst hasil = await naze.relayMessage(msg.key.remoteJid, msg.message, {\r\n\t\t\tmessageId: msg.key.id,\r\n\t\t\tadditionalNodes: [{\r\n\t\t\t\ttag: 'biz',\r\n\t\t\t\tattrs: {},\r\n\t\t\t\tcontent: [{\r\n\t\t\t\t\ttag: 'interactive',\r\n\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\ttype: 'native_flow',\r\n\t\t\t\t\t\tv: '1'\r\n\t\t\t\t\t},\r\n\t\t\t\t\tcontent: [{\r\n\t\t\t\t\t\ttag: 'native_flow',\r\n\t\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\t\tname: 'quick_reply'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}]\r\n\t\t\t\t}]\r\n\t\t\t}, ...(ai ? [{ attrs: { biz_bot: '1' }, tag: 'bot' }] : [])]\r\n\t\t})\r\n\t\treturn hasil\r\n\t}\r\n\t\r\n\tnaze.sendButtonMsg = async (jid, content = {}, options = {}) => {\r\n\t\tconst { text, caption, footer = '', headerType = 1, ai, contextInfo = {}, buttons = [], mentions = [], ...media } = content;\r\n\t\tconst msg = await generateWAMessageFromContent(jid, {\r\n\t\t\tviewOnceMessage: {\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tmessageContextInfo: {\r\n\t\t\t\t\t\tdeviceListMetadata: {},\r\n\t\t\t\t\t\tdeviceListMetadataVersion: 2,\r\n\t\t\t\t\t},\r\n\t\t\t\t\tbuttonsMessage: {\r\n\t\t\t\t\t\t...(media && typeof media === 'object' && Object.keys(media).length > 0 ? await generateWAMessageContent(media, {\r\n\t\t\t\t\t\t\tupload: naze.waUploadToServer\r\n\t\t\t\t\t\t}) : {}),\r\n\t\t\t\t\t\tcontentText: text || caption || '',\r\n\t\t\t\t\t\tfooterText: footer,\r\n\t\t\t\t\t\tbuttons,\r\n\t\t\t\t\t\theaderType: media && Object.keys(media).length > 0 ? Math.max(...Object.keys(media).map((a) => ({ document: 3, image: 4, video: 5, location: 6 })[a] || headerType)) : headerType,\r\n\t\t\t\t\t\tcontextInfo: {\r\n\t\t\t\t\t\t\t...contextInfo,\r\n\t\t\t\t\t\t\t...options.contextInfo,\r\n\t\t\t\t\t\t\tmentionedJid: options.mentions || mentions,\r\n\t\t\t\t\t\t\t...(options.quoted ? {\r\n\t\t\t\t\t\t\t\tstanzaId: options.quoted.key.id,\r\n\t\t\t\t\t\t\t\tremoteJid: options.quoted.key.remoteJid,\r\n\t\t\t\t\t\t\t\tparticipant: options.quoted.key.participant || options.quoted.key.remoteJid,\r\n\t\t\t\t\t\t\t\tfromMe: options.quoted.key.fromMe,\r\n\t\t\t\t\t\t\t\tquotedMessage: options.quoted.message\r\n\t\t\t\t\t\t\t} : {})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, {});\r\n\t\tconst hasil = await naze.relayMessage(msg.key.remoteJid, msg.message, {\r\n\t\t\tmessageId: msg.key.id,\r\n\t\t\tadditionalNodes: [{\r\n\t\t\t\ttag: 'biz',\r\n\t\t\t\tattrs: {},\r\n\t\t\t\tcontent: [{\r\n\t\t\t\t\ttag: 'interactive',\r\n\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\ttype: 'native_flow',\r\n\t\t\t\t\t\tv: '1'\r\n\t\t\t\t\t},\r\n\t\t\t\t\tcontent: [{\r\n\t\t\t\t\t\ttag: 'native_flow',\r\n\t\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\t\tname: 'quick_reply'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}]\r\n\t\t\t\t}]\r\n\t\t\t}, ...(ai ? [{ attrs: { biz_bot: '1' }, tag: 'bot' }] : [])]\r\n\t\t})\r\n\t\treturn hasil\r\n\t}\r\n\t\r\n\tnaze.newsletterMsg = async (key, content = {}, timeout = 5000) => {\r\n\t\tconst { type: rawType = 'INFO', name, description = '', picture = null, react, id, newsletter_id = key, ...media } = content;\r\n\t\tconst type = rawType.toUpperCase();\r\n\t\tif (react) {\r\n\t\t\tif (!(newsletter_id.endsWith('@newsletter') || !isNaN(newsletter_id))) throw [{ message: 'Use Id Newsletter', extensions: { error_code: 204, severity: 'CRITICAL', is_retryable: false }}]\r\n\t\t\tif (!id) throw [{ message: 'Use Id Newsletter Message', extensions: { error_code: 204, severity: 'CRITICAL', is_retryable: false }}]\r\n\t\t\tconst hasil = await naze.query({\r\n\t\t\t\ttag: 'message',\r\n\t\t\t\tattrs: {\r\n\t\t\t\t\tto: key,\r\n\t\t\t\t\ttype: 'reaction',\r\n\t\t\t\t\t'server_id': id,\r\n\t\t\t\t\tid: generateMessageID()\r\n\t\t\t\t},\r\n\t\t\t\tcontent: [{\r\n\t\t\t\t\ttag: 'reaction',\r\n\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\tcode: react\r\n\t\t\t\t\t}\r\n\t\t\t\t}]\r\n\t\t\t});\r\n\t\t\treturn hasil\r\n\t\t} else if (media && typeof media === 'object' && Object.keys(media).length > 0) {\r\n\t\t\tconst msg = await generateWAMessageContent(media, { upload: naze.waUploadToServer });\r\n\t\t\tconst anu = await naze.query({\r\n\t\t\t\ttag: 'message',\r\n\t\t\t\tattrs: { to: newsletter_id, type: 'text' in media ? 'text' : 'media' },\r\n\t\t\t\tcontent: [{\r\n\t\t\t\t\ttag: 'plaintext',\r\n\t\t\t\t\tattrs: /image|video|audio|sticker|poll/.test(Object.keys(media).join('|')) ? { mediatype: Object.keys(media).find(key => ['image', 'video', 'audio', 'sticker','poll'].includes(key)) || null } : {},\r\n\t\t\t\t\tcontent: proto.Message.encode(msg).finish()\r\n\t\t\t\t}]\r\n\t\t\t})\r\n\t\t\treturn anu\r\n\t\t} else {\r\n\t\t\tif ((/(FOLLOW|UNFOLLOW|DELETE)/.test(type)) && !(newsletter_id.endsWith('@newsletter') || !isNaN(newsletter_id))) return [{ message: 'Use Id Newsletter', extensions: { error_code: 204, severity: 'CRITICAL', is_retryable: false }}]\r\n\t\t\tconst _query = await naze.query({\r\n\t\t\t\ttag: 'iq',\r\n\t\t\t\tattrs: {\r\n\t\t\t\t\tto: 's.whatsapp.net',\r\n\t\t\t\t\ttype: 'get',\r\n\t\t\t\t\txmlns: 'w:mex'\r\n\t\t\t\t},\r\n\t\t\t\tcontent: [{\r\n\t\t\t\t\ttag: 'query',\r\n\t\t\t\t\tattrs: {\r\n\t\t\t\t\t\tquery_id: type == 'FOLLOW' ? '9926858900719341' : type == 'UNFOLLOW' ? '7238632346214362' : type == 'CREATE' ? '6234210096708695' : type == 'DELETE' ? '8316537688363079' : '6563316087068696'\r\n\t\t\t\t\t},\r\n\t\t\t\t\tcontent: new TextEncoder().encode(JSON.stringify({\r\n\t\t\t\t\t\tvariables: /(FOLLOW|UNFOLLOW|DELETE)/.test(type) ? { newsletter_id } : type == 'CREATE' ? { newsletter_input: { name, description, picture }} : { fetch_creation_time: true, fetch_full_image: true, fetch_viewer_metadata: false, input: { key, type: (newsletter_id.endsWith('@newsletter') || !isNaN(newsletter_id)) ? 'JID' : 'INVITE' }}\r\n\t\t\t\t\t}))\r\n\t\t\t\t}]\r\n\t\t\t}, timeout);\r\n\t\t\tconst res = JSON.parse(_query.content[0].content)?.data?.xwa2_newsletter || JSON.parse(_query.content[0].content)?.data?.xwa2_newsletter_join_v2 || JSON.parse(_query.content[0].content)?.data?.xwa2_newsletter_leave_v2 || JSON.parse(_query.content[0].content)?.data?.xwa2_newsletter_create || JSON.parse(_query.content[0].content)?.data?.xwa2_newsletter_delete_v2 || JSON.parse(_query.content[0].content)?.errors || JSON.parse(_query.content[0].content)\r\n\t\t\tres.thread_metadata ? (res.thread_metadata.host = 'https://mmg.whatsapp.net') : null\r\n\t\t\treturn res\r\n\t\t}\r\n\t}\r\n\t\r\n\tnaze.sendCarouselMsg = async (jid, body = '', footer = '', cards = [], options = {}) => {\r\n\t\tasync function getImageMsg(url) {\r\n\t\t\tconst { imageMessage } = await generateWAMessageContent({ image: { url } }, { upload: naze.waUploadToServer });\r\n\t\t\treturn imageMessage;\r\n\t\t}\r\n\t\tconst cardPromises = cards.map(async (a) => {\r\n\t\t\tconst imageMessage = await getImageMsg(a.url);\r\n\t\t\treturn {\r\n\t\t\t\theader: {\r\n\t\t\t\t\timageMessage: imageMessage,\r\n\t\t\t\t\thasMediaAttachment: true\r\n\t\t\t\t},\r\n\t\t\t\tbody: { text: a.body },\r\n\t\t\t\tfooter: { text: a.footer },\r\n\t\t\t\tnativeFlowMessage: {\r\n\t\t\t\t\tbuttons: a.buttons.map(b => ({\r\n\t\t\t\t\t\tname: b.name,\r\n\t\t\t\t\t\tbuttonParamsJson: JSON.stringify(b.buttonParamsJson ? JSON.parse(b.buttonParamsJson) : '')\r\n\t\t\t\t\t}))\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t});\r\n\t\t\r\n\t\tconst cardResults = await Promise.all(cardPromises);\r\n\t\tconst msg = await generateWAMessageFromContent(jid, {\r\n\t\t\tviewOnceMessage: {\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tmessageContextInfo: {\r\n\t\t\t\t\t\tdeviceListMetadata: {},\r\n\t\t\t\t\t\tdeviceListMetadataVersion: 2\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinteractiveMessage: proto.Message.InteractiveMessage.create({\r\n\t\t\t\t\t\tbody: proto.Message.InteractiveMessage.Body.create({ text: body }),\r\n\t\t\t\t\t\tfooter: proto.Message.InteractiveMessage.Footer.create({ text: footer }),\r\n\t\t\t\t\t\tcarouselMessage: proto.Message.InteractiveMessage.CarouselMessage.create({\r\n\t\t\t\t\t\t\tcards: cardResults,\r\n\t\t\t\t\t\t\tmessageVersion: 1\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, {});\r\n\t\tconst hasil = await naze.relayMessage(msg.key.remoteJid, msg.message, { messageId: msg.key.id });\r\n\t\treturn hasil\r\n\t}\r\n\t\r\n\tif (naze.user && naze.user.id) {\r\n\t\tconst botNumber = naze.decodeJid(naze.user.id);\r\n\t\tif (global.db?.set[botNumber]) {\r\n\t\t\tnaze.public = global.db.set[botNumber].public\r\n\t\t} else naze.public = true\r\n\t} else naze.public = true\r\n\r\n\treturn naze\r\n}\r\n\r\n/*\r\n\t* Create By Naze\r\n\t* Follow https://github.com/nazedev\r\n\t* Whatsapp : https://whatsapp.com/channel/0029VaWOkNm7DAWtkvkJBK43\r\n*/\r\n\r\nasync function Serialize(naze, msg, store) {\r\n\tconst botLid = naze.decodeJid(naze.user.lid);\r\n\tconst botNumber = naze.decodeJid(naze.user.id);\r\n\tconst m = { ...msg };\r\n\tif (!m) return m\r\n\tif (m.key) {\r\n\t\tm.id = m.key.id\r\n\t\tm.chat = m.key.remoteJid\r\n\t\tm.fromMe = m.key.fromMe\r\n\t\tm.isBot = ['HSK', 'BAE', 'B1E', '3EB0', 'B24E', 'WA'].some(a => m.id.startsWith(a) && [12, 16, 20, 22, 40].includes(m.id.length)) || /(.)\\1{5,}|[^a-zA-Z0-9]|[^0-9A-F]/.test(m.id) || false\r\n\t\tm.isGroup = m.chat.endsWith('@g.us')\r\n\t\tif (!m.isGroup && m.chat.endsWith('@lid')) m.chat = naze.findJidByLid(m.chat, store) || m.chat;\r\n\t\tm.sender = naze.decodeJid(m.fromMe && naze.user.id || m.key.participant || m.chat || '')\r\n\t\tif (m.isGroup) {\r\n\t\t\tif (!store.groupMetadata) store.groupMetadata = await naze.groupFetchAllParticipating().catch(e => ({}));\r\n\t\t\tlet metadata = store.groupMetadata[m.chat] ? store.groupMetadata[m.chat] : (store.groupMetadata[m.chat] = await naze.groupMetadata(m.chat).catch(e => ({})))\r\n\t\t\tif (!metadata) {\r\n\t\t\t\tmetadata = await naze.groupMetadata(m.chat).catch(e => ({}))\r\n\t\t\t\tstore.groupMetadata[m.chat] = metadata\r\n\t\t\t}\r\n\t\t\tm.metadata = metadata\r\n\t\t\tm.metadata.size = (metadata.participants || []).length;\r\n\t\t\tif (metadata.addressingMode === 'lid') {\r\n\t\t\t\tconst participant = metadata.participants.find(a => a.lid === m.sender)\r\n\t\t\t\tm.key.participant = m.sender = participant?.id || m.sender;\r\n\t\t\t\tm.metadata.owner = m.metadata?.participants?.find(p => p.lid === m.metadata.owner)?.id || m.metadata.owner;\r\n\t\t\t\tm.metadata.subjectOwner = m.metadata?.participants?.find(p => p.lid === m.metadata.subjectOwner)?.id || m.metadata.subjectOwner;\r\n\t\t\t\tstore.contacts[m.sender] = { ...store.contacts[m.sender], id: m.sender, lid: m.fromMe && naze.user.lid || participant?.lid || m.sender, name: m.pushName };\r\n\t\t\t}\r\n\t\t\tm.admins = m.metadata.participants ? (m.metadata.participants.reduce((a, b) => (b.admin ? a.push({ id: b.id, admin: b.admin }) : [...a]) && a, [])) : []\r\n\t\t\tm.isAdmin = m.admins?.some((b) => b.id === m.sender) || false\r\n\t\t\tm.participant = m.key.participant\r\n\t\t\tm.isBotAdmin = !!m.admins?.find((member) => [botNumber, botLid].includes(member.id)) || false\r\n\t\t}\r\n\t}\r\n\tif (m.message) {\r\n\t\tm.type = getContentType(m.message) || Object.keys(m.message)[0]\r\n\t\tm.msg = (/viewOnceMessage|viewOnceMessageV2Extension|editedMessage|ephemeralMessage/i.test(m.type) ? m.message[m.type].message[getContentType(m.message[m.type].message)] : (extractMessageContent(m.message[m.type]) || m.message[m.type]))\r\n\t\tm.body = m.message?.conversation || m.msg?.text || m.msg?.conversation || m.msg?.caption || m.msg?.selectedButtonId || m.msg?.singleSelectReply?.selectedRowId || m.msg?.selectedId || m.msg?.contentText || m.msg?.selectedDisplayText || m.msg?.title || m.msg?.name || ''\r\n\t\tm.mentionedJid = m.msg?.contextInfo?.mentionedJid || []\r\n\t\tm.text = m.msg?.text || m.msg?.caption || m.message?.conversation || m.msg?.contentText || m.msg?.selectedDisplayText || m.msg?.title || '';\r\n\t\tm.prefix = /^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@#$%^&.¬©^]/gi.test(m.body) ? m.body.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@#$%^&.¬©^]/gi)[0] : /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi.test(m.body) ? m.body.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi)[0] : ''\r\n\t\tm.command = m.body && m.body.replace(m.prefix, '').trim().split(/ +/).shift()\r\n\t\tm.args = m.body?.trim().replace(new RegExp(\"^\" + m.prefix?.replace(/[.*=+:\\-?^${}()|[\\]\\\\]|\\s/g, '\\\\$&'), 'i'), '').replace(m.command, '').split(/ +/).filter(a => a) || []\r\n\t\tm.device = getDevice(m.id)\r\n\t\tm.expiration = m.msg?.contextInfo?.expiration || m?.metadata?.ephemeralDuration || store?.messages?.[m.chat]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0\r\n\t\tm.timestamp = (typeof m.messageTimestamp === \"number\" ? m.messageTimestamp : m.messageTimestamp.low ? m.messageTimestamp.low : m.messageTimestamp.high) || m.msg.timestampMs * 1000\r\n\t\tm.isMedia = !!m.msg?.mimetype || !!m.msg?.thumbnailDirectPath\r\n\t\tif (m.isMedia) {\r\n\t\t\tm.mime = m.msg?.mimetype\r\n\t\t\tm.size = m.msg?.fileLength\r\n\t\t\tm.height = m.msg?.height || ''\r\n\t\t\tm.width = m.msg?.width || ''\r\n\t\t\tif (/webp/i.test(m.mime)) {\r\n\t\t\t\tm.isAnimated = m.msg?.isAnimated\r\n\t\t\t}\r\n\t\t}\r\n\t\tm.quoted = m.msg?.contextInfo?.quotedMessage || null\r\n\t\tif (m.quoted) {\r\n\t\t\tm.quoted.message = extractMessageContent(m.msg?.contextInfo?.quotedMessage)\r\n\t\t\tm.quoted.type = getContentType(m.quoted.message) || Object.keys(m.quoted.message)[0]\r\n\t\t\tm.quoted.id = m.msg.contextInfo.stanzaId\r\n\t\t\tm.quoted.device = getDevice(m.quoted.id)\r\n\t\t\tm.quoted.chat = m.msg.contextInfo.remoteJid || m.chat\r\n\t\t\tm.quoted.isBot = m.quoted.id ? ['HSK', 'BAE', 'B1E', '3EB0', 'B24E', 'WA'].some(a => m.quoted.id.startsWith(a) && [12, 16, 20, 22, 40].includes(m.quoted.id.length)) || /(.)\\1{5,}|[^a-zA-Z0-9]|[^0-9A-F]/.test(m.quoted.id) : false\r\n\t\t\tif (m.msg?.contextInfo?.participant?.endsWith('@lid')) m.msg.contextInfo.participant =  m?.metadata?.participants?.find(a => a.lid === m.msg.contextInfo.participant)?.id || m.msg.contextInfo.participant;\r\n\t\t\tm.quoted.sender = naze.decodeJid(m.msg.contextInfo.participant)\r\n\t\t\tm.quoted.fromMe = m.quoted.sender === naze.decodeJid(naze.user.id)\r\n\t\t\tm.quoted.text = m.quoted.caption || m.quoted.conversation || m.quoted.contentText || m.quoted.selectedDisplayText || m.quoted.title || ''\r\n\t\t\tm.quoted.msg = extractMessageContent(m.quoted.message[m.quoted.type]) || m.quoted.message[m.quoted.type]\r\n\t\t\tm.quoted.mentionedJid = m.quoted?.msg?.contextInfo?.mentionedJid || []\r\n\t\t\tm.quoted.body = m.quoted.msg?.text || m.quoted.msg?.caption || m.quoted?.message?.conversation || m.quoted.msg?.selectedButtonId || m.quoted.msg?.singleSelectReply?.selectedRowId || m.quoted.msg?.selectedId || m.quoted.msg?.contentText || m.quoted.msg?.selectedDisplayText || m.quoted.msg?.title || m.quoted?.msg?.name || ''\r\n\t\t\tm.getQuotedObj = async () => {\r\n\t\t\t\tif (!m.quoted.id) return false\r\n\t\t\t\tlet q = await store.loadMessage(m.chat, m.quoted.id, naze)\r\n\t\t\t\treturn await Serialize(naze, q, store)\r\n\t\t\t}\r\n\t\t\tm.quoted.key = {\r\n\t\t\t\tremoteJid: m.msg?.contextInfo?.remoteJid || m.chat,\r\n\t\t\t\tparticipant: m.quoted.sender,\r\n\t\t\t\tfromMe: areJidsSameUser(naze.decodeJid(m.msg?.contextInfo?.participant), naze.decodeJid(naze?.user?.id)),\r\n\t\t\t\tid: m.msg?.contextInfo?.stanzaId\r\n\t\t\t}\r\n\t\t\tm.quoted.isGroup = m.quoted.chat.endsWith('@g.us')\r\n\t\t\tm.quoted.mentions = m.quoted.msg?.contextInfo?.mentionedJid || []\r\n\t\t\tm.quoted.body = m.quoted.msg?.text || m.quoted.msg?.caption || m.quoted?.message?.conversation || m.quoted.msg?.selectedButtonId || m.quoted.msg?.singleSelectReply?.selectedRowId || m.quoted.msg?.selectedId || m.quoted.msg?.contentText || m.quoted.msg?.selectedDisplayText || m.quoted.msg?.title || m.quoted?.msg?.name || ''\r\n\t\t\tm.quoted.prefix = /^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@#$%^&.¬©^]/gi.test(m.quoted.body) ? m.quoted.body.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@#$%^&.¬©^]/gi)[0] : /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi.test(m.quoted.body) ? m.quoted.body.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/gi)[0] : ''\r\n\t\t\tm.quoted.command = m.quoted.body && m.quoted.body.replace(m.quoted.prefix, '').trim().split(/ +/).shift()\r\n\t\t\tm.quoted.isMedia = !!m.quoted.msg?.mimetype || !!m.quoted.msg?.thumbnailDirectPath\r\n\t\t\tif (m.quoted.isMedia) {\r\n\t\t\t\tm.quoted.fileSha256 = m.quoted[m.quoted.type]?.fileSha256 || ''\r\n\t\t\t\tm.quoted.mime = m.quoted.msg?.mimetype\r\n\t\t\t\tm.quoted.size = m.quoted.msg?.fileLength\r\n\t\t\t\tm.quoted.height = m.quoted.msg?.height || ''\r\n\t\t\t\tm.quoted.width = m.quoted.msg?.width || ''\r\n\t\t\t\tif (/webp/i.test(m.quoted.mime)) {\r\n\t\t\t\t\tm.quoted.isAnimated = m?.quoted?.msg?.isAnimated || false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tm.quoted.fakeObj = proto.WebMessageInfo.fromObject({\r\n\t\t\t\tkey: {\r\n\t\t\t\t\tremoteJid: m.quoted.chat,\r\n\t\t\t\t\tfromMe: m.quoted.fromMe,\r\n\t\t\t\t\tid: m.quoted.id\r\n\t\t\t\t},\r\n\t\t\t\tmessage: m.quoted,\r\n\t\t\t\t...(m.isGroup ? { participant: m.quoted.sender } : {})\r\n\t\t\t})\r\n\t\t\tm.quoted.download = () => naze.downloadMediaMessage(m.quoted)\r\n\t\t\tm.quoted.delete = () => {\r\n\t\t\t\tnaze.sendMessage(m.quoted.chat, {\r\n\t\t\t\t\tdelete: {\r\n\t\t\t\t\t\tremoteJid: m.quoted.chat,\r\n\t\t\t\t\t\tfromMe: m.isBotAdmins ? false : true,\r\n\t\t\t\t\t\tid: m.quoted.id,\r\n\t\t\t\t\t\tparticipant: m.quoted.sender\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tm.download = () => naze.downloadMediaMessage(m)\r\n\t\r\n\tm.copy = () => Serialize(naze, proto.WebMessageInfo.fromObject(proto.WebMessageInfo.toObject(m)))\r\n\t\r\n\tm.react = (u) => naze.sendMessage(m.chat, { react: { text: u, key: m.key }})\r\n\t\r\n\tm.reply = async (content, options = {}) => {\r\n\t\tconst { quoted = m, chat = m.chat, caption = '', ephemeralExpiration = m.expiration || m?.metadata?.ephemeralDuration || store?.messages[m.chat]?.array?.slice(-1)[0]?.metadata?.ephemeralDuration || 0, mentions = (typeof content === 'string' || typeof content.text === 'string' || typeof content.caption === 'string') ? [...(content.text || content.caption || content).matchAll(/@(\\d{0,16})/g)].map(v => v[1] + '@s.whatsapp.net') : [], ...validate } = options;\r\n\t\tif (typeof content === 'object') {\r\n\t\t\treturn naze.sendMessage(chat, content, { ...options, quoted, ephemeralExpiration })\r\n\t\t} else if (typeof content === 'string') {\r\n\t\t\ttry {\r\n\t\t\t\tif (/^https?:\\/\\//.test(content)) {\r\n\t\t\t\t\tconst data = await axios.get(content, { responseType: 'arraybuffer' });\r\n\t\t\t\t\tconst mime = data.headers['content-type'] || (await FileType.fromBuffer(data.data)).mime\r\n\t\t\t\t\tif (/gif|image|video|audio|pdf|stream/i.test(mime)) {\r\n\t\t\t\t\t\treturn naze.sendMedia(chat, data.data, '', caption, quoted, content)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn naze.sendMessage(chat, { text: content, mentions, ...options }, { quoted, ephemeralExpiration })\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn naze.sendMessage(chat, { text: content, mentions, ...options }, { quoted, ephemeralExpiration })\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn naze.sendMessage(chat, { text: content, mentions, ...options }, { quoted, ephemeralExpiration })\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn m\r\n}\r\n\r\nmodule.exports = { GroupUpdate, GroupParticipantsUpdate, LoadDataBase, MessagesUpsert, Solving }\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});\r\n","path":null,"size_bytes":46340,"size_tokens":null},"source-1/speed.py":{"content":"#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Copyright 2012 Matt Martz\n# All Rights Reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport csv\nimport datetime\nimport errno\nimport math\nimport os\nimport platform\nimport re\nimport signal\nimport socket\nimport sys\nimport threading\nimport timeit\nimport xml.parsers.expat\n\ntry:\n    import gzip\n    GZIP_BASE = gzip.GzipFile\nexcept ImportError:\n    gzip = None\n    GZIP_BASE = object\n\n__version__ = '2.1.4b1'\n\n\nclass FakeShutdownEvent(object):\n    \"\"\"Class to fake a threading.Event.isSet so that home of this module\n    are not required to register their own threading.Event()\n    \"\"\"\n\n    @staticmethod\n    def isSet():\n        \"Dummy method to always return false\"\"\"\n        return False\n\n    is_set = isSet\n\n\n# Some global variables we use\nDEBUG = False\n_GLOBAL_DEFAULT_TIMEOUT = object()\nPY25PLUS = sys.version_info[:2] >= (2, 5)\nPY26PLUS = sys.version_info[:2] >= (2, 6)\nPY32PLUS = sys.version_info[:2] >= (3, 2)\nPY310PLUS = sys.version_info[:2] >= (3, 10)\n\n# Begin import game to handle Python 2 and Python 3\ntry:\n    import json\nexcept ImportError:\n    try:\n        import simplejson as json\n    except ImportError:\n        json = None\n\ntry:\n    import xml.etree.ElementTree as ET\n    try:\n        from xml.etree.ElementTree import _Element as ET_Element\n    except ImportError:\n        pass\nexcept ImportError:\n    from xml.dom import minidom as DOM\n    from xml.parsers.expat import ExpatError\n    ET = None\n\ntry:\n    from urllib2 import (urlopen, Request, HTTPError, URLError,\n                         AbstractHTTPHandler, ProxyHandler,\n                         HTTPDefaultErrorHandler, HTTPRedirectHandler,\n                         HTTPErrorProcessor, OpenerDirector)\nexcept ImportError:\n    from urllib.request import (urlopen, Request, HTTPError, URLError,\n                                AbstractHTTPHandler, ProxyHandler,\n                                HTTPDefaultErrorHandler, HTTPRedirectHandler,\n                                HTTPErrorProcessor, OpenerDirector)\n\ntry:\n    from httplib import HTTPConnection, BadStatusLine\nexcept ImportError:\n    from http.client import HTTPConnection, BadStatusLine\n\ntry:\n    from httplib import HTTPSConnection\nexcept ImportError:\n    try:\n        from http.client import HTTPSConnection\n    except ImportError:\n        HTTPSConnection = None\n\ntry:\n    from httplib import FakeSocket\nexcept ImportError:\n    FakeSocket = None\n\ntry:\n    from Queue import Queue\nexcept ImportError:\n    from queue import Queue\n\ntry:\n    from urlparse import urlparse\nexcept ImportError:\n    from urllib.parse import urlparse\n\ntry:\n    from urlparse import parse_qs\nexcept ImportError:\n    try:\n        from urllib.parse import parse_qs\n    except ImportError:\n        from cgi import parse_qs\n\ntry:\n    from hashlib import md5\nexcept ImportError:\n    from md5 import md5\n\ntry:\n    from argparse import ArgumentParser as ArgParser\n    from argparse import SUPPRESS as ARG_SUPPRESS\n    PARSER_TYPE_INT = int\n    PARSER_TYPE_STR = str\n    PARSER_TYPE_FLOAT = float\nexcept ImportError:\n    from optparse import OptionParser as ArgParser\n    from optparse import SUPPRESS_HELP as ARG_SUPPRESS\n    PARSER_TYPE_INT = 'int'\n    PARSER_TYPE_STR = 'string'\n    PARSER_TYPE_FLOAT = 'float'\n\ntry:\n    from cStringIO import StringIO\n    BytesIO = None\nexcept ImportError:\n    try:\n        from StringIO import StringIO\n        BytesIO = None\n    except ImportError:\n        from io import StringIO, BytesIO\n\ntry:\n    import __builtin__\nexcept ImportError:\n    import builtins\n    from io import TextIOWrapper, FileIO\n\n    class _Py3Utf8Output(TextIOWrapper):\n        \"\"\"UTF-8 encoded wrapper around stdout for py3, to override\n        ASCII stdout\n        \"\"\"\n        def __init__(self, f, **kwargs):\n            buf = FileIO(f.fileno(), 'w')\n            super(_Py3Utf8Output, self).__init__(\n                buf,\n                encoding='utf8',\n                errors='strict'\n            )\n\n        def write(self, s):\n            super(_Py3Utf8Output, self).write(s)\n            self.flush()\n\n    _py3_print = getattr(builtins, 'print')\n    try:\n        _py3_utf8_stdout = _Py3Utf8Output(sys.stdout)\n        _py3_utf8_stderr = _Py3Utf8Output(sys.stderr)\n    except OSError:\n        # sys.stdout/sys.stderr is not a compatible stdout/stderr object\n        # just use it and hope things go ok\n        _py3_utf8_stdout = sys.stdout\n        _py3_utf8_stderr = sys.stderr\n\n    def to_utf8(v):\n        \"\"\"No-op encode to utf-8 for py3\"\"\"\n        return v\n\n    def print_(*args, **kwargs):\n        \"\"\"Wrapper function for py3 to print, with a utf-8 encoded stdout\"\"\"\n        if kwargs.get('file') == sys.stderr:\n            kwargs['file'] = _py3_utf8_stderr\n        else:\n            kwargs['file'] = kwargs.get('file', _py3_utf8_stdout)\n        _py3_print(*args, **kwargs)\nelse:\n    del __builtin__\n\n    def to_utf8(v):\n        \"\"\"Encode value to utf-8 if possible for py2\"\"\"\n        try:\n            return v.encode('utf8', 'strict')\n        except AttributeError:\n            return v\n\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\n\n        Taken from https://pypi.python.org/pypi/six/\n\n        Modified to set encoding to UTF-8 always, and to flush after write\n        \"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            encoding = 'utf8'  # Always trust UTF-8 for output\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(encoding, errors)\n            fp.write(data)\n            fp.flush()\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\n\n# Exception \"constants\" to support Python 2 through Python 3\ntry:\n    import ssl\n    try:\n        CERT_ERROR = (ssl.CertificateError,)\n    except AttributeError:\n        CERT_ERROR = tuple()\n\n    HTTP_ERRORS = (\n        (HTTPError, URLError, socket.error, ssl.SSLError, BadStatusLine) +\n        CERT_ERROR\n    )\nexcept ImportError:\n    ssl = None\n    HTTP_ERRORS = (HTTPError, URLError, socket.error, BadStatusLine)\n\nif PY32PLUS:\n    etree_iter = ET.Element.iter\nelif PY25PLUS:\n    etree_iter = ET_Element.getiterator\n\nif PY26PLUS:\n    thread_is_alive = threading.Thread.is_alive\nelse:\n    thread_is_alive = threading.Thread.isAlive\n\n\ndef event_is_set(event):\n    try:\n        return event.is_set()\n    except AttributeError:\n        return event.isSet()\n\n\nclass SpeedtestException(Exception):\n    \"\"\"Base exception for this module\"\"\"\n\n\nclass SpeedtestCLIError(SpeedtestException):\n    \"\"\"Generic exception for raising errors during CLI operation\"\"\"\n\n\nclass SpeedtestHTTPError(SpeedtestException):\n    \"\"\"Base HTTP exception for this module\"\"\"\n\n\nclass SpeedtestConfigError(SpeedtestException):\n    \"\"\"Configuration XML is invalid\"\"\"\n\n\nclass SpeedtestServersError(SpeedtestException):\n    \"\"\"Servers XML is invalid\"\"\"\n\n\nclass ConfigRetrievalError(SpeedtestHTTPError):\n    \"\"\"Could not retrieve config.php\"\"\"\n\n\nclass ServersRetrievalError(SpeedtestHTTPError):\n    \"\"\"Could not retrieve speedtest-servers.php\"\"\"\n\n\nclass InvalidServerIDType(SpeedtestException):\n    \"\"\"Server ID used for filtering was not an integer\"\"\"\n\n\nclass NoMatchedServers(SpeedtestException):\n    \"\"\"No servers matched when filtering\"\"\"\n\n\nclass SpeedtestMiniConnectFailure(SpeedtestException):\n    \"\"\"Could not connect to the provided speedtest mini server\"\"\"\n\n\nclass InvalidSpeedtestMiniServer(SpeedtestException):\n    \"\"\"Server provided as a speedtest mini server does not actually appear\n    to be a speedtest mini server\n    \"\"\"\n\n\nclass ShareResultsConnectFailure(SpeedtestException):\n    \"\"\"Could not connect to speedtest.net API to POST results\"\"\"\n\n\nclass ShareResultsSubmitFailure(SpeedtestException):\n    \"\"\"Unable to successfully POST results to speedtest.net API after\n    connection\n    \"\"\"\n\n\nclass SpeedtestUploadTimeout(SpeedtestException):\n    \"\"\"testlength configuration reached during upload\n    Used to ensure the upload halts when no additional data should be sent\n    \"\"\"\n\n\nclass SpeedtestBestServerFailure(SpeedtestException):\n    \"\"\"Unable to determine best server\"\"\"\n\n\nclass SpeedtestMissingBestServer(SpeedtestException):\n    \"\"\"get_best_server not called or not able to determine best server\"\"\"\n\n\ndef create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                      source_address=None):\n    \"\"\"Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :fun`getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.\n\n    Largely vendored from Python 2.7, modified to work with Python 2.4\n    \"\"\"\n\n    host, port = address\n    err = None\n    for res in socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket.socket(af, socktype, proto)\n            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                sock.settimeout(float(timeout))\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(sa)\n            return sock\n\n        except socket.error:\n            err = get_exception()\n            if sock is not None:\n                sock.close()\n\n    if err is not None:\n        raise err\n    else:\n        raise socket.error(\"getaddrinfo returns an empty list\")\n\n\nclass SpeedtestHTTPConnection(HTTPConnection):\n    \"\"\"Custom HTTPConnection to support source_address across\n    Python 2.4 - Python 3\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        source_address = kwargs.pop('source_address', None)\n        timeout = kwargs.pop('timeout', 10)\n\n        self._tunnel_host = None\n\n        HTTPConnection.__init__(self, *args, **kwargs)\n\n        self.source_address = source_address\n        self.timeout = timeout\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        try:\n            self.sock = socket.create_connection(\n                (self.host, self.port),\n                self.timeout,\n                self.source_address\n            )\n        except (AttributeError, TypeError):\n            self.sock = create_connection(\n                (self.host, self.port),\n                self.timeout,\n                self.source_address\n            )\n\n        if self._tunnel_host:\n            self._tunnel()\n\n\nif HTTPSConnection:\n    class SpeedtestHTTPSConnection(HTTPSConnection):\n        \"\"\"Custom HTTPSConnection to support source_address across\n        Python 2.4 - Python 3\n        \"\"\"\n        default_port = 443\n\n        def __init__(self, *args, **kwargs):\n            source_address = kwargs.pop('source_address', None)\n            timeout = kwargs.pop('timeout', 10)\n\n            self._tunnel_host = None\n\n            HTTPSConnection.__init__(self, *args, **kwargs)\n\n            self.timeout = timeout\n            self.source_address = source_address\n\n        def connect(self):\n            \"Connect to a host on a given (SSL) port.\"\n            try:\n                self.sock = socket.create_connection(\n                    (self.host, self.port),\n                    self.timeout,\n                    self.source_address\n                )\n            except (AttributeError, TypeError):\n                self.sock = create_connection(\n                    (self.host, self.port),\n                    self.timeout,\n                    self.source_address\n                )\n\n            if self._tunnel_host:\n                self._tunnel()\n\n            if ssl:\n                try:\n                    kwargs = {}\n                    if hasattr(ssl, 'SSLContext'):\n                        if self._tunnel_host:\n                            kwargs['server_hostname'] = self._tunnel_host\n                        else:\n                            kwargs['server_hostname'] = self.host\n                    self.sock = self._context.wrap_socket(self.sock, **kwargs)\n                except AttributeError:\n                    self.sock = ssl.wrap_socket(self.sock)\n                    try:\n                        self.sock.server_hostname = self.host\n                    except AttributeError:\n                        pass\n            elif FakeSocket:\n                # Python 2.4/2.5 support\n                try:\n                    self.sock = FakeSocket(self.sock, socket.ssl(self.sock))\n                except AttributeError:\n                    raise SpeedtestException(\n                        'This version of Python does not support HTTPS/SSL '\n                        'functionality'\n                    )\n            else:\n                raise SpeedtestException(\n                    'This version of Python does not support HTTPS/SSL '\n                    'functionality'\n                )\n\n\ndef _build_connection(connection, source_address, timeout, context=None):\n    \"\"\"Cross Python 2.4 - Python 3 callable to build an ``HTTPConnection`` or\n    ``HTTPSConnection`` with the args we need\n\n    Called from ``http(s)_open`` methods of ``SpeedtestHTTPHandler`` or\n    ``SpeedtestHTTPSHandler``\n    \"\"\"\n    def inner(host, **kwargs):\n        kwargs.update({\n            'source_address': source_address,\n            'timeout': timeout\n        })\n        if context:\n            kwargs['context'] = context\n        return connection(host, **kwargs)\n    return inner\n\n\nclass SpeedtestHTTPHandler(AbstractHTTPHandler):\n    \"\"\"Custom ``HTTPHandler`` that can build a ``HTTPConnection`` with the\n    args we need for ``source_address`` and ``timeout``\n    \"\"\"\n    def __init__(self, debuglevel=0, source_address=None, timeout=10):\n        AbstractHTTPHandler.__init__(self, debuglevel)\n        self.source_address = source_address\n        self.timeout = timeout\n\n    def http_open(self, req):\n        return self.do_open(\n            _build_connection(\n                SpeedtestHTTPConnection,\n                self.source_address,\n                self.timeout\n            ),\n            req\n        )\n\n    http_request = AbstractHTTPHandler.do_request_\n\n\nclass SpeedtestHTTPSHandler(AbstractHTTPHandler):\n    \"\"\"Custom ``HTTPSHandler`` that can build a ``HTTPSConnection`` with the\n    args we need for ``source_address`` and ``timeout``\n    \"\"\"\n    def __init__(self, debuglevel=0, context=None, source_address=None,\n                 timeout=10):\n        AbstractHTTPHandler.__init__(self, debuglevel)\n        self._context = context\n        self.source_address = source_address\n        self.timeout = timeout\n\n    def https_open(self, req):\n        return self.do_open(\n            _build_connection(\n                SpeedtestHTTPSConnection,\n                self.source_address,\n                self.timeout,\n                context=self._context,\n            ),\n            req\n        )\n\n    https_request = AbstractHTTPHandler.do_request_\n\n\ndef build_opener(source_address=None, timeout=10):\n    \"\"\"Function similar to ``urllib2.build_opener`` that will build\n    an ``OpenerDirector`` with the explicit handlers we want,\n    ``source_address`` for binding, ``timeout`` and our custom\n    `User-Agent`\n    \"\"\"\n\n    printer('Timeout set to %d' % timeout, debug=True)\n\n    if source_address:\n        source_address_tuple = (source_address, 0)\n        printer('Binding to source address: %r' % (source_address_tuple,),\n                debug=True)\n    else:\n        source_address_tuple = None\n\n    handlers = [\n        ProxyHandler(),\n        SpeedtestHTTPHandler(source_address=source_address_tuple,\n                             timeout=timeout),\n        SpeedtestHTTPSHandler(source_address=source_address_tuple,\n                              timeout=timeout),\n        HTTPDefaultErrorHandler(),\n        HTTPRedirectHandler(),\n        HTTPErrorProcessor()\n    ]\n\n    opener = OpenerDirector()\n    opener.addheaders = [('User-agent', build_user_agent())]\n\n    for handler in handlers:\n        opener.add_handler(handler)\n\n    return opener\n\n\nclass GzipDecodedResponse(GZIP_BASE):\n    \"\"\"A file-like object to decode a response encoded with the gzip\n    method, as described in RFC 1952.\n\n    Largely copied from ``xmlrpclib``/``xmlrpc.client`` and modified\n    to work for py2.4-py3\n    \"\"\"\n    def __init__(self, response):\n        # response doesn't support tell() and read(), required by\n        # GzipFile\n        if not gzip:\n            raise SpeedtestHTTPError('HTTP response body is gzip encoded, '\n                                     'but gzip support is not available')\n        IO = BytesIO or StringIO\n        self.io = IO()\n        while 1:\n            chunk = response.read(1024)\n            if len(chunk) == 0:\n                break\n            self.io.write(chunk)\n        self.io.seek(0)\n        gzip.GzipFile.__init__(self, mode='rb', fileobj=self.io)\n\n    def close(self):\n        try:\n            gzip.GzipFile.close(self)\n        finally:\n            self.io.close()\n\n\ndef get_exception():\n    \"\"\"Helper function to work with py2.4-py3 for getting the current\n    exception in a try/except block\n    \"\"\"\n    return sys.exc_info()[1]\n\n\ndef distance(origin, destination):\n    \"\"\"Determine distance between 2 sets of [lat,lon] in km\"\"\"\n\n    lat1, lon1 = origin\n    lat2, lon2 = destination\n    radius = 6371  # km\n\n    dlat = math.radians(lat2 - lat1)\n    dlon = math.radians(lon2 - lon1)\n    a = (math.sin(dlat / 2) * math.sin(dlat / 2) +\n         math.cos(math.radians(lat1)) *\n         math.cos(math.radians(lat2)) * math.sin(dlon / 2) *\n         math.sin(dlon / 2))\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    d = radius * c\n\n    return d\n\n\ndef build_user_agent():\n    \"\"\"Build a Mozilla/5.0 compatible User-Agent string\"\"\"\n\n    ua_tuple = (\n        'Mozilla/5.0',\n        '(%s; U; %s; en-us)' % (platform.platform(),\n                                platform.architecture()[0]),\n        'Python/%s' % platform.python_version(),\n        '(KHTML, like Gecko)',\n        'speedtest-cli/%s' % __version__\n    )\n    user_agent = ' '.join(ua_tuple)\n    printer('User-Agent: %s' % user_agent, debug=True)\n    return user_agent\n\n\ndef build_request(url, data=None, headers=None, bump='0', secure=False):\n    \"\"\"Build a urllib2 request object\n\n    This function automatically adds a User-Agent header to all requests\n\n    \"\"\"\n\n    if not headers:\n        headers = {}\n\n    if url[0] == ':':\n        scheme = ('http', 'https')[bool(secure)]\n        schemed_url = '%s%s' % (scheme, url)\n    else:\n        schemed_url = url\n\n    if '?' in url:\n        delim = '&'\n    else:\n        delim = '?'\n\n    # WHO YOU GONNA CALL? CACHE BUSTERS!\n    final_url = '%s%sx=%s.%s' % (schemed_url, delim,\n                                 int(timeit.time.time() * 1000),\n                                 bump)\n\n    headers.update({\n        'Cache-Control': 'no-cache',\n    })\n\n    printer('%s %s' % (('GET', 'POST')[bool(data)], final_url),\n            debug=True)\n\n    return Request(final_url, data=data, headers=headers)\n\n\ndef catch_request(request, opener=None):\n    \"\"\"Helper function to catch common exceptions encountered when\n    establishing a connection with a HTTP/HTTPS request\n\n    \"\"\"\n\n    if opener:\n        _open = opener.open\n    else:\n        _open = urlopen\n\n    try:\n        uh = _open(request)\n        if request.get_full_url() != uh.geturl():\n            printer('Redirected to %s' % uh.geturl(), debug=True)\n        return uh, False\n    except HTTP_ERRORS:\n        e = get_exception()\n        return None, e\n\n\ndef get_response_stream(response):\n    \"\"\"Helper function to return either a Gzip reader if\n    ``Content-Encoding`` is ``gzip`` otherwise the response itself\n\n    \"\"\"\n\n    try:\n        getheader = response.headers.getheader\n    except AttributeError:\n        getheader = response.getheader\n\n    if getheader('content-encoding') == 'gzip':\n        return GzipDecodedResponse(response)\n\n    return response\n\n\ndef get_attributes_by_tag_name(dom, tag_name):\n    \"\"\"Retrieve an attribute from an XML document and return it in a\n    consistent format\n\n    Only used with xml.dom.minidom, which is likely only to be used\n    with python versions older than 2.5\n    \"\"\"\n    elem = dom.getElementsByTagName(tag_name)[0]\n    return dict(list(elem.attributes.items()))\n\n\ndef print_dots(shutdown_event):\n    \"\"\"Built in callback function used by Thread classes for printing\n    status\n    \"\"\"\n    def inner(current, total, start=False, end=False):\n        if event_is_set(shutdown_event):\n            return\n\n        sys.stdout.write('.')\n        if current + 1 == total and end is True:\n            sys.stdout.write('\\n')\n        sys.stdout.flush()\n    return inner\n\n\ndef do_nothing(*args, **kwargs):\n    pass\n\n\nclass HTTPDownloader(threading.Thread):\n    \"\"\"Thread class for retrieving a URL\"\"\"\n\n    def __init__(self, i, request, start, timeout, opener=None,\n                 shutdown_event=None):\n        threading.Thread.__init__(self)\n        self.request = request\n        self.result = [0]\n        self.starttime = start\n        self.timeout = timeout\n        self.i = i\n        if opener:\n            self._opener = opener.open\n        else:\n            self._opener = urlopen\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n    def run(self):\n        try:\n            if (timeit.default_timer() - self.starttime) <= self.timeout:\n                f = self._opener(self.request)\n                while (not event_is_set(self._shutdown_event) and\n                        (timeit.default_timer() - self.starttime) <=\n                        self.timeout):\n                    self.result.append(len(f.read(10240)))\n                    if self.result[-1] == 0:\n                        break\n                f.close()\n        except IOError:\n            pass\n        except HTTP_ERRORS:\n            pass\n\n\nclass HTTPUploaderData(object):\n    \"\"\"File like object to improve cutting off the upload once the timeout\n    has been reached\n    \"\"\"\n\n    def __init__(self, length, start, timeout, shutdown_event=None):\n        self.length = length\n        self.start = start\n        self.timeout = timeout\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n        self._data = None\n\n        self.total = [0]\n\n    def pre_allocate(self):\n        chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        multiplier = int(round(int(self.length) / 36.0))\n        IO = BytesIO or StringIO\n        try:\n            self._data = IO(\n                ('content1=%s' %\n                 (chars * multiplier)[0:int(self.length) - 9]\n                 ).encode()\n            )\n        except MemoryError:\n            raise SpeedtestCLIError(\n                'Insufficient memory to pre-allocate upload data. Please '\n                'use --no-pre-allocate'\n            )\n\n    @property\n    def data(self):\n        if not self._data:\n            self.pre_allocate()\n        return self._data\n\n    def read(self, n=10240):\n        if ((timeit.default_timer() - self.start) <= self.timeout and\n                not event_is_set(self._shutdown_event)):\n            chunk = self.data.read(n)\n            self.total.append(len(chunk))\n            return chunk\n        else:\n            raise SpeedtestUploadTimeout()\n\n    def __len__(self):\n        return self.length\n\n\nclass HTTPUploader(threading.Thread):\n    \"\"\"Thread class for putting a URL\"\"\"\n\n    def __init__(self, i, request, start, size, timeout, opener=None,\n                 shutdown_event=None):\n        threading.Thread.__init__(self)\n        self.request = request\n        self.request.data.start = self.starttime = start\n        self.size = size\n        self.result = 0\n        self.timeout = timeout\n        self.i = i\n\n        if opener:\n            self._opener = opener.open\n        else:\n            self._opener = urlopen\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n    def run(self):\n        request = self.request\n        try:\n            if ((timeit.default_timer() - self.starttime) <= self.timeout and\n                    not event_is_set(self._shutdown_event)):\n                try:\n                    f = self._opener(request)\n                except TypeError:\n                    # PY24 expects a string or buffer\n                    # This also causes issues with Ctrl-C, but we will concede\n                    # for the moment that Ctrl-C on PY24 isn't immediate\n                    request = build_request(self.request.get_full_url(),\n                                            data=request.data.read(self.size))\n                    f = self._opener(request)\n                f.read(11)\n                f.close()\n                self.result = sum(self.request.data.total)\n            else:\n                self.result = 0\n        except (IOError, SpeedtestUploadTimeout):\n            self.result = sum(self.request.data.total)\n        except HTTP_ERRORS:\n            self.result = 0\n\n\nclass SpeedtestResults(object):\n    \"\"\"Class for holding the results of a speedtest, including:\n\n    Download speed\n    Upload speed\n    Ping/Latency to test server\n    Data about server that the test was run against\n\n    Additionally this class can return a result data as a dictionary or CSV,\n    as well as submit a POST of the result data to the speedtest.net API\n    to get a share results image link.\n    \"\"\"\n\n    def __init__(self, download=0, upload=0, ping=0, server=None, client=None,\n                 opener=None, secure=False):\n        self.download = download\n        self.upload = upload\n        self.ping = ping\n        if server is None:\n            self.server = {}\n        else:\n            self.server = server\n        self.client = client or {}\n\n        self._share = None\n        self.timestamp = '%sZ' % datetime.datetime.now(datetime.timezone.utc).isoformat()\n        self.bytes_received = 0\n        self.bytes_sent = 0\n\n        if opener:\n            self._opener = opener\n        else:\n            self._opener = build_opener()\n\n        self._secure = secure\n\n    def __repr__(self):\n        return repr(self.dict())\n\n    def share(self):\n        \"\"\"POST data to the speedtest.net API to obtain a share results\n        link\n        \"\"\"\n\n        if self._share:\n            return self._share\n\n        download = int(round(self.download / 1000.0, 0))\n        ping = int(round(self.ping, 0))\n        upload = int(round(self.upload / 1000.0, 0))\n\n        # Build the request to send results back to speedtest.net\n        # We use a list instead of a dict because the API expects parameters\n        # in a certain order\n        api_data = [\n            'recommendedserverid=%s' % self.server['id'],\n            'ping=%s' % ping,\n            'screenresolution=',\n            'promo=',\n            'download=%s' % download,\n            'screendpi=',\n            'upload=%s' % upload,\n            'testmethod=http',\n            'hash=%s' % md5(('%s-%s-%s-%s' %\n                             (ping, upload, download, '297aae72'))\n                            .encode()).hexdigest(),\n            'touchscreen=none',\n            'startmode=pingselect',\n            'accuracy=1',\n            'bytesreceived=%s' % self.bytes_received,\n            'bytessent=%s' % self.bytes_sent,\n            'serverid=%s' % self.server['id'],\n        ]\n\n        headers = {'Referer': 'http://c.speedtest.net/flash/speedtest.swf'}\n        request = build_request('://www.speedtest.net/api/api.php',\n                                data='&'.join(api_data).encode(),\n                                headers=headers, secure=self._secure)\n        f, e = catch_request(request, opener=self._opener)\n        if e:\n            raise ShareResultsConnectFailure(e)\n\n        response = f.read()\n        code = f.code\n        f.close()\n\n        if int(code) != 200:\n            raise ShareResultsSubmitFailure('Could not submit results to '\n                                            'speedtest.net')\n\n        qsargs = parse_qs(response.decode())\n        resultid = qsargs.get('resultid')\n        if not resultid or len(resultid) != 1:\n            raise ShareResultsSubmitFailure('Could not submit results to '\n                                            'speedtest.net')\n\n        self._share = 'http://www.speedtest.net/result/%s.png' % resultid[0]\n\n        return self._share\n\n    def dict(self):\n        \"\"\"Return dictionary of result data\"\"\"\n\n        return {\n            'download': self.download,\n            'upload': self.upload,\n            'ping': self.ping,\n            'server': self.server,\n            'timestamp': self.timestamp,\n            'bytes_sent': self.bytes_sent,\n            'bytes_received': self.bytes_received,\n            'share': self._share,\n            'client': self.client,\n        }\n\n    @staticmethod\n    def csv_header(delimiter=','):\n        \"\"\"Return CSV Headers\"\"\"\n\n        row = ['Server ID', 'Sponsor', 'Server Name', 'Timestamp', 'Distance',\n               'Ping', 'Download', 'Upload', 'Share', 'IP Address']\n        out = StringIO()\n        writer = csv.writer(out, delimiter=delimiter, lineterminator='')\n        writer.writerow([to_utf8(v) for v in row])\n        return out.getvalue()\n\n    def csv(self, delimiter=','):\n        \"\"\"Return data in CSV format\"\"\"\n\n        data = self.dict()\n        out = StringIO()\n        writer = csv.writer(out, delimiter=delimiter, lineterminator='')\n        row = [data['server']['id'], data['server']['sponsor'],\n               data['server']['name'], data['timestamp'],\n               data['server']['d'], data['ping'], data['download'],\n               data['upload'], self._share or '', self.client['ip']]\n        writer.writerow([to_utf8(v) for v in row])\n        return out.getvalue()\n\n    def json(self, pretty=False):\n        \"\"\"Return data in JSON format\"\"\"\n\n        kwargs = {}\n        if pretty:\n            kwargs.update({\n                'indent': 4,\n                'sort_keys': True\n            })\n        return json.dumps(self.dict(), **kwargs)\n\n\nclass Speedtest(object):\n    \"\"\"Class for performing standard speedtest.net testing operations\"\"\"\n\n    def __init__(self, config=None, source_address=None, timeout=10,\n                 secure=False, shutdown_event=None):\n        self.config = {}\n\n        self._source_address = source_address\n        self._timeout = timeout\n        self._opener = build_opener(source_address, timeout)\n\n        self._secure = secure\n\n        if shutdown_event:\n            self._shutdown_event = shutdown_event\n        else:\n            self._shutdown_event = FakeShutdownEvent()\n\n        self.get_config()\n        if config is not None:\n            self.config.update(config)\n\n        self.servers = {}\n        self.closest = []\n        self._best = {}\n\n        self.results = SpeedtestResults(\n            client=self.config['client'],\n            opener=self._opener,\n            secure=secure,\n        )\n\n    @property\n    def best(self):\n        if not self._best:\n            self.get_best_server()\n        return self._best\n\n    def get_config(self):\n        \"\"\"Download the speedtest.net configuration and return only the data\n        we are interested in\n        \"\"\"\n\n        headers = {}\n        if gzip:\n            headers['Accept-Encoding'] = 'gzip'\n        request = build_request('://www.speedtest.net/speedtest-config.php',\n                                headers=headers, secure=self._secure)\n        uh, e = catch_request(request, opener=self._opener)\n        if e:\n            raise ConfigRetrievalError(e)\n        configxml_list = []\n\n        stream = get_response_stream(uh)\n\n        while 1:\n            try:\n                configxml_list.append(stream.read(1024))\n            except (OSError, EOFError):\n                raise ConfigRetrievalError(get_exception())\n            if len(configxml_list[-1]) == 0:\n                break\n        stream.close()\n        uh.close()\n\n        if int(uh.code) != 200:\n            return None\n\n        configxml = ''.encode().join(configxml_list)\n\n        printer('Config XML:\\n%s' % configxml, debug=True)\n\n        try:\n            try:\n                root = ET.fromstring(configxml)\n            except ET.ParseError:\n                e = get_exception()\n                raise SpeedtestConfigError(\n                    'Malformed speedtest.net configuration: %s' % e\n                )\n            server_config = root.find('server-config').attrib\n            download = root.find('download').attrib\n            upload = root.find('upload').attrib\n            # times = root.find('times').attrib\n            client = root.find('client').attrib\n\n        except AttributeError:\n            try:\n                root = DOM.parseString(configxml)\n            except ExpatError:\n                e = get_exception()\n                raise SpeedtestConfigError(\n                    'Malformed speedtest.net configuration: %s' % e\n                )\n            server_config = get_attributes_by_tag_name(root, 'server-config')\n            download = get_attributes_by_tag_name(root, 'download')\n            upload = get_attributes_by_tag_name(root, 'upload')\n            # times = get_attributes_by_tag_name(root, 'times')\n            client = get_attributes_by_tag_name(root, 'client')\n\n        ignore_servers = [\n            int(i) for i in server_config['ignoreids'].split(',') if i\n        ]\n\n        ratio = int(upload['ratio'])\n        upload_max = int(upload['maxchunkcount'])\n        up_sizes = [32768, 65536, 131072, 262144, 524288, 1048576, 7340032]\n        sizes = {\n            'upload': up_sizes[ratio - 1:],\n            'download': [350, 500, 750, 1000, 1500, 2000, 2500,\n                         3000, 3500, 4000]\n        }\n\n        size_count = len(sizes['upload'])\n\n        upload_count = int(math.ceil(upload_max / size_count))\n\n        counts = {\n            'upload': upload_count,\n            'download': int(download['threadsperurl'])\n        }\n\n        threads = {\n            'upload': int(upload['threads']),\n            'download': int(server_config['threadcount']) * 2\n        }\n\n        length = {\n            'upload': int(upload['testlength']),\n            'download': int(download['testlength'])\n        }\n\n        self.config.update({\n            'client': client,\n            'ignore_servers': ignore_servers,\n            'sizes': sizes,\n            'counts': counts,\n            'threads': threads,\n            'length': length,\n            'upload_max': upload_count * size_count\n        })\n\n        try:\n            self.lat_lon = (float(client['lat']), float(client['lon']))\n        except ValueError:\n            raise SpeedtestConfigError(\n                'Unknown location: lat=%r lon=%r' %\n                (client.get('lat'), client.get('lon'))\n            )\n\n        printer('Config:\\n%r' % self.config, debug=True)\n\n        return self.config\n\n    def get_servers(self, servers=None, exclude=None):\n        \"\"\"Retrieve a the list of speedtest.net servers, optionally filtered\n        to servers matching those specified in the ``servers`` argument\n        \"\"\"\n        if servers is None:\n            servers = []\n\n        if exclude is None:\n            exclude = []\n\n        self.servers.clear()\n\n        for server_list in (servers, exclude):\n            for i, s in enumerate(server_list):\n                try:\n                    server_list[i] = int(s)\n                except ValueError:\n                    raise InvalidServerIDType(\n                        '%s is an invalid server type, must be int' % s\n                    )\n\n        urls = [\n            '://www.speedtest.net/speedtest-servers-static.php',\n            'http://c.speedtest.net/speedtest-servers-static.php',\n            '://www.speedtest.net/speedtest-servers.php',\n            'http://c.speedtest.net/speedtest-servers.php',\n        ]\n\n        headers = {}\n        if gzip:\n            headers['Accept-Encoding'] = 'gzip'\n\n        errors = []\n        for url in urls:\n            try:\n                request = build_request(\n                    '%s?threads=%s' % (url,\n                                       self.config['threads']['download']),\n                    headers=headers,\n                    secure=self._secure\n                )\n                uh, e = catch_request(request, opener=self._opener)\n                if e:\n                    errors.append('%s' % e)\n                    raise ServersRetrievalError()\n\n                stream = get_response_stream(uh)\n\n                serversxml_list = []\n                while 1:\n                    try:\n                        serversxml_list.append(stream.read(1024))\n                    except (OSError, EOFError):\n                        raise ServersRetrievalError(get_exception())\n                    if len(serversxml_list[-1]) == 0:\n                        break\n\n                stream.close()\n                uh.close()\n\n                if int(uh.code) != 200:\n                    raise ServersRetrievalError()\n\n                serversxml = ''.encode().join(serversxml_list)\n\n                printer('Servers XML:\\n%s' % serversxml, debug=True)\n\n                try:\n                    try:\n                        try:\n                            root = ET.fromstring(serversxml)\n                        except ET.ParseError:\n                            e = get_exception()\n                            raise SpeedtestServersError(\n                                'Malformed speedtest.net server list: %s' % e\n                            )\n                        elements = etree_iter(root, 'server')\n                    except AttributeError:\n                        try:\n                            root = DOM.parseString(serversxml)\n                        except ExpatError:\n                            e = get_exception()\n                            raise SpeedtestServersError(\n                                'Malformed speedtest.net server list: %s' % e\n                            )\n                        elements = root.getElementsByTagName('server')\n                except (SyntaxError, xml.parsers.expat.ExpatError):\n                    raise ServersRetrievalError()\n\n                for server in elements:\n                    try:\n                        attrib = server.attrib\n                    except AttributeError:\n                        attrib = dict(list(server.attributes.items()))\n\n                    if servers and int(attrib.get('id')) not in servers:\n                        continue\n\n                    if (int(attrib.get('id')) in self.config['ignore_servers']\n                            or int(attrib.get('id')) in exclude):\n                        continue\n\n                    try:\n                        d = distance(self.lat_lon,\n                                     (float(attrib.get('lat')),\n                                      float(attrib.get('lon'))))\n                    except Exception:\n                        continue\n\n                    attrib['d'] = d\n\n                    try:\n                        self.servers[d].append(attrib)\n                    except KeyError:\n                        self.servers[d] = [attrib]\n\n                break\n\n            except ServersRetrievalError:\n                continue\n\n        if (servers or exclude) and not self.servers:\n            raise NoMatchedServers()\n\n        return self.servers\n\n    def set_mini_server(self, server):\n        \"\"\"Instead of querying for a list of servers, set a link to a\n        speedtest mini server\n        \"\"\"\n\n        urlparts = urlparse(server)\n\n        name, ext = os.path.splitext(urlparts[2])\n        if ext:\n            url = os.path.dirname(server)\n        else:\n            url = server\n\n        request = build_request(url)\n        uh, e = catch_request(request, opener=self._opener)\n        if e:\n            raise SpeedtestMiniConnectFailure('Failed to connect to %s' %\n                                              server)\n        else:\n            text = uh.read()\n            uh.close()\n\n        extension = re.findall('upload_?[Ee]xtension: \"([^\"]+)\"',\n                               text.decode())\n        if not extension:\n            for ext in ['php', 'asp', 'aspx', 'jsp']:\n                try:\n                    f = self._opener.open(\n                        '%s/speedtest/upload.%s' % (url, ext)\n                    )\n                except Exception:\n                    pass\n                else:\n                    data = f.read().strip().decode()\n                    if (f.code == 200 and\n                            len(data.splitlines()) == 1 and\n                            re.match('size=[0-9]', data)):\n                        extension = [ext]\n                        break\n        if not urlparts or not extension:\n            raise InvalidSpeedtestMiniServer('Invalid Speedtest Mini Server: '\n                                             '%s' % server)\n\n        self.servers = [{\n            'sponsor': 'Speedtest Mini',\n            'name': urlparts[1],\n            'd': 0,\n            'url': '%s/speedtest/upload.%s' % (url.rstrip('/'), extension[0]),\n            'latency': 0,\n            'id': 0\n        }]\n\n        return self.servers\n\n    def get_closest_servers(self, limit=5):\n        \"\"\"Limit servers to the closest speedtest.net servers based on\n        geographic distance\n        \"\"\"\n\n        if not self.servers:\n            self.get_servers()\n\n        for d in sorted(self.servers.keys()):\n            for s in self.servers[d]:\n                self.closest.append(s)\n                if len(self.closest) == limit:\n                    break\n            else:\n                continue\n            break\n\n        printer('Closest Servers:\\n%r' % self.closest, debug=True)\n        return self.closest\n\n    def get_best_server(self, servers=None):\n        \"\"\"Perform a speedtest.net \"ping\" to determine which speedtest.net\n        server has the lowest latency\n        \"\"\"\n\n        if not servers:\n            if not self.closest:\n                servers = self.get_closest_servers()\n            servers = self.closest\n\n        if self._source_address:\n            source_address_tuple = (self._source_address, 0)\n        else:\n            source_address_tuple = None\n\n        user_agent = build_user_agent()\n\n        results = {}\n        for server in servers:\n            cum = []\n            url = os.path.dirname(server['url'])\n            stamp = int(timeit.time.time() * 1000)\n            latency_url = '%s/latency.txt?x=%s' % (url, stamp)\n            for i in range(0, 3):\n                this_latency_url = '%s.%s' % (latency_url, i)\n                printer('%s %s' % ('GET', this_latency_url),\n                        debug=True)\n                urlparts = urlparse(latency_url)\n                try:\n                    if urlparts[0] == 'https':\n                        h = SpeedtestHTTPSConnection(\n                            urlparts[1],\n                            source_address=source_address_tuple\n                        )\n                    else:\n                        h = SpeedtestHTTPConnection(\n                            urlparts[1],\n                            source_address=source_address_tuple\n                        )\n                    headers = {'User-Agent': user_agent}\n                    path = '%s?%s' % (urlparts[2], urlparts[4])\n                    start = timeit.default_timer()\n                    h.request(\"GET\", path, headers=headers)\n                    r = h.getresponse()\n                    total = (timeit.default_timer() - start)\n                except HTTP_ERRORS:\n                    e = get_exception()\n                    printer('ERROR: %r' % e, debug=True)\n                    cum.append(3600)\n                    continue\n\n                text = r.read(9)\n                if int(r.status) == 200 and text == 'test=test'.encode():\n                    cum.append(total)\n                else:\n                    cum.append(3600)\n                h.close()\n\n            avg = round((sum(cum) / 6) * 1000.0, 3)\n            results[avg] = server\n\n        try:\n            fastest = sorted(results.keys())[0]\n        except IndexError:\n            raise SpeedtestBestServerFailure('Unable to connect to servers to '\n                                             'test latency.')\n        best = results[fastest]\n        best['latency'] = fastest\n\n        self.results.ping = fastest\n        self.results.server = best\n\n        self._best.update(best)\n        printer('Best Server:\\n%r' % best, debug=True)\n        return best\n\n    def download(self, callback=do_nothing, threads=None):\n        \"\"\"Test download speed against speedtest.net\n\n        A ``threads`` value of ``None`` will fall back to those dictated\n        by the speedtest.net configuration\n        \"\"\"\n\n        urls = []\n        for size in self.config['sizes']['download']:\n            for _ in range(0, self.config['counts']['download']):\n                urls.append('%s/random%sx%s.jpg' %\n                            (os.path.dirname(self.best['url']), size, size))\n\n        request_count = len(urls)\n        requests = []\n        for i, url in enumerate(urls):\n            requests.append(\n                build_request(url, bump=i, secure=self._secure)\n            )\n\n        max_threads = threads or self.config['threads']['download']\n        in_flight = {'threads': 0}\n\n        def producer(q, requests, request_count):\n            for i, request in enumerate(requests):\n                thread = HTTPDownloader(\n                    i,\n                    request,\n                    start,\n                    self.config['length']['download'],\n                    opener=self._opener,\n                    shutdown_event=self._shutdown_event\n                )\n                while in_flight['threads'] >= max_threads:\n                    timeit.time.sleep(0.001)\n                thread.start()\n                q.put(thread, True)\n                in_flight['threads'] += 1\n                callback(i, request_count, start=True)\n\n        finished = []\n\n        def consumer(q, request_count):\n            _is_alive = thread_is_alive\n            while len(finished) < request_count:\n                thread = q.get(True)\n                while _is_alive(thread):\n                    thread.join(timeout=0.001)\n                in_flight['threads'] -= 1\n                finished.append(sum(thread.result))\n                callback(thread.i, request_count, end=True)\n\n        q = Queue(max_threads)\n        prod_thread = threading.Thread(target=producer,\n                                       args=(q, requests, request_count))\n        cons_thread = threading.Thread(target=consumer,\n                                       args=(q, request_count))\n        start = timeit.default_timer()\n        prod_thread.start()\n        cons_thread.start()\n        _is_alive = thread_is_alive\n        while _is_alive(prod_thread):\n            prod_thread.join(timeout=0.001)\n        while _is_alive(cons_thread):\n            cons_thread.join(timeout=0.001)\n\n        stop = timeit.default_timer()\n        self.results.bytes_received = sum(finished)\n        self.results.download = (\n            (self.results.bytes_received / (stop - start)) * 8.0\n        )\n        if self.results.download > 100000:\n            self.config['threads']['upload'] = 8\n        return self.results.download\n\n    def upload(self, callback=do_nothing, pre_allocate=True, threads=None):\n        \"\"\"Test upload speed against speedtest.net\n\n        A ``threads`` value of ``None`` will fall back to those dictated\n        by the speedtest.net configuration\n        \"\"\"\n\n        sizes = []\n\n        for size in self.config['sizes']['upload']:\n            for _ in range(0, self.config['counts']['upload']):\n                sizes.append(size)\n\n        # request_count = len(sizes)\n        request_count = self.config['upload_max']\n\n        requests = []\n        for i, size in enumerate(sizes):\n            # We set ``0`` for ``start`` and handle setting the actual\n            # ``start`` in ``HTTPUploader`` to get better measurements\n            data = HTTPUploaderData(\n                size,\n                0,\n                self.config['length']['upload'],\n                shutdown_event=self._shutdown_event\n            )\n            if pre_allocate:\n                data.pre_allocate()\n\n            headers = {'Content-length': size}\n            requests.append(\n                (\n                    build_request(self.best['url'], data, secure=self._secure,\n                                  headers=headers),\n                    size\n                )\n            )\n\n        max_threads = threads or self.config['threads']['upload']\n        in_flight = {'threads': 0}\n\n        def producer(q, requests, request_count):\n            for i, request in enumerate(requests[:request_count]):\n                thread = HTTPUploader(\n                    i,\n                    request[0],\n                    start,\n                    request[1],\n                    self.config['length']['upload'],\n                    opener=self._opener,\n                    shutdown_event=self._shutdown_event\n                )\n                while in_flight['threads'] >= max_threads:\n                    timeit.time.sleep(0.001)\n                thread.start()\n                q.put(thread, True)\n                in_flight['threads'] += 1\n                callback(i, request_count, start=True)\n\n        finished = []\n\n        def consumer(q, request_count):\n            _is_alive = thread_is_alive\n            while len(finished) < request_count:\n                thread = q.get(True)\n                while _is_alive(thread):\n                    thread.join(timeout=0.001)\n                in_flight['threads'] -= 1\n                finished.append(thread.result)\n                callback(thread.i, request_count, end=True)\n\n        q = Queue(threads or self.config['threads']['upload'])\n        prod_thread = threading.Thread(target=producer,\n                                       args=(q, requests, request_count))\n        cons_thread = threading.Thread(target=consumer,\n                                       args=(q, request_count))\n        start = timeit.default_timer()\n        prod_thread.start()\n        cons_thread.start()\n        _is_alive = thread_is_alive\n        while _is_alive(prod_thread):\n            prod_thread.join(timeout=0.1)\n        while _is_alive(cons_thread):\n            cons_thread.join(timeout=0.1)\n\n        stop = timeit.default_timer()\n        self.results.bytes_sent = sum(finished)\n        self.results.upload = (\n            (self.results.bytes_sent / (stop - start)) * 8.0\n        )\n        return self.results.upload\n\n\ndef ctrl_c(shutdown_event):\n    \"\"\"Catch Ctrl-C key sequence and set a SHUTDOWN_EVENT for our threaded\n    operations\n    \"\"\"\n    def inner(signum, frame):\n        shutdown_event.set()\n        printer('\\nCancelling...', error=True)\n        sys.exit(0)\n    return inner\n\n\ndef version():\n    \"\"\"Print the version\"\"\"\n\n    printer('speedtest-cli %s' % __version__)\n    printer('Python %s' % sys.version.replace('\\n', ''))\n    sys.exit(0)\n\n\ndef csv_header(delimiter=','):\n    \"\"\"Print the CSV Headers\"\"\"\n\n    printer(SpeedtestResults.csv_header(delimiter=delimiter))\n    sys.exit(0)\n\n\ndef parse_args():\n    \"\"\"Function to handle building and parsing of command line arguments\"\"\"\n    description = (\n        'Command line interface for testing internet bandwidth using '\n        'speedtest.net.\\n'\n        '------------------------------------------------'\n        '--------------\\n'\n        'https://github.com/sivel/speedtest-cli')\n\n    parser = ArgParser(description=description)\n    # Give optparse.OptionParser an `add_argument` method for\n    # compatibility with argparse.ArgumentParser\n    try:\n        parser.add_argument = parser.add_option\n    except AttributeError:\n        pass\n    parser.add_argument('--no-download', dest='download', default=True,\n                        action='store_const', const=False,\n                        help='Do not perform download test')\n    parser.add_argument('--no-upload', dest='upload', default=True,\n                        action='store_const', const=False,\n                        help='Do not perform upload test')\n    parser.add_argument('--single', default=False, action='store_true',\n                        help='Only use a single connection instead of '\n                             'multiple. This simulates a typical file '\n                             'transfer.')\n    parser.add_argument('--bytes', dest='units', action='store_const',\n                        const=('byte', 8), default=('bit', 1),\n                        help='Display values in bytes instead of bits. Does '\n                             'not affect the image generated by --share, nor '\n                             'output from --json or --csv')\n    parser.add_argument('--share', action='store_true',\n                        help='Generate and provide a URL to the speedtest.net '\n                             'share results image, not displayed with --csv')\n    parser.add_argument('--simple', action='store_true', default=False,\n                        help='Suppress verbose output, only show basic '\n                             'information')\n    parser.add_argument('--csv', action='store_true', default=False,\n                        help='Suppress verbose output, only show basic '\n                             'information in CSV format. Speeds listed in '\n                             'bit/s and not affected by --bytes')\n    parser.add_argument('--csv-delimiter', default=',', type=PARSER_TYPE_STR,\n                        help='Single character delimiter to use in CSV '\n                             'output. Default \",\"')\n    parser.add_argument('--csv-header', action='store_true', default=False,\n                        help='Print CSV headers')\n    parser.add_argument('--json', action='store_true', default=False,\n                        help='Suppress verbose output, only show basic '\n                             'information in JSON format. Speeds listed in '\n                             'bit/s and not affected by --bytes')\n    parser.add_argument('--list', action='store_true',\n                        help='Display a list of speedtest.net servers '\n                             'sorted by distance')\n    parser.add_argument('--server', type=PARSER_TYPE_INT, action='append',\n                        help='Specify a server ID to test against. Can be '\n                             'supplied multiple times')\n    parser.add_argument('--exclude', type=PARSER_TYPE_INT, action='append',\n                        help='Exclude a server from selection. Can be '\n                             'supplied multiple times')\n    parser.add_argument('--mini', help='URL of the Speedtest Mini server')\n    parser.add_argument('--source', help='Source IP address to bind to')\n    parser.add_argument('--timeout', default=10, type=PARSER_TYPE_FLOAT,\n                        help='HTTP timeout in seconds. Default 10')\n    parser.add_argument('--secure', action='store_true',\n                        help='Use HTTPS instead of HTTP when communicating '\n                             'with speedtest.net operated servers')\n    parser.add_argument('--no-pre-allocate', dest='pre_allocate',\n                        action='store_const', default=True, const=False,\n                        help='Do not pre allocate upload data. Pre allocation '\n                             'is enabled by default to improve upload '\n                             'performance. To support systems with '\n                             'insufficient memory, use this option to avoid a '\n                             'MemoryError')\n    parser.add_argument('--version', action='store_true',\n                        help='Show the version number and exit')\n    parser.add_argument('--debug', action='store_true',\n                        help=ARG_SUPPRESS, default=ARG_SUPPRESS)\n\n    options = parser.parse_args()\n    if isinstance(options, tuple):\n        args = options[0]\n    else:\n        args = options\n    return args\n\n\ndef validate_optional_args(args):\n    \"\"\"Check if an argument was provided that depends on a module that may\n    not be part of the Python standard library.\n\n    If such an argument is supplied, and the module does not exist, exit\n    with an error stating which module is missing.\n    \"\"\"\n    optional_args = {\n        'json': ('json/simplejson python module', json),\n        'secure': ('SSL support', HTTPSConnection),\n    }\n\n    for arg, info in optional_args.items():\n        if getattr(args, arg, False) and info[1] is None:\n            raise SystemExit('%s is not installed. --%s is '\n                             'unavailable' % (info[0], arg))\n\n\ndef printer(string, quiet=False, debug=False, error=False, **kwargs):\n    \"\"\"Helper function print a string with various features\"\"\"\n\n    if debug and not DEBUG:\n        return\n\n    if debug:\n        if sys.stdout.isatty():\n            out = '\\033[1;30mDEBUG: %s\\033[0m' % string\n        else:\n            out = 'DEBUG: %s' % string\n    else:\n        out = string\n\n    if error:\n        kwargs['file'] = sys.stderr\n\n    if not quiet:\n        print_(out, **kwargs)\n\n\ndef shell():\n    \"\"\"Run the full speedtest.net test\"\"\"\n\n    global DEBUG\n    shutdown_event = threading.Event()\n\n    signal.signal(signal.SIGINT, ctrl_c(shutdown_event))\n\n    args = parse_args()\n\n    # Print the version and exit\n    if args.version:\n        version()\n\n    if not args.download and not args.upload:\n        raise SpeedtestCLIError('Cannot supply both --no-download and '\n                                '--no-upload')\n\n    if len(args.csv_delimiter) != 1:\n        raise SpeedtestCLIError('--csv-delimiter must be a single character')\n\n    if args.csv_header:\n        csv_header(args.csv_delimiter)\n\n    validate_optional_args(args)\n\n    debug = getattr(args, 'debug', False)\n    if debug == 'SUPPRESSHELP':\n        debug = False\n    if debug:\n        DEBUG = True\n\n    if args.simple or args.csv or args.json:\n        quiet = True\n    else:\n        quiet = False\n\n    if args.csv or args.json:\n        machine_format = True\n    else:\n        machine_format = False\n\n    # Don't set a callback if we are running quietly\n    if quiet or debug:\n        callback = do_nothing\n    else:\n        callback = print_dots(shutdown_event)\n\n    printer('', quiet)\n    try:\n        speedtest = Speedtest(\n            source_address=args.source,\n            timeout=args.timeout,\n            secure=args.secure\n        )\n    except (ConfigRetrievalError,) + HTTP_ERRORS:\n        printer('Cannot retrieve speedtest configuration', error=True)\n        raise SpeedtestCLIError(get_exception())\n\n    if args.list:\n        try:\n            speedtest.get_servers()\n        except (ServersRetrievalError,) + HTTP_ERRORS:\n            printer('Cannot retrieve speedtest server list', error=True)\n            raise SpeedtestCLIError(get_exception())\n\n        for _, servers in sorted(speedtest.servers.items()):\n            for server in servers:\n                line = ('%(id)5s) %(sponsor)s (%(name)s, %(country)s) '\n                        '[%(d)0.2f km]' % server)\n                try:\n                    printer(line)\n                except IOError:\n                    e = get_exception()\n                    if e.errno != errno.EPIPE:\n                        raise\n        sys.exit(0)\n\n    printer('*üåÅ ·¥õ·¥ás·¥õ…™…¥…¢ “ì Ä·¥è·¥ç %(isp)s...*\\n' % speedtest.config['client'],\n            quiet)\n\n    if not args.mini:\n        printer('üìë  Ä·¥á·¥õ Ä…™·¥á·¥†…™…¥…¢ speedtest.net s·¥á Ä·¥†·¥á Ä  ü…™s·¥õ...', quiet)\n        try:\n            speedtest.get_servers(servers=args.server, exclude=args.exclude)\n        except NoMatchedServers:\n            raise SpeedtestCLIError(\n                'No matched servers: %s' %\n                ', '.join('%s' % s for s in args.server)\n            )\n        except (ServersRetrievalError,) + HTTP_ERRORS:\n            printer('Cannot retrieve speedtest server list', error=True)\n            raise SpeedtestCLIError(get_exception())\n        except InvalidServerIDType:\n            raise SpeedtestCLIError(\n                '%s is an invalid server type, must '\n                'be an int' % ', '.join('%s' % s for s in args.server)\n            )\n\n        if args.server and len(args.server) == 1:\n            printer('üìö Retrieving information for the selected server...', quiet)\n        else:\n            printer('üîç s·¥á ü·¥á·¥Ñ·¥õ…™…¥…¢  ô·¥ás·¥õ s·¥á Ä·¥†·¥á Ä  ô·¥Äs·¥á·¥Ö ·¥è…¥ ·¥ò…™…¥…¢...', quiet)\n        speedtest.get_best_server()\n    elif args.mini:\n        speedtest.get_best_server(speedtest.set_mini_server(args.mini))\n\n    results = speedtest.results\n\n    printer('\\n..................................................\\nüè† * ú·¥ès·¥õ·¥á·¥Ö  ô è :* %(sponsor)s\\nüåç * ü·¥è·¥Ñ·¥Ä·¥õ…™·¥è…¥ :* %(name)s [%(d)0.2f km] '\n            '\\n‚ö° *·¥ò…™…¥…¢ :* %(latency)s ms' % results.server, quiet)\n\n    if args.download:\n        printer('', quiet,\n                end=('', '\\n')[bool(debug)])\n        speedtest.download(\n            callback=callback,\n            threads=(None, 1)[args.single]\n        )\n        printer('*üì• ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö:* %0.2f M%s/s' %\n                ((results.download / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0]),\n                quiet)\n    else:\n        printer('Skipping download test', quiet)\n\n    if args.upload:\n        speedtest.upload()\n        printer('*üì§ ·¥ú·¥ò ü·¥è·¥Ä·¥Ö:* %0.2f M%s/s' %\n                ((results.upload / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0]),\n                quiet)\n        printer(\"\\n..................................................\\n‚Ü¨ ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è *s·¥ò·¥á·¥á·¥Ö·¥õ·¥ás·¥õ Ookla*\")\n    else:\n        printer('Skipping upload test', quiet)\n\n    printer('Results:\\n%r' % results.dict(), debug=True)\n\n    if not args.simple and args.share:\n        results.share()\n\n    if args.simple:\n        printer('Ping: %s ms\\nDownload: %0.2f M%s/s\\nUpload: %0.2f M%s/s' %\n                (results.ping,\n                 (results.download / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0],\n                 (results.upload / 1000.0 / 1000.0) / args.units[1],\n                 args.units[0]))\n    elif args.csv:\n        printer(results.csv(delimiter=args.csv_delimiter))\n    elif args.json:\n        printer(results.json())\n\n    if args.share and not machine_format:\n        printer('Share results: %s' % results.share())\n\n\ndef main():\n    try:\n        shell()\n    except KeyboardInterrupt:\n        printer('\\nCancelling...', error=True)\n    except (SpeedtestException, SystemExit):\n        e = get_exception()\n        # Ignore a successful exit, or argparse exit\n        if getattr(e, 'code', 1) not in (0, 2):\n            msg = '%s' % e\n            if not msg:\n                msg = '%r' % e\n            raise SystemExit('ERROR: %s' % msg)\n\n\nif __name__ == '__main__':\n    main()\n","path":null,"size_bytes":65448,"size_tokens":null},"ciel/lib/nulis.js":{"content":"const Jimp = require('jimp');\nconst fs = require('fs-extra');\nconst path = require('path');\n\nconst fontPath = path.join(__dirname, '../src/media/nulis/font');\nconst imagesPath = path.join(__dirname, '../src/media/nulis/images');\n\nasync function nulisBuku(text, halaman = 'kiri') {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const sebelum = halaman === 'kiri' ? 'sebelumkiri.jpg' : 'sebelumkanan.jpg';\n            const setelah = halaman === 'kiri' ? 'setelahkiri.jpg' : 'setelahkanan.jpg';\n            \n            const image = await Jimp.read(path.join(imagesPath, 'buku', sebelum));\n            const font = await Jimp.loadFont(Jimp.FONT_SANS_16_BLACK);\n            \n            const lines = text.match(/.{1,30}/g) || [text];\n            let y = 50;\n            \n            for (const line of lines.slice(0, 15)) {\n                image.print(font, 30, y, line);\n                y += 25;\n            }\n            \n            const buffer = await image.getBufferAsync(Jimp.MIME_JPEG);\n            resolve(buffer);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nasync function nulisFolio(text, halaman = 'kiri') {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const sebelum = halaman === 'kiri' ? 'sebelumkiri.jpg' : 'sebelumkanan.jpg';\n            \n            const image = await Jimp.read(path.join(imagesPath, 'folio', sebelum));\n            const font = await Jimp.loadFont(Jimp.FONT_SANS_16_BLACK);\n            \n            const lines = text.match(/.{1,40}/g) || [text];\n            let y = 80;\n            \n            for (const line of lines.slice(0, 20)) {\n                image.print(font, 50, y, line);\n                y += 28;\n            }\n            \n            const buffer = await image.getBufferAsync(Jimp.MIME_JPEG);\n            resolve(buffer);\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nmodule.exports = { nulisBuku, nulisFolio };\n","path":null,"size_bytes":1969,"size_tokens":null},"source-1/src/database.js":{"content":"require('../settings');\r\nconst fs = require('fs');\r\nconst toMs = require('ms');\r\nconst path = require('path');\r\nconst chalk = require('chalk');\r\nconst mongoose = require('mongoose');\r\n\r\nclass MongoDB {\r\n\tconstructor(url = global.tempatDB, options = { useNewUrlParser: true, useUnifiedTopology: true, serverSelectionTimeoutMS: 5000 }) {\r\n\t\tthis.url = url\r\n\t\tthis._model = null\r\n\t\tthis.options = options\r\n\t\tthis.isConnecting = false\r\n\t\tthis.isReconnecting = false\r\n\t\t\r\n\t\tmongoose.connection.on('disconnected', async () => {\r\n\t\t\tif (this.isReconnecting) return\r\n\t\t\tthis.isReconnecting = true\r\n\t\t\tconsole.warn('‚ùó MongoDB connection lost. Attempting to reconnect in 5 seconds...');\r\n\t\t\tawait new Promise(resolve => setTimeout(resolve, 5000));\r\n\t\t\tawait this.connect();\r\n\t\t});\r\n\t}\r\n\t\r\n\tconnect = async (retries = 5, delay = 2000) => {\r\n\t\tif (mongoose.connection.readyState === 1 || this.isConnecting) {\r\n\t\t\tconsole.log('‚úÖ MongoDB is already connected.');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.isConnecting = true;\r\n\t\twhile (retries > 0) {\r\n\t\t\ttry {\r\n\t\t\t\tconsole.log(`üîÑ Attempting to connect to MongoDB... (Attempt ${6 - retries}/5)`);\r\n\t\t\t\tif (mongoose.connection.readyState === 0) {\r\n\t\t\t\t\tawait mongoose.connect(this.url, { ...this.options });\r\n\t\t\t\t}\r\n\t\t\t\tif (!this._model) {\r\n\t\t\t\t\tconst schema = new mongoose.Schema({\r\n\t\t\t\t\t\tdata: { type: Object, required: true, default: {} }\r\n\t\t\t\t\t})\r\n\t\t\t\t\tthis._model = mongoose.models.data || mongoose.model('data', schema);\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log('‚úÖ Successfully connected to MongoDB.');\r\n\t\t\t\tthis.isConnecting = false;\r\n\t\t\t\tthis.isReconnecting = false;\r\n\t\t\t\treturn;\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.error(`‚ùå MongoDB connection failed: ${e.message}`);\r\n\t\t\t\tawait new Promise((res) => setTimeout(res, delay));\r\n\t\t\t\tretries--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.isConnecting = false;\r\n\t\tthrow new Error('‚ùå MongoDB connection failed after multiple attempts.');\r\n\t}\r\n\t\r\n\tread = async () => {\r\n\t\tif (mongoose.connection.readyState !== 1 && !this.isConnecting) {\r\n\t\t\tawait this.connect();\r\n\t\t}\r\n\t\tlet doc = await this._model.findOne({});\r\n\t\tif (!doc) {\r\n\t\t\tdoc = new this._model({ data: {} });\r\n\t\t\tawait doc.save();\r\n\t\t}\r\n\t\ttry {\r\n\t\t\treturn JSON.parse(doc.data);\r\n\t\t} catch {\r\n\t\t\treturn doc.data || {};\r\n\t\t}\r\n\t}\r\n\t\r\n\twrite = async (data) => {\r\n\t\tif (!data) return;\r\n\t\tif (mongoose.connection.readyState !== 1 && !this.isConnecting) {\r\n\t\t\tawait this.connect();\r\n\t\t}\r\n\t\tconst safeData = JSON.stringify(data, (key, value) => {\r\n\t\t\tif (typeof value === 'object' && value !== null && value._id) {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t\tawait this._model.findOneAndUpdate({}, { data: safeData }, { upsert: true, new: true, setDefaultsOnInsert: true });\r\n\t}\r\n}\r\n\r\nclass JsonDB {\r\n\tconstructor(file = global.tempatDB) {\r\n\t\tthis.data = {}\r\n\t\tthis.file = path.join(process.cwd(), 'database', file);\r\n\t\tthis.isWriting = false;\r\n\t\tthis.writePending = false;\r\n\t}\r\n\t\r\n\tread = async () => {\r\n\t\tlet data;\r\n\t\tif (fs.existsSync(this.file)) {\r\n\t\t\ttry {\r\n\t\t\t\tdata = JSON.parse(fs.readFileSync(this.file))\r\n\t\t\t} catch(e) {\r\n\t\t\t\tif (fs.existsSync(this.file + '.bak')) {\r\n\t\t\t\t\tdata = JSON.parse(fs.readFileSync(this.file + '.bak'))\r\n\t\t\t\t\tfs.writeFileSync(this.file, JSON.stringify(data, null, 2))\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdata = this.data\r\n\t\t\t\t\tfs.writeFileSync(this.file, JSON.stringify(this.data, null, 2))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tdata = this.data\r\n\t\t\tfs.mkdirSync(path.dirname(this.file), { recursive: true })\r\n\t\t\tfs.writeFileSync(this.file, JSON.stringify(this.data, null, 2))\r\n\t\t}\r\n\t\treturn data\r\n\t}\r\n\t\r\n\twrite = async (data) => {\r\n\t\tthis.data = data || global.db || {}\r\n\t\tif (this.isWriting) {\r\n\t\t\tthis.writePending = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.isWriting = true;\r\n\t\ttry {\r\n\t\t\tlet dirname = path.dirname(this.file)\r\n\t\t\tif (!fs.existsSync(dirname)) fs.mkdirSync(dirname, { recursive: true })\r\n\t\t\tif (fs.existsSync(this.file)) fs.copyFileSync(this.file, this.file + '.bak')\r\n\t\t\tif (Object.keys(this.data).length > 0) fs.writeFileSync(this.file, JSON.stringify(this.data, null, 2))\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error('‚ùå Write Database failed: ', e);\r\n\t\t} finally {\r\n\t\t\tthis.isWriting = false;\r\n\t\t\tif (this.writePending) {\r\n\t\t\t\tthis.writePending = false;\r\n\t\t\t\tawait this.write(this.data);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst dataBase = (source) => {\r\n\tif (/^mongodb(\\+srv)?:\\/\\//i.test(source)) {\r\n\t\treturn new MongoDB(source);\r\n\t}\r\n\treturn new JsonDB(source);\r\n}\r\n\r\nconst cmdAdd = (hit) => {\r\n\tif (hit && !hit.totalcmd) {\r\n\t\thit.totalcmd = 0;\r\n\t}\r\n\tif (hit && !hit.todaycmd) {\r\n\t\thit.todaycmd = 0;\r\n\t}\r\n\thit.totalcmd++;\r\n\thit.todaycmd++;\r\n}\r\nconst cmdDel = (hit) => {\r\n\thit.todaycmd = 0\r\n}\r\n\r\nconst cmdAddHit = (hit, feature) => {\r\n\tif (hit && !hit[feature]) {\r\n\t\thit[feature] = 0;\r\n\t}\r\n\tif (hit) hit[feature]++;\r\n}\r\n\r\nconst addExpired = ({ id, expired, ...options }, _dir) => {\r\n\tconst _cek = _dir.find((a) => a.id == id);\r\n\tif (_cek) {\r\n\t\t_cek.expired = _cek.expired + toMs(expired);\r\n\t} else {\r\n\t\t_dir.push({ id, expired: Date.now() + toMs(expired), ...options });\r\n\t}\r\n};\r\n\r\nconst getPosition = (id, _dir) => _dir.findIndex(a => a.id === id || a.url === id);\r\n\r\nconst getExpired = (id, _dir) => _dir.find(a => a.id === id || a.url === id)?.expired;\r\n\r\nconst getStatus = (id, _dir) => _dir.find(a => a.id === id || a.url === id);\r\n\r\nconst checkStatus = (id, _dir) => _dir.some(a => a.id === id || a.url === id);\r\n\r\nconst getAllExpired = (_dir) => _dir.map(a => a.id);\r\n\r\nconst checkExpired = (_dir, conn) => {\r\n\tsetInterval(() => {\r\n\t\tfor (let i = _dir.length - 1; i >= 0; i--) {\r\n\t\t\tif (Date.now() >= _dir[i].expired) {\r\n\t\t\t\tif (conn) {\r\n\t\t\t\t\tconn.groupLeave(_dir[i].id).catch(e => {});\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(`Expired: ${_dir[i].id}`);\r\n\t\t\t\t_dir.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}, 5 * 60 * 1000);\r\n};\r\n\r\nmodule.exports = {\r\n\tdataBase,\r\n\tcmdAdd,\r\n\tcmdDel,\r\n\tcmdAddHit,\r\n\taddExpired,\r\n\tgetPosition,\r\n\tgetStatus,\r\n\tgetExpired,\r\n\tcheckStatus,\r\n\tgetAllExpired,\r\n\tcheckExpired\r\n}\r\n\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});","path":null,"size_bytes":6079,"size_tokens":null},"source-2/lib/handlers/douyinHandler.js":{"content":"const SavetikAPI = require('../tikSnap.js');\nconst axios = require('axios');\nconst { logger } = require('../utils/logger.js');\n\nconst douyinApi = new SavetikAPI();\n\nasync function handleDouyinUrl(conn, m, url) {\n    try {\n        const result = await douyinApi.download({ url });\n        \n        if (result.downloadLinks?.length > 0) {\n            const videoUrl = result.downloadLinks[0].link;\n            const response = await axios.get(videoUrl, { responseType: 'arraybuffer' });\n            \n            await conn.sendMessage(m.key.remoteJid, {\n                video: response.data,\n                caption: `Douyin Video: ${result.videoTitle || 'No title'}`\n            });\n\n            logger.success(`‚úÖ Sent Douyin video: ${result.videoTitle || 'No title'}`);\n        }\n    } catch (e) {\n        logger.error(`Douyin API failed: ${e.message}`);\n        throw e;\n    }\n}\n\nmodule.exports = {\n    handleDouyinUrl\n};\n","path":null,"size_bytes":925,"size_tokens":null},"ciel/DEPLOYMENT.md":{"content":"# Panduan Deployment Ciel Bot\n\n## Persyaratan Sistem\n- Node.js v18 atau lebih tinggi\n- NPM atau Yarn\n- PostgreSQL (bisa menggunakan Railway, Supabase, Neon, dll)\n\n## Environment Variables\nBuat file `.env` atau set environment variables berikut:\n\n```env\nDATABASE_URL=postgresql://user:password@host:port/database\nBOT_NUMBER=628xxxxxxxxxx\nOWNER_NUMBER=628xxxxxxxxxx\nBOT_NAME=Ciel Bot\nGEMINI_API_KEY=your_gemini_api_key\nPORT=5000\n```\n\n---\n\n## 1. Railway Deployment\n\n### Langkah-langkah:\n1. Fork/Clone repository ini\n2. Buat project baru di [Railway](https://railway.app)\n3. Connect dengan GitHub repository\n4. Tambahkan environment variables di Railway Dashboard\n5. Deploy otomatis akan berjalan\n\n### File Konfigurasi:\n- `railway.json` - Konfigurasi build dan deploy\n- `railway.toml` - Konfigurasi alternatif\n\n---\n\n## 2. Replit Deployment\n\n### Langkah-langkah:\n1. Import repository ke Replit\n2. Tambahkan Secrets di panel Secrets:\n   - `DATABASE_URL`\n   - `BOT_NUMBER`\n   - `OWNER_NUMBER`\n3. Klik Run untuk menjalankan bot\n\n### Catatan:\n- Gunakan Replit Database atau koneksikan ke PostgreSQL eksternal\n- Bot akan menampilkan QR code di console\n\n---\n\n## 3. VPS/Termux Deployment\n\n### Menggunakan Script Start:\n```bash\n# Clone repository\ngit clone <repository-url>\ncd ciel\n\n# Jalankan dengan script\nchmod +x start.sh\n./start.sh\n```\n\n### Menggunakan PM2:\n```bash\n# Install PM2 secara global\nnpm install -g pm2\n\n# Install dependencies\nnpm install\n\n# Generate Prisma\nnpx prisma generate\n\n# Jalankan dengan PM2\npm2 start ecosystem.config.js\n\n# Lihat logs\npm2 logs ciel-bot\n\n# Restart bot\npm2 restart ciel-bot\n\n# Stop bot\npm2 stop ciel-bot\n```\n\n### Tanpa PM2:\n```bash\n# Install dependencies\nnpm install\n\n# Generate Prisma\nnpx prisma generate\n\n# Jalankan\nnpm start\n```\n\n---\n\n## 4. Pterodactyl Panel\n\n### Persyaratan:\n- Pterodactyl Panel dengan Node.js Egg\n- Minimal 1GB RAM\n\n### Langkah-langkah:\n1. Upload semua file ke server\n2. Set startup command: `npm start`\n3. Set environment variables di panel\n4. Mulai server\n\n### Startup Variables:\n| Variable | Deskripsi | Default |\n|----------|-----------|---------|\n| `DATABASE_URL` | PostgreSQL connection string | - |\n| `BOT_NUMBER` | Nomor WhatsApp bot | - |\n| `OWNER_NUMBER` | Nomor owner | - |\n| `PORT` | Port server | 5000 |\n\n---\n\n## Troubleshooting\n\n### Bot tidak connect ke WhatsApp\n1. Hapus folder `ciel_session`\n2. Restart bot\n3. Scan QR code baru\n\n### Database Error\n1. Pastikan `DATABASE_URL` benar\n2. Jalankan `npx prisma generate`\n3. Jalankan `npx prisma db push`\n\n### Memory Error\n1. Tingkatkan RAM (minimal 1GB)\n2. Restart bot secara berkala\n\n---\n\n## Support\n- Buat issue di repository untuk bantuan\n","path":null,"size_bytes":2651,"size_tokens":null},"source-1/README.md":{"content":"## Information\r\n\r\n<div align=\"center\">\r\n<a href=\"https://github.com/nazedev/hitori/watchers\"><img title=\"Watchers\" src=\"https://img.shields.io/github/watchers/nazedev/hitori?label=Watchers&color=green&style=flat-square\"></a>\r\n<a href=\"https://github.com/nazedev/hitori/network/members\"><img title=\"Forks\" src=\"https://img.shields.io/github/forks/nazedev/hitori?label=Forks&color=blue&style=flat-square\"></a>\r\n<a href=\"https://github.com/nazedev/hitori/stargazers\"><img title=\"Stars\" src=\"https://img.shields.io/github/stars/nazedev/hitori?label=Stars&color=yellow&style=flat-square\"></a>\r\n<a href=\"https://github.com/nazedev/hitori/issues\"><img title=\"Issues\" src=\"https://img.shields.io/github/issues/nazedev/hitori?label=Issues&color=success&style=flat-square\"></a>\r\n<a href=\"https://github.com/nazedev/hitori/issues?q=is%3Aissue+is%3Aclosed\"><img title=\"Issues\" src=\"https://img.shields.io/github/issues-closed/nazedev/hitori?label=Issues&color=red&style=flat-square\"></a>\r\n<a href=\"https://github.com/nazedev/hitori/pulls\"><img title=\"Pull Request\" src=\"https://img.shields.io/github/issues-pr/nazedev/hitori?label=PullRequest&color=success&style=flat-square\"></a>\r\n<a href=\"https://github.com/nazedev/hitori/pulls?q=is%3Apr+is%3Aclosed\"><img title=\"Pull Request\" src=\"https://img.shields.io/github/issues-pr-closed/nazedev/hitori?label=PullRequest&color=red&style=flat-square\"></a>\r\n</div>\r\n\r\nThis script is created by [Nazedev](https://github.com/nazedev) using Node.js and the [WhiskeySocket/Baileys](https://github.com/WhiskeySockets/Baileys) library. The script is currently in the development phase (BETA), so there may still be some errors that can be ignored. If errors persist even after debugging, please contact the owner for assistance. ~ By Naze\r\n\r\n## Contributor\r\n\r\n- [NazeDev](https://github.com/nazedev) (Pembuat)\r\n- [Zaynn](https://github.com/ZaynRcK) (Penyedia Layanan API)\r\n- [Dani](https://github.com/nazedev) (Penyumbang Code)\r\n\r\n#### Join Group\r\n[![Grup WhatsApp](https://img.shields.io/badge/WhatsApp%20Group-25D366?style=for-the-badge&logo=whatsapp&logoColor=white)](https://chat.whatsapp.com/Hx9vcBVhbc04KLVGPFtH2R) \r\n\r\n---\r\n#### Deploy to Heroku\r\n[![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy?template=https://github.com/nazedev/hitori)\r\n\r\n#### Heroku Buildpack\r\n| Build Pack | LINK |\r\n|--------|--------|\r\n| **NODEJS** | heroku/nodejs |\r\n| **FFMPEG** | [here](https://github.com/jonathanong/heroku-buildpack-ffmpeg-latest) |\r\n| **WEBP** | [here](https://github.com/clhuang/heroku-buildpack-webp-binaries.git) |\r\n| **IMAGEMAGICK** | [here](https://github.com/DuckyTeam/heroku-buildpack-imagemagick) |\r\n\r\n---\r\n## For Windows/VPS/RDP User\r\n* Download And Install Git [`Click Here`](https://git-scm.com/downloads)\r\n* Download And Install NodeJS [`Click Here`](https://nodejs.org/en/download)\r\n* Download And Install FFmpeg [`Click Here`](https://ffmpeg.org/download.html) (**Don't Forget Add FFmpeg to PATH enviroment variables**)\r\n* Download And Install ImageMagick [`Click Here`](https://imagemagick.org/script/download.php)\r\n\r\n```bash\r\ngit clone https://github.com/nazedev/hitori\r\ncd hitori\r\nnpm install\r\nnpm update\r\n```\r\n---\r\n## For Termux/Ubuntu/SSH User\r\n```bash\r\npkg update && pkg upgrade\r\npkg install git\r\npkg install nodejs\r\npkg install ffmpeg\r\npkg install imagemagick\r\ngit clone https://github.com/nazedev/hitori\r\ncd hitori\r\nnpm install\r\n```\r\n\r\n[ RECOMMENDED INSTALL ON TERMUX ]\r\n```bash\r\npkg install yarn\r\nyarn\r\n```\r\n\r\n---\r\n\r\n## Run\r\n```bash\r\nnode .\r\n```\r\n---\r\n\r\n### Connection Options\r\n- Support Qr Code\r\n- Support Pairing Code\r\n---\r\n\r\n### Features\r\n| Menu     | Bot | Group | Search | Download | Tools | Ai | Game | Fun | Owner |\r\n| -------- | --- | ----- | ------ | -------- | ----- | -- | ---- | --- | ----- |\r\n| Work     |  ‚úÖ  |   ‚úÖ   |    ‚úÖ    |     ‚úÖ     |   ‚úÖ   | ‚úÖ |   ‚úÖ   |  ‚úÖ  |    ‚úÖ    |\r\n\r\n\r\nLicense: [MIT](https://choosealicense.com/licenses/mit/)\r\n\r\n#### Support Me\r\n- [Saweria](https://saweria.co/naze)\r\n\r\n## Thanks to\r\n\r\n| [![Nazedev](https://github.com/nazedev.png?size=100)](https://github.com/nazedev) | [![Zaynn](https://github.com/ZaynRcK.png?size=100)](https://github.com/ZaynRcK) | [![Dani](https://github.com/nazedev.png?size=100)](https://github.com/nazedev) | [![WhiskeySockets](https://github.com/WhiskeySockets.png?size=100)](https://github.com/WhiskeySockets) |\r\n| --- | --- | --- | --- |\r\n| [NazeDev](https://github.com/nazedev) | [Zaynn](https://github.com/ZaynRcK) | [Dani](https://github.com/dani) | [WhiskeySockets](https://github.com/WhiskeySockets) |","path":null,"size_bytes":4580,"size_tokens":null},"ciel/src/handlers/messageHandler.js":{"content":"const { jidNormalizedUser, getContentType } = require('@whiskeysockets/baileys');\nconst settings = require('../../config/settings');\nconst { logger } = require('../utils/logger');\nconst { antiSpam } = require('../utils/antiSpam');\nconst { Serialize } = require('./serialize');\nconst { \n    getOrCreateUser, \n    getOrCreateGroup, \n    getOrCreateBotSettings,\n    addHit,\n    isPremium\n} = require('../services/database');\n\nconst handleMessage = async (conn, message, store) => {\n    try {\n        const msg = message.messages[0];\n        if (!msg?.message) return;\n        \n        const remoteJid = msg.key.remoteJid;\n        \n        store.messages[remoteJid] = store.messages[remoteJid] || { array: [], keyId: new Set() };\n        if (!store.messages[remoteJid].keyId.has(msg.key.id)) {\n            store.messages[remoteJid].array.push(msg);\n            store.messages[remoteJid].keyId.add(msg.key.id);\n            \n            if (store.messages[remoteJid].array.length > 100) {\n                const removed = store.messages[remoteJid].array.shift();\n                store.messages[remoteJid].keyId.delete(removed.key.id);\n            }\n        }\n        \n        const m = await Serialize(conn, msg, store);\n        if (!m || m.isBot) return;\n        \n        const botJid = jidNormalizedUser(conn.user.id);\n        const botSettings = await getOrCreateBotSettings(botJid);\n        \n        const ownerNumbers = botSettings.owner || settings.owner;\n        const isOwner = ownerNumbers.map(n => n.replace(/[^0-9]/g, '')).includes(m.sender.split('@')[0]);\n        \n        const user = await getOrCreateUser(m.sender, m.pushName);\n        if (user?.banned && !isOwner) return;\n        \n        if (m.isGroup) {\n            const group = await getOrCreateGroup(m.chat, m.metadata?.subject);\n            if (group?.mute && !isOwner) return;\n            \n            await handleGroupFeatures(conn, m, group, isOwner, botSettings);\n        }\n        \n        if (botSettings.autoRead && (botSettings.public || isOwner)) {\n            await conn.readMessages([m.key]).catch(() => {});\n        }\n        \n        const prefix = getPrefix(m.text, isOwner, botSettings);\n        const isCmd = m.text.startsWith(prefix) && prefix !== '';\n        const command = isCmd ? m.text.slice(prefix.length).trim().split(/\\s+/)[0].toLowerCase() : '';\n        const args = m.text.trim().split(/\\s+/).slice(1);\n        const text = args.join(' ');\n        \n        if (isCmd && command) {\n            if (!isOwner && botSettings.antiSpam && antiSpam.isFiltered(m.sender)) {\n                return m.reply('Tunggu 5 detik sebelum menggunakan command lagi!');\n            }\n            \n            if (!isOwner) antiSpam.addFilter(m.sender);\n            \n            logger.command(prefix + command, m.pushName, m.isGroup);\n            \n            await processCommand(conn, m, {\n                prefix,\n                command,\n                args,\n                text,\n                isOwner,\n                user,\n                botSettings,\n                store\n            });\n            \n            await addHit(command);\n        } else if (botSettings.autoTyping && botSettings.public) {\n            await handleAutoFeatures(conn, m, text, botSettings);\n        }\n        \n        if (!isCmd && m.text) {\n            await handleGameAnswers(conn, m, { user, botSettings, store });\n        }\n        \n    } catch (e) {\n        logger.error(`handleMessage error: ${e.message}`);\n    }\n};\n\nconst getPrefix = (text, isOwner, botSettings) => {\n    if (!text) return '';\n    \n    const prefixes = settings.prefixes;\n    \n    if (isOwner) {\n        const symbolMatch = text.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@()#,'\"*+√∑/\\%^&.¬©^]/);\n        if (symbolMatch) return symbolMatch[0];\n        \n        const emojiMatch = text.match(/^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/);\n        if (emojiMatch) return emojiMatch[0];\n    }\n    \n    if (botSettings.multiPrefix) {\n        const symbolMatch = text.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=|~!?@()#,'\"*+√∑/\\%^&.¬©^]/);\n        if (symbolMatch) return symbolMatch[0];\n    }\n    \n    for (const p of prefixes) {\n        if (text.startsWith(p)) return p;\n    }\n    \n    return '';\n};\n\nconst handleGroupFeatures = async (conn, m, group, isOwner, botSettings) => {\n    if (!group || isOwner || !m.isBotAdmin) return;\n    \n    const text = m.text.toLowerCase();\n    \n    if (group.antilink && text.includes('chat.whatsapp.com/')) {\n        await conn.sendMessage(m.chat, { delete: m.key });\n        await m.reply(`@${m.sender.split('@')[0]} mengirim link grup!\\nLink telah dihapus.`, { mentions: [m.sender] });\n        return true;\n    }\n    \n    if (group.antitoxic && settings.badWords.some(word => text.includes(word))) {\n        await conn.sendMessage(m.chat, { delete: m.key });\n        await m.reply(`@${m.sender.split('@')[0]} menggunakan kata kasar!\\nPesan telah dihapus.`, { mentions: [m.sender] });\n        return true;\n    }\n    \n    if (group.antivirtex && (m.text.length > 5000 || m.msg?.nativeFlowMessage?.messageParamsJson?.length > 3500)) {\n        await conn.sendMessage(m.chat, { delete: m.key });\n        await conn.groupParticipantsUpdate(m.chat, [m.sender], 'remove');\n        await m.reply(`@${m.sender.split('@')[0]} mengirim virtex!\\nTelah dikick dari grup.`, { mentions: [m.sender] });\n        return true;\n    }\n    \n    return false;\n};\n\nconst handleGameAnswers = async (conn, m, ctx) => {\n    try {\n        const text = m.text?.trim();\n        if (!text) return;\n        \n        const isNumeric = /^-?\\d+$/.test(text);\n        const isSingleDigit = /^[1-9]$/.test(text);\n        \n        const gameCommands = require('./commands/game');\n        \n        if (isSingleDigit && gameCommands.tttmove) {\n            await gameCommands.tttmove(conn, m, { ...ctx, args: [text] });\n        }\n        \n        if (isNumeric && gameCommands.mathanswer) {\n            await gameCommands.mathanswer(conn, m, ctx);\n        }\n    } catch (e) {\n    }\n};\n\nconst handleAutoFeatures = async (conn, m, text, botSettings) => {\n    const lowerText = text.toLowerCase();\n    \n    if (/^a(s|ss)alamu('|)alaikum(| )(wr|)( |)(wb|)$/i.test(lowerText)) {\n        const responses = [\"Wa'alaikumsalam\", \"Wa'alaikumsalam wr wb\", \"Wa'alaikumsalam Warohmatullahi Wabarokatuh\"];\n        await m.reply(responses[Math.floor(Math.random() * responses.length)]);\n    }\n};\n\nconst processCommand = async (conn, m, ctx) => {\n    const { prefix, command, args, text, isOwner, user, botSettings, store } = ctx;\n    \n    try {\n        const ownerCommands = require('./commands/owner');\n        const groupCommands = require('./commands/group');\n        const toolCommands = require('./commands/tools');\n        const downloadCommands = require('./commands/download');\n        const infoCommands = require('./commands/info');\n        const gameCommands = require('./commands/game');\n        const funCommands = require('./commands/fun');\n        \n        const allCommands = {\n            ...ownerCommands,\n            ...groupCommands,\n            ...toolCommands,\n            ...downloadCommands,\n            ...infoCommands,\n            ...gameCommands,\n            ...funCommands\n        };\n        \n        if (allCommands[command]) {\n            await allCommands[command](conn, m, { prefix, args, text, isOwner, user, botSettings, store });\n        }\n        \n    } catch (e) {\n        if (e.code !== 'MODULE_NOT_FOUND') {\n            logger.error(`Command error (${command}): ${e.message}`);\n        }\n    }\n};\n\nmodule.exports = { handleMessage };\n","path":null,"size_bytes":7586,"size_tokens":null},"source-1/start.js":{"content":"const path = require('path');\r\nconst chalk = require('chalk');\r\nconst { spawn } = require('child_process');\r\n\r\nfunction start() {\r\n\tlet args = [path.join(__dirname, 'index.js'), ...process.argv.slice(2)]\r\n\tlet p = spawn(process.argv[0], args, {\r\n\t\tstdio: ['inherit', 'inherit', 'inherit', 'ipc']\r\n\t}).on('message', data => {\r\n\t\tif (data === 'reset') {\r\n\t\t\tconsole.log(chalk.yellow.bold('[BOT] Restarting...'))\r\n\t\t\tp.kill()\r\n\t\t\tstart()\r\n\t\t\tdelete p\r\n\t\t} else if (data === 'uptime') {\r\n\t\t\tp.send(process.uptime())\r\n\t\t}\r\n\t}).on('exit', code => {\r\n\t\tif (code !== 0) {\r\n\t\t\tconsole.error(chalk.red.bold(`[BOT] Exited with code: ${code}`))\r\n\t\t\tstart()\r\n\t\t} else {\r\n\t\t\tconsole.log(chalk.green.bold('[BOT] Process exited cleanly. Goodbye!'))\r\n\t\t\tprocess.exit(0)\r\n\t\t}\r\n\t})\r\n}\r\nstart()","path":null,"size_bytes":774,"size_tokens":null},"source-1/src/server.js":{"content":"const express = require('express');\r\nconst { createServer } = require('http');\r\n\r\nconst app = express();\r\nconst server = createServer(app);\r\nconst PORT = process.env.PORT || process.env.SERVER_PORT || 3000;\r\nconst packageInfo = require('../package.json');\r\n\r\napp.all('/', (req, res) => {\r\n\tif (process.send) {\r\n\t\tprocess.send('uptime');\r\n\t\tprocess.once('message', (uptime) => {\r\n\t\t\tres.json({\r\n\t\t\t\tbot_name: packageInfo.name,\r\n\t\t\t\tversion: packageInfo.version,\r\n\t\t\t\tauthor: packageInfo.author,\r\n\t\t\t\tdescription: packageInfo.description,\r\n\t\t\t\tuptime: `${Math.floor(uptime)} seconds`\r\n\t\t\t});\r\n\t\t});\r\n\t} else res.json({ error: 'Process not running with IPC' });\r\n});\r\n\r\napp.all('/process', (req, res) => {\r\n\tconst { send } = req.query;\r\n\tif (!send) return res.status(400).json({ error: 'Missing send query' });\r\n\tif (process.send) {\r\n\t\tprocess.send(send)\r\n\t\tres.json({ status: 'Send', data: send });\r\n\t} else res.json({ error: 'Process not running with IPC' });\r\n});\r\n\r\napp.all('/chat', (req, res) => {\r\n\tconst { message, to } = req.query;\r\n\tif (!message || !to) return res.status(400).json({ error: 'Missing message or to query' });\r\n\tres.json({ status: 200, mess: 'does not start' })\r\n});\r\n\r\nmodule.exports = { app, server, PORT };","path":null,"size_bytes":1230,"size_tokens":null},"ciel/lib/tikSnap.js":{"content":"const axios = require('axios');\nconst cheerio = require('cheerio');\n\nclass SavetikAPI {\n    constructor() {\n        this.csrfToken = \"\";\n        this.userAgent = \"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Mobile Safari/537.36\";\n        this.cookies = \"\";\n    }\n    \n    async fetchCsrfToken(url) {\n        try {\n            const response = await axios.get(url, {\n                headers: { \n                    \"user-agent\": this.userAgent,\n                    \"Cookie\": this.cookies\n                }\n            });\n            \n            const setCookies = response.headers['set-cookie'];\n            if (setCookies) {\n                this.cookies = setCookies.map(c => c.split(';')[0]).join('; ');\n            }\n            \n            const csrfMatch = response.data.match(/<meta name=\"csrf-token\" content=\"([^\"]+)\">/);\n            if (csrfMatch && csrfMatch[1]) {\n                this.csrfToken = csrfMatch[1];\n            } else {\n                const csrfCookieMatch = /XSRF-TOKEN=([^;]+)/.exec(this.cookies);\n                if (csrfCookieMatch && csrfCookieMatch[1]) {\n                    this.csrfToken = decodeURIComponent(csrfCookieMatch[1]);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching CSRF token:\", error.message);\n            throw error;\n        }\n    }\n    \n    async ajaxSearch(url, videoUrl) {\n        try {\n            if (!this.csrfToken) {\n                await this.fetchCsrfToken(\"https://savetik.co/vi/douyin-downloader\");\n            }\n            \n            const response = await axios.post(url, `q=${encodeURIComponent(videoUrl)}&lang=vi&cftoken=${this.csrfToken}`, {\n                headers: {\n                    \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n                    \"user-agent\": this.userAgent,\n                    \"x-requested-with\": \"XMLHttpRequest\",\n                    \"Cookie\": this.cookies\n                }\n            });\n            \n            const $ = cheerio.load(response.data.data);\n            const videoTitle = $(\"div.video-data h3\").text().trim();\n            const thumbnailUrl = $(\"div.thumbnail img\").attr(\"src\");\n            const downloadLinks = $(\"div.dl-action a\").map((index, element) => {\n                return {\n                    text: $(element).text().trim(),\n                    link: $(element).attr(\"href\")\n                };\n            }).get();\n            \n            return {\n                status: \"ok\",\n                videoTitle,\n                thumbnailUrl,\n                downloadLinks\n            };\n        } catch (error) {\n            console.error(\"Error in ajaxSearch:\", error.message);\n            throw error;\n        }\n    }\n    \n    async download({ url: videoUrl }) {\n        try {\n            const searchResult = await this.ajaxSearch(\"https://savetik.co/api/ajaxSearch\", videoUrl);\n            return searchResult;\n        } catch (error) {\n            console.error(\"Error during search and download:\", error.message);\n            throw error;\n        }\n    }\n}\n\nmodule.exports = SavetikAPI;\n","path":null,"size_bytes":3139,"size_tokens":null},"ciel/src/handlers/groupHandler.js":{"content":"const { jidNormalizedUser } = require('@whiskeysockets/baileys');\nconst { logger } = require('../utils/logger');\nconst { getOrCreateGroup, getOrCreateBotSettings } = require('../services/database');\n\nconst handleGroupParticipantsUpdate = async (conn, update, store) => {\n    try {\n        const { id, participants, author, action } = update;\n        \n        const group = await getOrCreateGroup(id);\n        if (!group) return;\n        \n        const metadata = store.groupMetadata[id] || await conn.groupMetadata(id).catch(() => ({}));\n        store.groupMetadata[id] = metadata;\n        \n        for (const participant of participants) {\n            const jid = jidNormalizedUser(participant);\n            let profile;\n            \n            try {\n                profile = await conn.profilePictureUrl(jid, 'image');\n            } catch {\n                profile = 'https://i.ibb.co/Tq7d7TZ/avatar-contact.png';\n            }\n            \n            let messageText = '';\n            \n            switch (action) {\n                case 'add':\n                    if (group.welcome) {\n                        messageText = group.welcomeText || \n                            `Selamat datang di *${metadata.subject}*!\\n\\n` +\n                            `Halo @${jid.split('@')[0]}, semoga betah di grup ini.`;\n                    }\n                    \n                    if (metadata.participants) {\n                        const exists = metadata.participants.find(p => \n                            jidNormalizedUser(p.id) === jid || jidNormalizedUser(p.lid) === jid\n                        );\n                        if (!exists) {\n                            metadata.participants.push({\n                                id: jid,\n                                admin: null\n                            });\n                        }\n                    }\n                    break;\n                    \n                case 'remove':\n                    if (group.leave) {\n                        messageText = group.leaveText || \n                            `@${jid.split('@')[0]} telah keluar dari *${metadata.subject}*.\\n\\nSampai jumpa!`;\n                    }\n                    \n                    const botJid = jidNormalizedUser(conn.user.id);\n                    if (jid === botJid) {\n                        delete store.messages[id];\n                        delete store.presences[id];\n                        delete store.groupMetadata[id];\n                    }\n                    \n                    if (metadata.participants) {\n                        metadata.participants = metadata.participants.filter(p => \n                            jidNormalizedUser(p.id) !== jid && jidNormalizedUser(p.lid) !== jid\n                        );\n                    }\n                    break;\n                    \n                case 'promote':\n                    if (group.promote) {\n                        const authorName = author ? `@${author.split('@')[0]}` : 'Admin';\n                        messageText = group.promoteText || \n                            `@${jid.split('@')[0]} telah diangkat menjadi Admin oleh ${authorName}`;\n                    }\n                    \n                    if (metadata.participants) {\n                        const p = metadata.participants.find(p => \n                            jidNormalizedUser(p.id) === jid || jidNormalizedUser(p.lid) === jid\n                        );\n                        if (p) p.admin = 'admin';\n                    }\n                    break;\n                    \n                case 'demote':\n                    if (group.demote) {\n                        const authorName = author ? `@${author.split('@')[0]}` : 'Admin';\n                        messageText = group.demoteText || \n                            `@${jid.split('@')[0]} telah diturunkan dari Admin oleh ${authorName}`;\n                    }\n                    \n                    if (metadata.participants) {\n                        const p = metadata.participants.find(p => \n                            jidNormalizedUser(p.id) === jid || jidNormalizedUser(p.lid) === jid\n                        );\n                        if (p) p.admin = null;\n                    }\n                    break;\n            }\n            \n            if (messageText && conn.public) {\n                const mentions = [jid];\n                if (author) mentions.push(author);\n                \n                await conn.sendMessage(id, {\n                    text: messageText.replace(/@/g, `@${jid.split('@')[0]}`),\n                    contextInfo: {\n                        mentionedJid: mentions,\n                        externalAdReply: {\n                            title: action === 'add' ? 'Welcome' : \n                                   action === 'remove' ? 'Goodbye' : \n                                   action.charAt(0).toUpperCase() + action.slice(1),\n                            body: metadata.subject,\n                            mediaType: 1,\n                            thumbnailUrl: profile,\n                            renderLargerThumbnail: true\n                        }\n                    }\n                });\n                \n                logger.info(`Group ${action}: ${jid} in ${id}`);\n            }\n        }\n        \n    } catch (e) {\n        logger.error(`handleGroupParticipantsUpdate error: ${e.message}`);\n    }\n};\n\nconst handleGroupUpdate = (updates, store) => {\n    for (const update of updates) {\n        if (store.groupMetadata[update.id]) {\n            Object.assign(store.groupMetadata[update.id], update);\n        } else {\n            store.groupMetadata[update.id] = update;\n        }\n    }\n};\n\nmodule.exports = { handleGroupParticipantsUpdate, handleGroupUpdate };\n","path":null,"size_bytes":5749,"size_tokens":null},"ciel/lib/math.js":{"content":"const modes = {\n    noob: [-3, 3, -3, 3, '+-', 15000, 10],\n    easy: [-10, 10, -10, 10, '*/+-', 20000, 40],\n    medium: [-40, 40, -20, 20, '*/+-', 40000, 150],\n    hard: [-100, 100, -70, 70, '*/+-', 60000, 350],\n    extreme: [-999999, 999999, -999999, 999999, '*/', 99999, 9999],\n    impossible: [-99999999999, 99999999999, -99999999999, 999999999999, '*/', 30000, 35000],\n    impossible2: [-999999999999999, 999999999999999, -999, 999, '/', 30000, 50000]\n};\n\nconst operators = {\n    '+': '+',\n    '-': '-',\n    '*': '√ó',\n    '/': '√∑'\n};\n\nfunction randomInt(from, to) {\n    if (from > to) [from, to] = [to, from];\n    from = Math.floor(from);\n    to = Math.floor(to);\n    return Math.floor((to - from) * Math.random() + from);\n}\n\nfunction pickRandom(list) {\n    return list[Math.floor(Math.random() * list.length)];\n}\n\nfunction genMath(mode) {\n    return new Promise((resolve, reject) => {\n        try {\n            const [a1, a2, b1, b2, ops, time, bonus] = modes[mode] || modes.easy;\n            let a = randomInt(a1, a2);\n            let b = randomInt(b1, b2);\n            const op = pickRandom([...ops]);\n            let result = (new Function(`return ${a} ${op.replace('/', '*')} ${b < 0 ? `(${b})` : b}`))();\n            if (op === '/') [a, result] = [result, a];\n            \n            resolve({\n                soal: `${a} ${operators[op]} ${b}`,\n                mode: mode,\n                waktu: time,\n                hadiah: bonus,\n                jawaban: result\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nmodule.exports = { modes, operators, randomInt, pickRandom, genMath };\n","path":null,"size_bytes":1632,"size_tokens":null},"source-1/src/jadibot.js":{"content":"require('../settings');\r\nconst fs = require('fs');\r\nconst pino = require('pino');\r\nconst path = require('path');\r\nconst { Boom } = require('@hapi/boom');\r\nconst NodeCache = require('node-cache');\r\nconst { exec, spawn, execSync } = require('child_process');\r\nconst { parsePhoneNumber } = require('awesome-phonenumber');\r\nconst { default: WAConnection, useMultiFileAuthState, Browsers, DisconnectReason, makeInMemoryStore, makeCacheableSignalKeyStore, fetchLatestBaileysVersion, proto, getAggregateVotesInPollMessage } = require('baileys');\r\n\r\nconst { GroupCacheUpdate, GroupParticipantsUpdate, MessagesUpsert, Solving } = require('./message');\r\n\r\nglobal.client = {};\r\n\r\n\r\nconst msgRetryCounterCache = new NodeCache();\r\nconst groupCache = new NodeCache({ stdTTL: 5 * 60, useClones: false });\r\n\r\nasync function JadiBot(conn, from, m, store) {\r\n\tasync function startJadiBot() {\r\n\t\ttry {\r\n\t\t\tconst { state, saveCreds } = await useMultiFileAuthState(`./database/jadibot/${from}`);\r\n\t\t\tconst { version, isLatest } = await fetchLatestBaileysVersion();\r\n\t\t\tconst level = pino({ level: 'silent' })\r\n\t\t\t\r\n\t\t\tconst getMessage = async (key) => {\r\n\t\t\t\tif (store) {\r\n\t\t\t\t\tconst msg = await store.loadMessage(key.remoteJid, key.id);\r\n\t\t\t\t\treturn msg?.message || ''\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tconversation: 'Halo Saya Adalah Bot'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tclient[from] = WAConnection({\r\n\t\t\t\tisLatest,\r\n\t\t\t\tlogger: level,\r\n\t\t\t\tgetMessage,\r\n\t\t\t\tsyncFullHistory: false,\r\n\t\t\t\tmaxMsgRetryCount: 15,\r\n\t\t\t\tmsgRetryCounterCache,\r\n\t\t\t\tretryRequestDelayMs: 10,\r\n\t\t\t\tdefaultQueryTimeoutMs: 0,\r\n\t\t\t\tcachedGroupMetadata: async (jid) => groupCache.get(jid),\r\n\t\t\t\tbrowser: Browsers.ubuntu('Chrome'),\r\n\t\t\t\ttransactionOpts: {\r\n\t\t\t\t\tmaxCommitRetries: 10,\r\n\t\t\t\t\tdelayBetweenTriesMs: 10,\r\n\t\t\t\t},\r\n\t\t\t\tappStateMacVerification: {\r\n\t\t\t\t\tpatch: true,\r\n\t\t\t\t\tsnapshot: true,\r\n\t\t\t\t},\r\n\t\t\t\tauth: {\r\n\t\t\t\t\tcreds: state.creds,\r\n\t\t\t\t\tkeys: makeCacheableSignalKeyStore(state.keys, level),\r\n\t\t\t\t},\r\n\t\t\t})\r\n\t\t\t\r\n\t\t\tawait Solving(client[from], store)\r\n\t\t\t\r\n\t\t\tclient[from].pairingStarted = false;\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('creds.update', saveCreds)\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('connection.update', async (update) => {\r\n\t\t\t\tconst { connection, lastDisconnect, receivedPendingNotifications } = update\r\n\t\t\t\tif (connection === 'connecting' && !client[from].authState.creds.registered && !client[from].pairingStarted) {\r\n\t\t\t\t\tsetTimeout(async () => {\r\n\t\t\t\t\t\tclient[from].pairingStarted = true;\r\n\t\t\t\t\t\texec('rm -rf ./database/jadibot/' + from + '/*');\r\n\t\t\t\t\t\tlet code = await client[from].requestPairingCode(from.replace(/[^0-9]/g, ''));\r\n\t\t\t\t\t\tm.reply(`Your Pairing Code : ${code?.match(/.{1,4}/g)?.join('-') || code}`);\r\n\t\t\t\t\t}, 3000);\r\n\t\t\t\t}\r\n\t\t\t\tif (connection === 'close') {\r\n\t\t\t\t\tconst reason = new Boom(lastDisconnect?.error)?.output.statusCode\r\n\t\t\t\t\tconsole.log(reason)\r\n\t\t\t\t\tif ([DisconnectReason.connectionLost, DisconnectReason.connectionClosed, DisconnectReason.restartRequired, DisconnectReason.timedOut, DisconnectReason.badSession, DisconnectReason.connectionReplaced].includes(reason)) {\r\n\t\t\t\t\t\tJadiBot(conn, from, m, store)\r\n\t\t\t\t\t} else if (reason === DisconnectReason.loggedOut) {\r\n\t\t\t\t\t\tm.reply('Scan again and Run...');\r\n\t\t\t\t\t\tStopJadiBot(conn, from, m)\r\n\t\t\t\t\t} else if (reason === DisconnectReason.Multidevicemismatch) {\r\n\t\t\t\t\t\tm.reply('Scan again...');\r\n\t\t\t\t\t\tStopJadiBot(conn, from, m)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tm.reply('Anda Sudah Tidak Lagi Menjadi Bot!')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (connection == 'open') {\r\n\t\t\t\t\tlet botNumber = await client[from].decodeJid(client[from].user.id);\r\n\t\t\t\t\tif (db.set[botNumber] && !db.set[botNumber]?.join) {\r\n\t\t\t\t\t\tdb.set[botNumber].original = false\r\n\t\t\t\t\t\tif (my.ch.length > 0 && my.ch.includes('@newsletter')) {\r\n\t\t\t\t\t\t\tif (my.ch) await client[from].newsletterMsg(my.ch, { type: 'follow' }).catch(e => {})\r\n\t\t\t\t\t\t\tdb.set[botNumber].join = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (receivedPendingNotifications == 'true') {\r\n\t\t\t\t\tclient[from].ev.flush()\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('contacts.update', (update) => {\r\n\t\t\t\tfor (let contact of update) {\r\n\t\t\t\t\tlet id = client[from].decodeJid(contact.id)\r\n\t\t\t\t\tif (store && store.contacts) store.contacts[id] = { id, name: contact.notify }\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('call', async (call) => {\r\n\t\t\t\tlet botNumber = await client[from].decodeJid(client[from].user.id);\r\n\t\t\t\tif (db.set[botNumber].anticall) {\r\n\t\t\t\t\tfor (let id of call) {\r\n\t\t\t\t\t\tif (id.status === 'offer') {\r\n\t\t\t\t\t\t\tlet msg = await client[from].sendMessage(id.from, { text: `Saat Ini, Kami Tidak Dapat Menerima Panggilan ${id.isVideo ? 'Video' : 'Suara'}.\\nJika @${id.from.split('@')[0]} Memerlukan Bantuan, Silakan Hubungi Owner :)`, mentions: [id.from]});\r\n\t\t\t\t\t\t\tawait client[from].sendContact(id.from, global.owner, msg);\r\n\t\t\t\t\t\t\tawait client[from].rejectCall(id.id, id.from)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('groups.update', (update) => {\r\n\t\t\t\tfor (let n of update) {\r\n\t\t\t\t\tif (store.groupMetadata[n.id]) {\r\n\t\t\t\t\t\tgroupCache.set(n.id, n);\r\n\t\t\t\t\t\tObject.assign(store.groupMetadata[n.id], n);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('group-participants.update', async (update) => {\r\n\t\t\t\tawait GroupParticipantsUpdate(client[from], update, store, groupCache);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tclient[from].ev.on('messages.upsert', async (message) => {\r\n\t\t\t\tawait MessagesUpsert(client[from], message, store, groupCache);\r\n\t\t\t});\r\n\t\t\r\n\t\t\treturn client[from]\r\n\t\t} catch (e) {\r\n\t\t\tconsole.log('Error di jadibot : ', e)\r\n\t\t}\r\n\t}\r\n\treturn startJadiBot()\r\n}\r\n\r\nasync function StopJadiBot(conn, from, m) {\r\n\tif (!Object.keys(client).includes(from)) {\r\n\t\treturn conn.sendMessage(m.chat, { text: 'Anda Tidak Sedang jadibot!' }, { quoted: m })\r\n\t}\r\n\ttry {\r\n\t\tclient[from].end('Stop')\r\n\t\tclient[from].ev.removeAllListeners()\r\n\t} catch (e) {\r\n\t\tconsole.log('Errornya di stopjadibot : ', e)\r\n\t}\r\n\tdelete client[from]\r\n\texec(`rm -rf ./database/jadibot/${from}`)\r\n\treturn m.reply('Sukses Keluar Dari Sessi Jadi bot')\r\n}\r\n\r\nasync function ListJadiBot(conn, m) {\r\n\tlet teks = 'List Jadi Bot :\\n\\n'\r\n\tfor (let jadibot of Object.values(client)) {\r\n\t\tteks += (jadibot.user?.id ? `- @${conn.decodeJid(jadibot.user.id).split('@')[0]}\\n` : '')\r\n\t}\r\n\treturn m.reply(teks)\r\n}\r\n\r\nmodule.exports = { JadiBot, StopJadiBot, ListJadiBot }","path":null,"size_bytes":6257,"size_tokens":null},"source-2/lib/handlers/stickerHandler.js":{"content":"const { downloadContentFromMessage } = require('@naruyaizumi/baileys');\nconst { writeExif } = require('../utils/mediaConverter.js');\nconst { globalPackname, globalAuthor } = require('../../config.js');\nconst { logger } = require('../utils/logger.js');\n\nasync function handleStickerCommand(conn, m, args = '') {\n    await conn.readMessages([m.key]);\n    try {\n        if (!m.message.extendedTextMessage?.contextInfo?.quotedMessage) {\n            await conn.sendMessage(m.key.remoteJid, { \n                text: 'Reply to an image/video with [prefix]sticker [pack|author]'\n            });\n            return;\n        }\n\n        const quotedMsg = m.message.extendedTextMessage.contextInfo.quotedMessage;\n        const quotedType = Object.keys(quotedMsg)[0];\n        \n        if (!['imageMessage', 'videoMessage'].includes(quotedType)) {\n            await conn.sendMessage(m.key.remoteJid, { \n                text: 'Only images/videos (max 5s) can be stickers'\n            });\n            return;\n        }\n\n        const stream = await downloadContentFromMessage(quotedMsg[quotedType], quotedType.replace('Message', ''));\n        let buffer = Buffer.from([]);\n        for await (const chunk of stream) {\n            buffer = Buffer.concat([buffer, chunk]);\n        }\n\n        const parts = args.split('|').map(s => s.trim());\n        const packName = parts[0] || globalPackname;\n        const authorName = parts[1] || globalAuthor;\n\n        await conn.sendAsSticker(\n            m.key.remoteJid, \n            buffer, \n            m, \n            {\n                packname: packName,\n                author: authorName,\n                categories: ['ü§©', 'üéâ']\n            }\n        );\n\n        logger.success(`‚úÖ Sticker created`);\n        \n    } catch (err) {\n        logger.error(`‚ùå Sticker failed: ${err.message}`);\n        await conn.sendMessage(m.key.remoteJid, { \n            text: 'Failed to create sticker. Try again with a different media.'\n        });\n    }\n}\n\nmodule.exports = {\n    handleStickerCommand\n};\n","path":null,"size_bytes":2023,"size_tokens":null},"ciel/src/handlers/serialize.js":{"content":"const {\n    jidNormalizedUser,\n    jidDecode,\n    proto,\n    getContentType,\n    downloadContentFromMessage,\n    generateWAMessageFromContent,\n    getBinaryNodeChild,\n    getBinaryNodeChildren,\n    generateWAMessageContent,\n    prepareWAMessageMedia\n} = require('@whiskeysockets/baileys');\nconst FileType = require('file-type');\nconst { getGroupAdmins } = require('../utils/functions');\n\nconst downloadMedia = async (message) => {\n    const mtype = Object.keys(message.message || {})[0];\n    const msg = message.message[mtype];\n    \n    if (!msg) return null;\n    \n    const stream = await downloadContentFromMessage(msg, mtype.replace('Message', ''));\n    const chunks = [];\n    \n    for await (const chunk of stream) {\n        chunks.push(chunk);\n    }\n    \n    return Buffer.concat(chunks);\n};\n\nconst Serialize = async (conn, msg, store) => {\n    if (!msg.message) return msg;\n    \n    const m = {};\n    \n    m.message = msg.message;\n    m.key = msg.key;\n    m.id = msg.key.id;\n    m.chat = msg.key.remoteJid;\n    m.sender = msg.key.fromMe \n        ? jidNormalizedUser(conn.user.id) \n        : (msg.key.participant || msg.key.remoteJid);\n    m.sender = jidNormalizedUser(m.sender);\n    m.fromMe = msg.key.fromMe;\n    m.pushName = msg.pushName || 'Unknown';\n    m.isGroup = m.chat.endsWith('@g.us');\n    m.isBot = msg.key.id.startsWith('BAE5') || msg.key.id.startsWith('3EB0');\n    \n    const type = getContentType(msg.message);\n    m.type = type;\n    \n    if (type === 'ephemeralMessage') {\n        m.message = msg.message.ephemeralMessage.message;\n        m.type = getContentType(m.message);\n    }\n    \n    if (type === 'viewOnceMessageV2') {\n        m.message = msg.message.viewOnceMessageV2.message;\n        m.type = getContentType(m.message);\n    }\n    \n    m.msg = m.message[m.type];\n    \n    if (m.type === 'conversation') {\n        m.text = m.message.conversation;\n    } else if (m.type === 'extendedTextMessage') {\n        m.text = m.message.extendedTextMessage.text;\n    } else if (m.type === 'imageMessage') {\n        m.text = m.message.imageMessage.caption || '';\n    } else if (m.type === 'videoMessage') {\n        m.text = m.message.videoMessage.caption || '';\n    } else if (m.type === 'documentMessage') {\n        m.text = m.message.documentMessage.caption || '';\n    } else {\n        m.text = '';\n    }\n    \n    m.mentionedJid = m.msg?.contextInfo?.mentionedJid || [];\n    m.expiration = m.msg?.contextInfo?.expiration || 0;\n    \n    const mimetype = m.msg?.mimetype || '';\n    m.isMedia = /image|video|audio|sticker|document/.test(m.type);\n    m.mime = mimetype;\n    \n    if (m.isGroup) {\n        m.metadata = store.groupMetadata[m.chat] || await conn.groupMetadata(m.chat).catch(() => ({}));\n        m.participants = m.metadata.participants || [];\n        m.admins = getGroupAdmins(m.participants);\n        m.isAdmin = m.admins.includes(m.sender);\n        m.isBotAdmin = m.admins.includes(jidNormalizedUser(conn.user.id));\n    }\n    \n    m.download = async () => {\n        return await downloadMedia(msg);\n    };\n    \n    const quotedInfo = m.msg?.contextInfo;\n    if (quotedInfo?.quotedMessage) {\n        const quotedType = getContentType(quotedInfo.quotedMessage);\n        const quotedMsg = quotedInfo.quotedMessage[quotedType];\n        \n        m.quoted = {\n            message: quotedInfo.quotedMessage,\n            key: {\n                remoteJid: m.chat,\n                fromMe: quotedInfo.participant === jidNormalizedUser(conn.user.id),\n                id: quotedInfo.stanzaId,\n                participant: quotedInfo.participant\n            },\n            sender: jidNormalizedUser(quotedInfo.participant),\n            type: quotedType,\n            text: quotedMsg?.text || quotedMsg?.caption || quotedMsg?.conversation || '',\n            isMedia: /image|video|audio|sticker|document/.test(quotedType),\n            mime: quotedMsg?.mimetype || '',\n            msg: quotedMsg\n        };\n        \n        m.quoted.download = async () => {\n            const stream = await downloadContentFromMessage(quotedMsg, quotedType.replace('Message', ''));\n            const chunks = [];\n            for await (const chunk of stream) {\n                chunks.push(chunk);\n            }\n            return Buffer.concat(chunks);\n        };\n    } else {\n        m.quoted = null;\n    }\n    \n    m.reply = async (text, options = {}) => {\n        if (typeof text === 'string') {\n            return conn.sendMessage(m.chat, { text, ...options }, { quoted: msg });\n        }\n        return conn.sendMessage(m.chat, text, { quoted: msg, ...options });\n    };\n    \n    m.react = async (emoji) => {\n        return conn.sendMessage(m.chat, {\n            react: { text: emoji, key: m.key }\n        });\n    };\n    \n    return m;\n};\n\nconst setupExtensions = (conn, store) => {\n    conn.decodeJid = (jid) => {\n        if (!jid) return jid;\n        if (/:\\d+@/gi.test(jid)) {\n            const decode = jidDecode(jid) || {};\n            return decode.user && decode.server ? decode.user + '@' + decode.server : jid;\n        }\n        return jid;\n    };\n    \n    conn.getName = async (jid) => {\n        const id = conn.decodeJid(jid);\n        if (id.endsWith('@g.us')) {\n            const group = store.groupMetadata[id] || await conn.groupMetadata(id).catch(() => ({}));\n            return group.subject || id;\n        }\n        const contact = store.contacts[id];\n        return contact?.name || contact?.notify || id.split('@')[0];\n    };\n    \n    conn.sendContact = async (jid, numbers, quoted = null) => {\n        const contacts = [];\n        for (const num of numbers) {\n            const cleanNum = num.replace(/[^0-9]/g, '');\n            const name = await conn.getName(cleanNum + '@s.whatsapp.net');\n            contacts.push({\n                displayName: name,\n                vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:${name}\\nFN:${name}\\nTEL;type=CELL;type=VOICE;waid=${cleanNum}:+${cleanNum}\\nEND:VCARD`\n            });\n        }\n        \n        return conn.sendMessage(jid, {\n            contacts: {\n                displayName: contacts.length === 1 ? contacts[0].displayName : `${contacts.length} Contacts`,\n                contacts\n            }\n        }, { quoted });\n    };\n    \n    conn.sendImage = async (jid, image, caption = '', quoted = null) => {\n        let buffer;\n        if (typeof image === 'string') {\n            if (image.startsWith('http')) {\n                const axios = require('axios');\n                const { data } = await axios.get(image, { responseType: 'arraybuffer' });\n                buffer = Buffer.from(data);\n            } else {\n                buffer = require('fs').readFileSync(image);\n            }\n        } else {\n            buffer = image;\n        }\n        \n        return conn.sendMessage(jid, {\n            image: buffer,\n            caption\n        }, { quoted });\n    };\n    \n    conn.sendVideo = async (jid, video, caption = '', quoted = null) => {\n        let buffer;\n        if (typeof video === 'string') {\n            if (video.startsWith('http')) {\n                const axios = require('axios');\n                const { data } = await axios.get(video, { responseType: 'arraybuffer' });\n                buffer = Buffer.from(data);\n            } else {\n                buffer = require('fs').readFileSync(video);\n            }\n        } else {\n            buffer = video;\n        }\n        \n        return conn.sendMessage(jid, {\n            video: buffer,\n            caption\n        }, { quoted });\n    };\n    \n    conn.sendAudio = async (jid, audio, ptt = false, quoted = null) => {\n        let buffer;\n        if (typeof audio === 'string') {\n            if (audio.startsWith('http')) {\n                const axios = require('axios');\n                const { data } = await axios.get(audio, { responseType: 'arraybuffer' });\n                buffer = Buffer.from(data);\n            } else {\n                buffer = require('fs').readFileSync(audio);\n            }\n        } else {\n            buffer = audio;\n        }\n        \n        return conn.sendMessage(jid, {\n            audio: buffer,\n            ptt,\n            mimetype: 'audio/mp4'\n        }, { quoted });\n    };\n    \n    conn.sendSticker = async (jid, sticker, quoted = null) => {\n        let buffer;\n        if (typeof sticker === 'string') {\n            if (sticker.startsWith('http')) {\n                const axios = require('axios');\n                const { data } = await axios.get(sticker, { responseType: 'arraybuffer' });\n                buffer = Buffer.from(data);\n            } else {\n                buffer = require('fs').readFileSync(sticker);\n            }\n        } else {\n            buffer = sticker;\n        }\n        \n        return conn.sendMessage(jid, {\n            sticker: buffer\n        }, { quoted });\n    };\n    \n    conn.sendDocument = async (jid, doc, filename, mimetype, quoted = null) => {\n        let buffer;\n        if (typeof doc === 'string') {\n            if (doc.startsWith('http')) {\n                const axios = require('axios');\n                const { data } = await axios.get(doc, { responseType: 'arraybuffer' });\n                buffer = Buffer.from(data);\n            } else {\n                buffer = require('fs').readFileSync(doc);\n            }\n        } else {\n            buffer = doc;\n        }\n        \n        return conn.sendMessage(jid, {\n            document: buffer,\n            fileName: filename,\n            mimetype\n        }, { quoted });\n    };\n    \n    conn.downloadMediaMessage = async (msg) => {\n        const mtype = Object.keys(msg.message || {})[0];\n        const media = msg.message[mtype];\n        \n        if (!media) return null;\n        \n        const stream = await downloadContentFromMessage(media, mtype.replace('Message', ''));\n        const chunks = [];\n        \n        for await (const chunk of stream) {\n            chunks.push(chunk);\n        }\n        \n        return Buffer.concat(chunks);\n    };\n    \n    store.loadMessage = (remoteJid, id) => {\n        const messages = store.messages?.[remoteJid]?.array;\n        if (!messages) return null;\n        return messages.find(msg => msg?.key?.id === id) || null;\n    };\n};\n\nmodule.exports = { Serialize, setupExtensions, downloadMedia };\n","path":null,"size_bytes":10207,"size_tokens":null},"source-1/lib/math.js":{"content":"let modes = {\n    noob: [-3, 3,-3, 3, '+-', 15000, 10],\n    easy: [-10, 10, -10, 10, '*/+-', 20000, 40],\n    medium: [-40, 40, -20, 20, '*/+-', 40000, 150],\n    hard: [-100, 100, -70, 70, '*/+-', 60000, 350],\n    extreme: [-999999, 999999, -999999, 999999, '*/', 99999, 9999],\n    impossible: [-99999999999, 99999999999, -99999999999, 999999999999, '*/', 30000, 35000],\n    impossible2: [-999999999999999, 999999999999999, -999, 999, '/', 30000, 50000]\n  } \n  \n  let operators = {\n    '+': '+',\n    '-': '-',\n    '*': '√ó',\n    '/': '√∑'\n  }\n\n  function randomInt(from, to) {\n    if (from > to) [from, to] = [to, from]\n    from = Math.floor(from)\n    to = Math.floor(to)\n    return Math.floor((to - from) * Math.random() + from)\n  }\n  \n  function pickRandom(list) {\n    return list[Math.floor(Math.random() * list.length)]\n  }\n\n  function genMath(mode) {\n      return new Promise((resolve, reject) => {\n        let [a1, a2, b1, b2, ops, time, bonus] = modes[mode]\n        let a = randomInt(a1, a2)\n        let b = randomInt(b1, b2)\n        let op = pickRandom([...ops])\n        let result = (new Function(`return ${a} ${op.replace('/', '*')} ${b < 0 ? `(${b})` : b}`))()\n        if (op == '/') [a, result] = [result, a]\n        hasil = { \n            soal: `${a} ${operators[op]} ${b}`,\n            mode: mode,\n            waktu: time,\n            hadiah: bonus,\n            jawaban: result\n         }\n         resolve(hasil)\n      })\n  }\n  \nmodule.exports = { modes, operators, randomInt, pickRandom, genMath }\n","path":null,"size_bytes":1512,"size_tokens":null},"source-2/lib/handlers/infoHandler.js":{"content":"const { botInfo } = require('../../config');\nconst performanceMonitor = require('../utils/performanceMonitor');\nconst { logger } = require('../utils/logger');\nconst moment = require('moment-timezone');\n\nfunction getCurrentTime() {\n    moment.locale('id');\n    return {\n        tanggal: moment().tz('Asia/Jakarta').format('DD MMMM YYYY'),\n        hari: moment().tz('Asia/Jakarta').format('dddd'),\n        jam: moment().tz('Asia/Jakarta').format('HH:mm:ss')\n    };\n}\n\nasync function handleBotInfo(conn, m) {\n    try {\n        const { tanggal, hari, jam } = getCurrentTime();\n        const perf = performanceMonitor.getPerformanceData();\n        const { name: botname, owner, public: isPublic, version } = botInfo;\n        \n        const infoMessage = `\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *BOT INFO* „Äç‚ùç\n‚îú *Nama Bot* : ${botname}\n‚îú *Version* : ${version}\n‚îú *Powered* : @${'0@s.whatsapp.net'.split('@')[0]}\n‚îú *Owner* : @${owner[0].split('@')[0]}\n‚îú *Mode* : ${isPublic ? 'Public' : 'Self'}\n‚îú *Prefix* : Multi-Prefix\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *ABOUT* „Äç‚ùç\n‚îú *Tanggal* : ${tanggal}\n‚îú *Hari* : ${hari}\n‚îú *Jam* : ${jam} WIB\n‚ï∞‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\n‚ï≠‚îÄ‚î¥‚îÄ‚ùç„Äå *PERFORMANCE* „Äç‚ùç\n‚îú *Uptime* : ${perf.uptime}\n‚îú *RAM Usage* : ${perf.ram} MB\n‚îú *Node.js* : ${perf.nodeVersion}\n‚îú *Speed* : ${perf.speedTest.toFixed(2)} ms\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ùç\n        `.trim();\n\n        await conn.sendMessage(m.key.remoteJid, {\n            text: infoMessage,\n            mentions: [owner[0], '0@s.whatsapp.net']\n        }, { quoted: m });\n\n        logger.success(`‚úÖ Sent bot info`);\n    } catch (err) {\n        logger.error(`‚ùå Failed to send bot info: ${err.message}`);\n    }\n}\n\nasync function handlePing(conn, m) {\n    try {\n        const start = Date.now();\n        const pingMessage = await conn.sendMessage(m.key.remoteJid, { text: 'Testing ping...' }, { quoted: m });\n        const latency = Date.now() - start;\n        \n        await conn.sendMessage(m.key.remoteJid, {\n            text: `üèì Pong!\\n‚ö° Latency: ${latency}ms`\n        }, { quoted: m });\n        \n        await conn.deleteMessage(m.key.remoteJid, pingMessage.key);\n        logger.success(`‚úÖ Ping response: ${latency}ms`);\n    } catch (err) {\n        logger.error(`‚ùå Ping failed: ${err.message}`);\n    }\n}\n\nmodule.exports = {\n    handleBotInfo,\n    handlePing\n};","path":null,"size_bytes":2358,"size_tokens":null},"ciel/lib/exif.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst { Readable } = require('stream');\n\nclass Exif {\n    constructor(options = {}) {\n        this.packname = options.packname || 'Ciel';\n        this.author = options.author || 'Bot';\n    }\n\n    createExifBuffer() {\n        const json = {\n            'sticker-pack-id': 'ciel-bot-sticker',\n            'sticker-pack-name': this.packname,\n            'sticker-pack-publisher': this.author,\n            'emojis': ['ü§ñ'],\n            'is-avatar-sticker': 0,\n            'android-app-store-link': '',\n            'ios-app-store-link': ''\n        };\n\n        let jsonBuffer = Buffer.from(JSON.stringify(json), 'utf-8');\n        let exif = Buffer.alloc(19 + jsonBuffer.length);\n\n        exif.writeUInt32LE(0x49492A00, 0);\n        exif.writeUInt32LE(8, 4);\n        exif.writeUInt16LE(1, 8);\n        exif.writeUInt16LE(0x0112, 10);\n        exif.writeUInt16LE(7, 12);\n        exif.writeUInt32LE(jsonBuffer.length, 14);\n        exif.writeUInt32LE(19, 18);\n\n        return Buffer.concat([exif, jsonBuffer]);\n    }\n\n    async addExifToWebp(webpBuffer) {\n        try {\n            const exifBuffer = this.createExifBuffer();\n            \n            const bufferView = Buffer.from(webpBuffer);\n            \n            if (bufferView.toString('utf8', 0, 4) !== 'RIFF') {\n                throw new Error('Invalid WebP file');\n            }\n            \n            const chunk1 = bufferView.slice(0, 12);\n            const chunk2 = bufferView.slice(12);\n            \n            const exifChunk = Buffer.alloc(8 + exifBuffer.length);\n            exifChunk.write('EXIF', 0);\n            exifChunk.writeUInt32LE(exifBuffer.length, 4);\n            exifBuffer.copy(exifChunk, 8);\n            \n            const newBuffer = Buffer.concat([chunk1, exifChunk, chunk2]);\n            \n            const newSize = newBuffer.length - 8;\n            newBuffer.writeUInt32LE(newSize, 4);\n            \n            return newBuffer;\n        } catch (error) {\n            console.error('Error adding exif to webp:', error);\n            return webpBuffer;\n        }\n    }\n\n    setPackname(packname) {\n        this.packname = packname;\n    }\n\n    setAuthor(author) {\n        this.author = author;\n    }\n}\n\nconst createSticker = async (mediaBuffer, options = {}) => {\n    const sharp = require('sharp');\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const { packname = 'Ciel', author = 'Bot', type = 'default' } = options;\n    \n    try {\n        const isVideo = mediaBuffer.slice(0, 4).toString('hex') === '00000018' ||\n                       mediaBuffer.slice(4, 8).toString('ascii') === 'ftyp' ||\n                       mediaBuffer.slice(0, 3).toString('hex') === '000000';\n        \n        const isGif = mediaBuffer.slice(0, 6).toString('ascii').includes('GIF');\n        \n        let webpBuffer;\n        \n        if (isVideo || isGif) {\n            webpBuffer = await convertVideoToWebp(mediaBuffer, type);\n        } else {\n            webpBuffer = await convertImageToWebp(mediaBuffer, type);\n        }\n        \n        const exif = new Exif({ packname, author });\n        return await exif.addExifToWebp(webpBuffer);\n        \n    } catch (error) {\n        console.error('Error creating sticker:', error);\n        throw error;\n    }\n};\n\nconst convertImageToWebp = async (imageBuffer, type = 'default') => {\n    const sharp = require('sharp');\n    \n    let resizeOptions = { width: 512, height: 512, fit: 'contain', background: { r: 0, g: 0, b: 0, alpha: 0 } };\n    \n    if (type === 'circle') {\n        resizeOptions.fit = 'cover';\n    } else if (type === 'rounded') {\n        resizeOptions.fit = 'cover';\n    }\n    \n    let image = sharp(imageBuffer)\n        .resize(resizeOptions.width, resizeOptions.height, {\n            fit: resizeOptions.fit,\n            background: resizeOptions.background\n        });\n    \n    if (type === 'circle') {\n        const circleShape = Buffer.from(`\n            <svg width=\"512\" height=\"512\">\n                <circle cx=\"256\" cy=\"256\" r=\"256\" fill=\"white\"/>\n            </svg>\n        `);\n        image = image.composite([{ input: circleShape, blend: 'dest-in' }]);\n    } else if (type === 'rounded') {\n        const roundedShape = Buffer.from(`\n            <svg width=\"512\" height=\"512\">\n                <rect x=\"0\" y=\"0\" width=\"512\" height=\"512\" rx=\"60\" ry=\"60\" fill=\"white\"/>\n            </svg>\n        `);\n        image = image.composite([{ input: roundedShape, blend: 'dest-in' }]);\n    }\n    \n    return await image.webp({ quality: 80 }).toBuffer();\n};\n\nconst convertVideoToWebp = async (videoBuffer, type = 'default') => {\n    const ffmpeg = require('fluent-ffmpeg');\n    const fs = require('fs');\n    const path = require('path');\n    const os = require('os');\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.mp4`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.webp`);\n    \n    fs.writeFileSync(inputPath, videoBuffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg(inputPath)\n            .outputOptions([\n                '-vcodec', 'libwebp',\n                '-vf', 'scale=512:512:force_original_aspect_ratio=decrease,fps=15,pad=512:512:-1:-1:color=white@0.0,split[a][b];[a]palettegen=reserve_transparent=on:transparency_color=ffffff[p];[b][p]paletteuse',\n                '-loop', '0',\n                '-ss', '0',\n                '-t', '8',\n                '-preset', 'default',\n                '-an',\n                '-vsync', '0'\n            ])\n            .toFormat('webp')\n            .on('end', () => {\n                const webpBuffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(inputPath);\n                fs.unlinkSync(outputPath);\n                resolve(webpBuffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(inputPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nconst webpToImage = async (webpBuffer, format = 'png') => {\n    const sharp = require('sharp');\n    \n    return await sharp(webpBuffer)\n        .toFormat(format, { quality: 90 })\n        .toBuffer();\n};\n\nconst webpToVideo = async (webpBuffer) => {\n    const sharp = require('sharp');\n    const ffmpeg = require('fluent-ffmpeg');\n    const fs = require('fs');\n    const path = require('path');\n    const os = require('os');\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.webp`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.mp4`);\n    \n    fs.writeFileSync(inputPath, webpBuffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg(inputPath)\n            .outputOptions([\n                '-movflags', 'faststart',\n                '-pix_fmt', 'yuv420p',\n                '-vf', 'scale=512:512'\n            ])\n            .toFormat('mp4')\n            .on('end', () => {\n                const mp4Buffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(inputPath);\n                fs.unlinkSync(outputPath);\n                resolve(mp4Buffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(inputPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nmodule.exports = {\n    Exif,\n    createSticker,\n    convertImageToWebp,\n    convertVideoToWebp,\n    webpToImage,\n    webpToVideo\n};\n","path":null,"size_bytes":7567,"size_tokens":null},"source-2/lib/utils/stickerSender.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst axios = require('axios');\nconst { writeExif } = require('./mediaConverter');\nconst { logger } = require('./logger');\n\nmodule.exports = (conn) => {\n    conn.sendAsSticker = async (jid, media, quoted, options = {}) => {\n        let buffer;\n        try {\n            if (Buffer.isBuffer(media)) {\n                buffer = media;\n            } else if (typeof media === 'string') {\n                if (/^data:/.test(media)) {\n                    buffer = Buffer.from(media.split`,`[1], 'base64');\n                } else if (/^https?:\\/\\//.test(media)) {\n                    const res = await axios.get(media, { responseType: 'arraybuffer' });\n                    buffer = res.data;\n                } else if (fs.existsSync(media)) {\n                    buffer = fs.readFileSync(media);\n                } else {\n                    throw new Error('Invalid media path or URL');\n                }\n            } else {\n                throw new Error('Invalid media type');\n            }\n\n            const result = await writeExif(buffer, options);\n            await conn.sendMessage(jid, { \n                sticker: { url: result }, \n                ...options \n            }, { \n                quoted,\n                ephemeralExpiration: quoted?.expiration || 0 \n            });\n        } catch (error) {\n            logger.error('Error creating sticker:', error);\n            throw error;\n        }\n    };\n};","path":null,"size_bytes":1469,"size_tokens":null},"ciel/src/handlers/commands/game.js":{"content":"const settings = require('../../../config/settings');\nconst { \n    getOrCreateUser, \n    updateUser, \n    createActiveGame, \n    getActiveGame, \n    updateActiveGame, \n    deleteActiveGame \n} = require('../../services/database');\nconst { genMath, modes } = require('../../../lib/math');\n\nconst tictactoe = async (conn, m, { args, text, user }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    \n    const target = m.mentionedJid[0];\n    if (!target) return m.reply('Tag lawan untuk bermain TicTacToe!\\nContoh: .tictactoe @user');\n    \n    if (target === m.sender) return m.reply('Tidak bisa bermain dengan diri sendiri!');\n    \n    const existingGame = await getActiveGame(m.chat, 'tictactoe');\n    if (existingGame) return m.reply('Masih ada game TicTacToe yang berjalan! Selesaikan dulu atau tunggu timeout.');\n    \n    const board = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];\n    const gameData = {\n        board,\n        playerX: m.sender,\n        playerO: target,\n        currentTurn: m.sender,\n        moves: 0\n    };\n    \n    await createActiveGame(m.chat, 'tictactoe', gameData, [m.sender, target], 10);\n    \n    const boardDisplay = renderTicTacToeBoard(board);\n    \n    m.reply(`*üéÆ TicTacToe*\n\n@${m.sender.split('@')[0]} (X) vs @${target.split('@')[0]} (O)\n\n${boardDisplay}\n\nGiliran: @${m.sender.split('@')[0]}\nKetik nomor 1-9 untuk bermain!`, { mentions: [m.sender, target] });\n};\n\nconst ttt = tictactoe;\n\nconst tttmove = async (conn, m, { args }) => {\n    if (!m.isGroup) return;\n    \n    const move = parseInt(m.text);\n    if (isNaN(move) || move < 1 || move > 9) return;\n    \n    const game = await getActiveGame(m.chat, 'tictactoe');\n    if (!game) return;\n    \n    const gameData = game.gameData;\n    \n    if (m.sender !== gameData.currentTurn) return;\n    \n    if (gameData.board[move - 1] === 'X' || gameData.board[move - 1] === 'O') {\n        return m.reply('Kotak sudah terisi!');\n    }\n    \n    const symbol = m.sender === gameData.playerX ? 'X' : 'O';\n    gameData.board[move - 1] = symbol;\n    gameData.moves++;\n    \n    const winner = checkTicTacToeWinner(gameData.board);\n    \n    if (winner) {\n        await deleteActiveGame(m.chat, 'tictactoe');\n        const winnerId = winner === 'X' ? gameData.playerX : gameData.playerO;\n        const loserId = winner === 'X' ? gameData.playerO : gameData.playerX;\n        \n        await updateUser(winnerId, { money: { increment: 500 } });\n        \n        const boardDisplay = renderTicTacToeBoard(gameData.board);\n        return m.reply(`*üéÆ TicTacToe - Selesai!*\n\n${boardDisplay}\n\nüèÜ Pemenang: @${winnerId.split('@')[0]}\nüí∞ +500 uang!`, { mentions: [winnerId, loserId] });\n    }\n    \n    if (gameData.moves >= 9) {\n        await deleteActiveGame(m.chat, 'tictactoe');\n        const boardDisplay = renderTicTacToeBoard(gameData.board);\n        return m.reply(`*üéÆ TicTacToe - Seri!*\n\n${boardDisplay}\n\nPermainan berakhir seri!`, { mentions: [gameData.playerX, gameData.playerO] });\n    }\n    \n    gameData.currentTurn = m.sender === gameData.playerX ? gameData.playerO : gameData.playerX;\n    await updateActiveGame(m.chat, 'tictactoe', gameData);\n    \n    const boardDisplay = renderTicTacToeBoard(gameData.board);\n    m.reply(`*üéÆ TicTacToe*\n\n${boardDisplay}\n\nGiliran: @${gameData.currentTurn.split('@')[0]}`, { mentions: [gameData.currentTurn] });\n};\n\nconst deletettt = async (conn, m, { isOwner }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (!m.isAdmin && !isOwner) return m.reply(settings.messages.admin);\n    \n    const game = await getActiveGame(m.chat, 'tictactoe');\n    if (!game) return m.reply('Tidak ada game TicTacToe yang berjalan!');\n    \n    await deleteActiveGame(m.chat, 'tictactoe');\n    m.reply('Game TicTacToe telah dihapus!');\n};\n\nfunction renderTicTacToeBoard(board) {\n    return `\n ${board[0]} ‚îÇ ${board[1]} ‚îÇ ${board[2]}\n‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ\n ${board[3]} ‚îÇ ${board[4]} ‚îÇ ${board[5]}\n‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ\n ${board[6]} ‚îÇ ${board[7]} ‚îÇ ${board[8]}\n    `.trim();\n}\n\nfunction checkTicTacToeWinner(board) {\n    const winPatterns = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8],\n        [0, 3, 6], [1, 4, 7], [2, 5, 8],\n        [0, 4, 8], [2, 4, 6]\n    ];\n    \n    for (const pattern of winPatterns) {\n        const [a, b, c] = pattern;\n        if (board[a] === board[b] && board[b] === board[c]) {\n            return board[a];\n        }\n    }\n    return null;\n}\n\nconst slot = async (conn, m, { args, user }) => {\n    const bet = parseInt(args[0]) || 100;\n    \n    if (bet < 100) return m.reply('Minimal taruhan 100!');\n    if (bet > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    \n    const symbols = ['üçí', 'üçã', 'üçä', 'üçá', '‚≠ê', 'üíé', '7Ô∏è‚É£'];\n    const getRandomSymbol = () => symbols[Math.floor(Math.random() * symbols.length)];\n    \n    const row1 = [getRandomSymbol(), getRandomSymbol(), getRandomSymbol()];\n    const row2 = [getRandomSymbol(), getRandomSymbol(), getRandomSymbol()];\n    const row3 = [getRandomSymbol(), getRandomSymbol(), getRandomSymbol()];\n    \n    const slotDisplay = `\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë ${row1[0]} ‚îÇ ${row1[1]} ‚îÇ ${row1[2]} ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë ${row2[0]} ‚îÇ ${row2[1]} ‚îÇ ${row2[2]} ‚ïë ‚¨ÖÔ∏è\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë ${row3[0]} ‚îÇ ${row3[1]} ‚îÇ ${row3[2]} ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n    `.trim();\n    \n    let winAmount = 0;\n    let winMessage = '';\n    \n    if (row2[0] === row2[1] && row2[1] === row2[2]) {\n        if (row2[0] === '7Ô∏è‚É£') {\n            winAmount = bet * 10;\n            winMessage = 'üéâ JACKPOT 777! x10';\n        } else if (row2[0] === 'üíé') {\n            winAmount = bet * 5;\n            winMessage = 'üíé DIAMOND! x5';\n        } else if (row2[0] === '‚≠ê') {\n            winAmount = bet * 3;\n            winMessage = '‚≠ê STAR! x3';\n        } else {\n            winAmount = bet * 2;\n            winMessage = 'üé∞ Triple Match! x2';\n        }\n    } else if (row2[0] === row2[1] || row2[1] === row2[2]) {\n        winAmount = Math.floor(bet * 1.5);\n        winMessage = '‚ú® Double Match! x1.5';\n    }\n    \n    const profit = winAmount - bet;\n    await updateUser(m.sender, { money: { increment: profit } });\n    \n    const newBalance = user.money + profit;\n    \n    let resultText = `*üé∞ SLOT MACHINE*\n\n${slotDisplay}\n\nTaruhan: ${bet}\n`;\n    \n    if (winAmount > 0) {\n        resultText += `\n${winMessage}\nMenang: +${winAmount}\nSaldo: ${newBalance}`;\n    } else {\n        resultText += `\n‚ùå Tidak beruntung!\nKalah: -${bet}\nSaldo: ${newBalance}`;\n    }\n    \n    m.reply(resultText);\n};\n\nconst daily = async (conn, m, { user }) => {\n    const now = new Date();\n    const lastDaily = user.lastDaily ? new Date(user.lastDaily) : null;\n    \n    if (lastDaily) {\n        const diff = now - lastDaily;\n        const hours = Math.floor(diff / (1000 * 60 * 60));\n        \n        if (hours < 24) {\n            const remaining = 24 - hours;\n            return m.reply(`‚è∞ Daily reward sudah diklaim!\\nTunggu ${remaining} jam lagi.`);\n        }\n    }\n    \n    const reward = Math.floor(Math.random() * 5000) + 1000;\n    const limitReward = Math.floor(Math.random() * 5) + 1;\n    \n    await updateUser(m.sender, { \n        money: { increment: reward },\n        limit: { increment: limitReward },\n        lastDaily: now\n    });\n    \n    m.reply(`*üéÅ Daily Reward*\n\nüí∞ Uang: +${reward}\nüìä Limit: +${limitReward}\n\nKlaim lagi besok!`);\n};\n\nconst weekly = async (conn, m, { user }) => {\n    const now = new Date();\n    const lastWeekly = user.lastWeekly ? new Date(user.lastWeekly) : null;\n    \n    if (lastWeekly) {\n        const diff = now - lastWeekly;\n        const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n        \n        if (days < 7) {\n            const remaining = 7 - days;\n            return m.reply(`‚è∞ Weekly reward sudah diklaim!\\nTunggu ${remaining} hari lagi.`);\n        }\n    }\n    \n    const reward = Math.floor(Math.random() * 25000) + 10000;\n    const limitReward = Math.floor(Math.random() * 15) + 5;\n    \n    await updateUser(m.sender, { \n        money: { increment: reward },\n        limit: { increment: limitReward },\n        lastWeekly: now\n    });\n    \n    m.reply(`*üéÅ Weekly Reward*\n\nüí∞ Uang: +${reward}\nüìä Limit: +${limitReward}\n\nKlaim lagi minggu depan!`);\n};\n\nconst transfer = async (conn, m, { args, user }) => {\n    const target = m.mentionedJid[0];\n    if (!target) return m.reply('Tag user yang akan ditransfer!\\nContoh: .transfer @user 1000');\n    \n    if (target === m.sender) return m.reply('Tidak bisa transfer ke diri sendiri!');\n    \n    const amount = parseInt(args[1]) || parseInt(args[0]?.replace(/[^0-9]/g, ''));\n    if (!amount || amount < 100) return m.reply('Minimal transfer 100!');\n    if (amount > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    \n    const targetUser = await getOrCreateUser(target, null);\n    \n    await updateUser(m.sender, { money: { decrement: amount } });\n    await updateUser(target, { money: { increment: amount } });\n    \n    m.reply(`*üí∏ Transfer Berhasil*\n\nDari: @${m.sender.split('@')[0]}\nKe: @${target.split('@')[0]}\nJumlah: ${amount}\n\nSaldo kamu: ${user.money - amount}`, { mentions: [m.sender, target] });\n};\n\nconst tf = transfer;\n\nconst leaderboard = async (conn, m, {}) => {\n    const { prisma } = require('../../services/database');\n    \n    try {\n        const topMoney = await prisma.user.findMany({\n            orderBy: { money: 'desc' },\n            take: 10\n        });\n        \n        let text = '*üèÜ Leaderboard Uang*\\n\\n';\n        \n        topMoney.forEach((u, i) => {\n            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;\n            text += `${medal} ${u.name || u.jid.split('@')[0]}: ${u.money}\\n`;\n        });\n        \n        m.reply(text);\n    } catch (e) {\n        console.error('Leaderboard error:', e);\n        m.reply('Gagal mendapatkan leaderboard!');\n    }\n};\n\nconst lb = leaderboard;\nconst top = leaderboard;\n\nconst profile = async (conn, m, { user }) => {\n    const target = m.mentionedJid[0] || m.sender;\n    const targetUser = target === m.sender ? user : await getOrCreateUser(target, null);\n    \n    if (!targetUser) return m.reply('User tidak ditemukan!');\n    \n    const premiumStatus = targetUser.premium ? '‚úÖ Premium' : '‚ùå Free';\n    const vipStatus = targetUser.vip ? '‚úÖ VIP' : '‚ùå';\n    \n    const text = `*üë§ Profile*\n\n*Nama:* ${targetUser.name || 'Unknown'}\n*JID:* ${target}\n\n*üí∞ Uang:* ${targetUser.money}\n*üìä Limit:* ${targetUser.limit}\n*‚≠ê Premium:* ${premiumStatus}\n*üëë VIP:* ${vipStatus}\n*üö´ Banned:* ${targetUser.banned ? '‚úÖ' : '‚ùå'}\n\n*üìÖ Bergabung:* ${new Date(targetUser.createdAt).toLocaleDateString('id-ID')}`;\n    \n    m.reply(text, { mentions: [target] });\n};\n\nconst cekmoney = async (conn, m, { user }) => {\n    m.reply(`üí∞ Uang kamu: ${user.money}`);\n};\n\nconst cekuang = cekmoney;\nconst money = cekmoney;\n\nconst ceklimit = async (conn, m, { user }) => {\n    m.reply(`üìä Limit kamu: ${user.limit}`);\n};\n\nconst limit = ceklimit;\n\nconst coinflip = async (conn, m, { args, user }) => {\n    const choice = args[0]?.toLowerCase();\n    if (!['heads', 'tails', 'h', 't'].includes(choice)) {\n        return m.reply('Pilih heads (h) atau tails (t)!\\nContoh: .coinflip h 100');\n    }\n    \n    const bet = parseInt(args[1]) || 100;\n    \n    if (bet < 100) return m.reply('Minimal taruhan 100!');\n    if (bet > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    \n    const result = Math.random() < 0.5 ? 'heads' : 'tails';\n    const userChoice = choice === 'h' ? 'heads' : choice === 't' ? 'tails' : choice;\n    const win = result === userChoice;\n    \n    const emoji = result === 'heads' ? 'üëë' : 'ü¶Ö';\n    const profit = win ? bet : -bet;\n    \n    await updateUser(m.sender, { money: { increment: profit } });\n    \n    m.reply(`*ü™ô Coin Flip*\n\n${emoji} Hasil: ${result.toUpperCase()}\nPilihan: ${userChoice.toUpperCase()}\n\n${win ? `üéâ Menang! +${bet}` : `üòî Kalah! -${bet}`}\nSaldo: ${user.money + profit}`);\n};\n\nconst cf = coinflip;\n\nconst dice = async (conn, m, { args, user }) => {\n    const guess = parseInt(args[0]);\n    if (!guess || guess < 1 || guess > 6) {\n        return m.reply('Tebak angka 1-6!\\nContoh: .dice 4 100');\n    }\n    \n    const bet = parseInt(args[1]) || 100;\n    \n    if (bet < 100) return m.reply('Minimal taruhan 100!');\n    if (bet > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    \n    const result = Math.floor(Math.random() * 6) + 1;\n    const diceEmojis = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];\n    const win = result === guess;\n    \n    const profit = win ? bet * 5 : -bet;\n    \n    await updateUser(m.sender, { money: { increment: profit } });\n    \n    m.reply(`*üé≤ Dice Game*\n\n${diceEmojis[result - 1]} Hasil: ${result}\nTebakan: ${guess}\n\n${win ? `üéâ Menang! +${bet * 5}` : `üòî Kalah! -${bet}`}\nSaldo: ${user.money + profit}`);\n};\n\nconst rps = async (conn, m, { args, user }) => {\n    const choices = ['rock', 'paper', 'scissors', 'r', 'p', 's', 'batu', 'kertas', 'gunting'];\n    const choice = args[0]?.toLowerCase();\n    \n    if (!choices.includes(choice)) {\n        return m.reply('Pilih rock/paper/scissors!\\nContoh: .rps rock 100');\n    }\n    \n    const bet = parseInt(args[1]) || 100;\n    \n    if (bet < 100) return m.reply('Minimal taruhan 100!');\n    if (bet > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    \n    const normalize = (c) => {\n        if (['r', 'rock', 'batu'].includes(c)) return 'rock';\n        if (['p', 'paper', 'kertas'].includes(c)) return 'paper';\n        return 'scissors';\n    };\n    \n    const userChoice = normalize(choice);\n    const botChoice = ['rock', 'paper', 'scissors'][Math.floor(Math.random() * 3)];\n    \n    const emojis = { rock: 'ü™®', paper: 'üìÑ', scissors: '‚úÇÔ∏è' };\n    \n    let result, profit;\n    if (userChoice === botChoice) {\n        result = 'Seri!';\n        profit = 0;\n    } else if (\n        (userChoice === 'rock' && botChoice === 'scissors') ||\n        (userChoice === 'paper' && botChoice === 'rock') ||\n        (userChoice === 'scissors' && botChoice === 'paper')\n    ) {\n        result = 'üéâ Menang!';\n        profit = bet;\n    } else {\n        result = 'üòî Kalah!';\n        profit = -bet;\n    }\n    \n    await updateUser(m.sender, { money: { increment: profit } });\n    \n    m.reply(`*‚úä‚úã‚úåÔ∏è Rock Paper Scissors*\n\nKamu: ${emojis[userChoice]} ${userChoice}\nBot: ${emojis[botChoice]} ${botChoice}\n\n${result}\n${profit !== 0 ? (profit > 0 ? `+${profit}` : profit) : ''}\nSaldo: ${user.money + profit}`);\n};\n\nconst suit = rps;\n\nconst math = async (conn, m, { args, user }) => {\n    const mode = args[0]?.toLowerCase() || 'easy';\n    const validModes = Object.keys(modes);\n    \n    if (!validModes.includes(mode)) {\n        return m.reply(`*üßÆ Mode tidak valid!*\\n\\nMode tersedia:\\n${validModes.join(', ')}\\n\\nContoh: .math easy`);\n    }\n    \n    const existingGame = await getActiveGame(m.chat || m.sender, 'math');\n    if (existingGame) {\n        return m.reply('Masih ada soal matematika yang belum dijawab!\\nJawab dulu atau tunggu timeout.');\n    }\n    \n    try {\n        const question = await genMath(mode);\n        \n        const gameData = {\n            soal: question.soal,\n            jawaban: question.jawaban,\n            mode: question.mode,\n            hadiah: question.hadiah,\n            timestamp: Date.now()\n        };\n        \n        const timeoutMinutes = Math.ceil(question.waktu / 60000);\n        await createActiveGame(m.chat || m.sender, 'math', gameData, [m.sender], timeoutMinutes);\n        \n        m.reply(`*üßÆ Math Game*\n\n*Mode:* ${mode}\n*Soal:* ${question.soal} = ?\n*Hadiah:* ${question.hadiah} uang\n*Waktu:* ${question.waktu / 1000} detik\n\nKetik jawaban angka untuk menjawab!`);\n    } catch (e) {\n        console.error('Math game error:', e);\n        m.reply('Gagal membuat soal matematika!');\n    }\n};\n\nconst matematik = math;\nconst matematika = math;\n\nconst mathanswer = async (conn, m, { user }) => {\n    const answer = parseInt(m.text);\n    if (isNaN(answer)) return;\n    \n    const game = await getActiveGame(m.chat || m.sender, 'math');\n    if (!game) return;\n    \n    const gameData = game.gameData;\n    \n    if (answer === gameData.jawaban) {\n        await deleteActiveGame(m.chat || m.sender, 'math');\n        await updateUser(m.sender, { money: { increment: gameData.hadiah } });\n        \n        m.reply(`*üéâ Benar!*\n\n*Jawaban:* ${gameData.jawaban}\n*Hadiah:* +${gameData.hadiah} uang\n\nSelamat @${m.sender.split('@')[0]}!`, { mentions: [m.sender] });\n    }\n};\n\nconst casino = async (conn, m, { args, user }) => {\n    const bet = parseInt(args[0]);\n    \n    if (!bet || isNaN(bet)) {\n        return m.reply('Masukkan jumlah taruhan!\\nContoh: .casino 1000');\n    }\n    \n    if (bet < 100) return m.reply('Minimal taruhan 100!');\n    if (bet > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    if (user.limit < 1) return m.reply('Limit kamu habis! Klaim daily atau beli limit.');\n    \n    await updateUser(m.sender, { \n        limit: { decrement: 1 },\n        money: { decrement: bet }\n    });\n    \n    const botPoint = Math.floor(Math.random() * 101);\n    const playerPoint = Math.floor(Math.random() * 81);\n    \n    let result, winnings = 0;\n    \n    if (botPoint > playerPoint) {\n        result = 'üòî *You LOSE*';\n        winnings = 0;\n    } else if (botPoint < playerPoint) {\n        result = 'üéâ *You WIN*';\n        winnings = bet * 2;\n        await updateUser(m.sender, { money: { increment: winnings } });\n    } else {\n        result = 'ü§ù *SERI*';\n        winnings = bet;\n        await updateUser(m.sender, { money: { increment: winnings } });\n    }\n    \n    const newBalance = user.money - bet + winnings;\n    \n    m.reply(`*üí∞ Casino üí∞*\n\n*Kamu:* ${playerPoint} Point\n*Computer:* ${botPoint} Point\n\n${result}\n${winnings > bet ? `Menang: +${winnings - bet}` : winnings === 0 ? `Kalah: -${bet}` : 'Taruhan dikembalikan'}\nSaldo: ${newBalance}`);\n};\n\nconst samgong = async (conn, m, { args, user }) => {\n    const bet = parseInt(args[0]);\n    \n    if (!bet || isNaN(bet)) {\n        return m.reply('Masukkan jumlah taruhan!\\nContoh: .samgong 5000');\n    }\n    \n    if (bet < 5000) return m.reply('Minimal taruhan 5000!');\n    if (bet > user.money) return m.reply(`Uang kamu tidak cukup!\\nUang: ${user.money}`);\n    if (user.limit < 1) return m.reply('Limit kamu habis! Klaim daily atau beli limit.');\n    \n    await updateUser(m.sender, { \n        limit: { decrement: 1 },\n        money: { decrement: bet }\n    });\n    \n    const suits = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è'];\n    const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\n    \n    const getCard = () => {\n        const rank = ranks[Math.floor(Math.random() * ranks.length)];\n        const suit = suits[Math.floor(Math.random() * suits.length)];\n        return { rank, suit, display: `${rank}${suit}` };\n    };\n    \n    const calcScore = (cards) => {\n        return cards.reduce((sum, card) => {\n            if (['J', 'Q', 'K'].includes(card.rank)) return sum + 10;\n            if (card.rank === 'A') return sum + 1;\n            return sum + parseInt(card.rank);\n        }, 0) % 10;\n    };\n    \n    const playerCards = [getCard(), getCard(), getCard()];\n    const botCards = [getCard(), getCard(), getCard()];\n    \n    const playerScore = calcScore(playerCards);\n    const botScore = calcScore(botCards);\n    \n    let result, winnings = 0;\n    \n    if (playerScore > botScore) {\n        winnings = Math.floor(bet * 2.5);\n        result = `üéâ *Kamu menang!* +${winnings - bet}`;\n        await updateUser(m.sender, { money: { increment: winnings } });\n    } else if (playerScore < botScore) {\n        winnings = 0;\n        result = `üòî *Bot menang!* -${bet}`;\n    } else {\n        winnings = bet;\n        result = 'ü§ù *Seri!* Taruhan dikembalikan';\n        await updateUser(m.sender, { money: { increment: bet } });\n    }\n    \n    const newBalance = user.money - bet + winnings;\n    \n    m.reply(`*üÉè Samgong üÉè*\n\n*Kartu Kamu:* ${playerCards.map(c => c.display).join(' ')}\n*Score:* ${playerScore}\n\n*Kartu Bot:* ${botCards.map(c => c.display).join(' ')}\n*Score:* ${botScore}\n\n${result}\nSaldo: ${newBalance}`);\n};\n\nconst merampok = async (conn, m, { args, user }) => {\n    if (!m.isGroup) return m.reply(settings.messages.group);\n    if (user.limit < 1) return m.reply('Limit kamu habis! Klaim daily atau beli limit.');\n    \n    const target = m.mentionedJid[0] || (m.quoted ? m.quoted.sender : null);\n    if (!target) return m.reply('Tag target yang ingin dirampok!\\nContoh: .merampok @user');\n    if (target === m.sender) return m.reply('Tidak bisa merampok diri sendiri!');\n    \n    const now = new Date();\n    const lastRampok = user.lastRampok ? new Date(user.lastRampok) : null;\n    \n    if (lastRampok) {\n        const diff = now - lastRampok;\n        const hoursPassed = diff / (1000 * 60 * 60);\n        \n        if (hoursPassed < 1) {\n            const minutesLeft = Math.ceil(60 - (diff / (1000 * 60)));\n            return m.reply(`‚è∞ Kamu sudah merampok dan sedang bersembunyi!\\nTunggu ${minutesLeft} menit lagi.`);\n        }\n    }\n    \n    const targetUser = await getOrCreateUser(target, null);\n    if (!targetUser) return m.reply('Target tidak terdaftar di database!');\n    if (targetUser.money < 10000) return m.reply('Target terlalu miskin untuk dirampok! üíÄ');\n    \n    await updateUser(m.sender, { limit: { decrement: 1 } });\n    \n    const dapat = Math.floor(Math.random() * 10000) + 1000;\n    const actualDapat = Math.min(dapat, targetUser.money);\n    \n    await updateUser(target, { money: { decrement: actualDapat } });\n    await updateUser(m.sender, { \n        money: { increment: actualDapat },\n        lastRampok: now\n    });\n    \n    m.reply(`*üî´ Merampok*\n\nBerhasil merampok @${target.split('@')[0]}!\nüí∞ Dapat: +${actualDapat} uang\n\nSaldo: ${user.money + actualDapat}`, { mentions: [target] });\n};\n\nconst rampok = merampok;\n\nconst begal = async (conn, m, { user }) => {\n    if (user.limit < 1) return m.reply('Limit kamu habis! Klaim daily atau beli limit.');\n    \n    const now = new Date();\n    const lastBegal = user.lastBegal ? new Date(user.lastBegal) : null;\n    \n    if (lastBegal) {\n        const diff = now - lastBegal;\n        const hoursPassed = diff / (1000 * 60 * 60);\n        \n        if (hoursPassed < 1) {\n            const minutesLeft = Math.ceil(60 - (diff / (1000 * 60)));\n            return m.reply(`‚è∞ Kamu sedang bersembunyi dari polisi!\\nTunggu ${minutesLeft} menit lagi.`);\n        }\n    }\n    \n    await updateUser(m.sender, { limit: { decrement: 1 } });\n    \n    const randomUang = Math.floor(Math.random() * 10001);\n    const outcomes = [\n        { text: 'Pemain Berhasil Kabur!', type: 'fail' },\n        { text: 'Pemain Melarikan Diri!', type: 'fail' },\n        { text: 'Pemain Bersembunyi!', type: 'fail' },\n        { text: 'Pemain Bunuh Diri!', type: 'lose' },\n        { text: 'Pemain Berhasil Tertangkap!', type: 'win' },\n        { text: 'Pemain Tidak Ditemukan!', type: 'fail' },\n        { text: 'Pemain Lebih Kuat Dari Kamu!', type: 'lose' },\n        { text: 'Pemain Menggunakan Cheat!', type: 'lose' },\n        { text: 'Pemain Lapor Polisi!', type: 'fail' },\n        { text: 'Pemain Tertangkap!', type: 'win' },\n        { text: 'Pemain Menyerahkan Diri!', type: 'win' }\n    ];\n    \n    const outcome = outcomes[Math.floor(Math.random() * outcomes.length)];\n    let result, profit = 0;\n    \n    if (outcome.type === 'win') {\n        profit = randomUang;\n        result = `üéâ ${outcome.text}\\n\\nBerhasil mendapatkan: +${randomUang} uang`;\n        await updateUser(m.sender, { \n            money: { increment: randomUang },\n            lastBegal: now\n        });\n    } else if (outcome.type === 'lose') {\n        profit = -randomUang;\n        result = `üíÄ ${outcome.text}\\n\\nKamu kehilangan: -${randomUang} uang`;\n        await updateUser(m.sender, { money: { decrement: randomUang } });\n    } else {\n        result = `üòÖ ${outcome.text}\\n\\nGagal membegal, coba lagi!`;\n    }\n    \n    m.reply(`*üî™ Begal*\n\n${result}\nSaldo: ${user.money + profit}`);\n};\n\nconst buylimit = async (conn, m, { args, user }) => {\n    const amount = parseInt(args[0]);\n    \n    if (!amount || isNaN(amount)) {\n        return m.reply(`*üí≥ Buy Limit*\n\nHarga: 1 limit = 500 uang\n\nContoh: .buylimit 10\n(Beli 10 limit = 5000 uang)\n\nUang kamu: ${user.money}`);\n    }\n    \n    if (amount < 1) return m.reply('Minimal beli 1 limit!');\n    \n    const price = amount * 500;\n    \n    if (price > user.money) {\n        return m.reply(`Uang kamu tidak cukup!\nHarga ${amount} limit: ${price}\nUang kamu: ${user.money}`);\n    }\n    \n    await updateUser(m.sender, { \n        money: { decrement: price },\n        limit: { increment: amount }\n    });\n    \n    m.reply(`*üí≥ Buy Limit Berhasil!*\n\nBeli: ${amount} limit\nHarga: -${price} uang\n\nLimit sekarang: ${user.limit + amount}\nSaldo: ${user.money - price}`);\n};\n\nconst beli = buylimit;\nconst buy = buylimit;\n\nmodule.exports = {\n    tictactoe,\n    ttt,\n    tttmove,\n    deletettt,\n    slot,\n    daily,\n    weekly,\n    transfer,\n    tf,\n    leaderboard,\n    lb,\n    top,\n    profile,\n    cekmoney,\n    cekuang,\n    money,\n    ceklimit,\n    limit,\n    coinflip,\n    cf,\n    dice,\n    rps,\n    suit,\n    math,\n    matematik,\n    matematika,\n    mathanswer,\n    casino,\n    samgong,\n    merampok,\n    rampok,\n    begal,\n    buylimit,\n    beli,\n    buy\n};\n","path":null,"size_bytes":25667,"size_tokens":null},"ciel/lib/converter.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst os = require('os');\n\nconst toAudio = async (buffer, ext = 'mp3') => {\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.tmp`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.${ext}`);\n    \n    fs.writeFileSync(inputPath, buffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg(inputPath)\n            .audioCodec(ext === 'mp3' ? 'libmp3lame' : 'aac')\n            .audioBitrate('128k')\n            .audioChannels(2)\n            .audioFrequency(44100)\n            .toFormat(ext)\n            .on('end', () => {\n                const audioBuffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(inputPath);\n                fs.unlinkSync(outputPath);\n                resolve(audioBuffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(inputPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nconst toPTT = async (buffer) => {\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.tmp`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.opus`);\n    \n    fs.writeFileSync(inputPath, buffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg(inputPath)\n            .audioCodec('libopus')\n            .audioBitrate('128k')\n            .audioChannels(1)\n            .audioFrequency(48000)\n            .outputOptions(['-avoid_negative_ts', 'make_zero'])\n            .toFormat('opus')\n            .on('end', () => {\n                const opusBuffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(inputPath);\n                fs.unlinkSync(outputPath);\n                resolve(opusBuffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(inputPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nconst toVideo = async (buffer, options = {}) => {\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const { \n        format = 'mp4',\n        width = null,\n        height = null,\n        videoBitrate = '1000k',\n        audioBitrate = '128k'\n    } = options;\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.tmp`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.${format}`);\n    \n    fs.writeFileSync(inputPath, buffer);\n    \n    return new Promise((resolve, reject) => {\n        let command = ffmpeg(inputPath)\n            .videoCodec('libx264')\n            .audioCodec('aac')\n            .videoBitrate(videoBitrate)\n            .audioBitrate(audioBitrate)\n            .outputOptions([\n                '-movflags', 'faststart',\n                '-pix_fmt', 'yuv420p'\n            ])\n            .toFormat(format);\n        \n        if (width && height) {\n            command = command.size(`${width}x${height}`);\n        }\n        \n        command\n            .on('end', () => {\n                const videoBuffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(inputPath);\n                fs.unlinkSync(outputPath);\n                resolve(videoBuffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(inputPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nconst toGif = async (buffer) => {\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.tmp`);\n    const palettePath = path.join(tempDir, `palette_${Date.now()}.png`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.gif`);\n    \n    fs.writeFileSync(inputPath, buffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg(inputPath)\n            .outputOptions([\n                '-vf', 'fps=10,scale=320:-1:flags=lanczos,palettegen=stats_mode=diff'\n            ])\n            .on('end', () => {\n                ffmpeg(inputPath)\n                    .input(palettePath)\n                    .outputOptions([\n                        '-lavfi', 'fps=10,scale=320:-1:flags=lanczos [x]; [x][1:v] paletteuse=dither=bayer:bayer_scale=5:diff_mode=rectangle'\n                    ])\n                    .toFormat('gif')\n                    .on('end', () => {\n                        const gifBuffer = fs.readFileSync(outputPath);\n                        fs.unlinkSync(inputPath);\n                        fs.unlinkSync(palettePath);\n                        fs.unlinkSync(outputPath);\n                        resolve(gifBuffer);\n                    })\n                    .on('error', (err) => {\n                        cleanup();\n                        reject(err);\n                    })\n                    .save(outputPath);\n            })\n            .on('error', (err) => {\n                cleanup();\n                reject(err);\n            })\n            .save(palettePath);\n        \n        function cleanup() {\n            try { fs.unlinkSync(inputPath); } catch (e) {}\n            try { fs.unlinkSync(palettePath); } catch (e) {}\n            try { fs.unlinkSync(outputPath); } catch (e) {}\n        }\n    });\n};\n\nconst resizeImage = async (buffer, width, height, fit = 'contain') => {\n    const sharp = require('sharp');\n    \n    return await sharp(buffer)\n        .resize(width, height, { fit, background: { r: 0, g: 0, b: 0, alpha: 0 } })\n        .toBuffer();\n};\n\nconst compressImage = async (buffer, quality = 80) => {\n    const sharp = require('sharp');\n    \n    const metadata = await sharp(buffer).metadata();\n    \n    if (metadata.format === 'png') {\n        return await sharp(buffer)\n            .png({ quality, compressionLevel: 9 })\n            .toBuffer();\n    } else {\n        return await sharp(buffer)\n            .jpeg({ quality })\n            .toBuffer();\n    }\n};\n\nconst convertImageFormat = async (buffer, format = 'png') => {\n    const sharp = require('sharp');\n    \n    return await sharp(buffer)\n        .toFormat(format, { quality: 90 })\n        .toBuffer();\n};\n\nconst getMediaInfo = async (buffer) => {\n    const sharp = require('sharp');\n    \n    try {\n        const metadata = await sharp(buffer).metadata();\n        return {\n            format: metadata.format,\n            width: metadata.width,\n            height: metadata.height,\n            size: buffer.length,\n            hasAlpha: metadata.hasAlpha || false\n        };\n    } catch (error) {\n        return null;\n    }\n};\n\nconst base64ToBuffer = (base64) => {\n    const matches = base64.match(/^data:([A-Za-z-+\\/]+);base64,(.+)$/);\n    if (matches && matches.length === 3) {\n        return Buffer.from(matches[2], 'base64');\n    }\n    return Buffer.from(base64, 'base64');\n};\n\nconst bufferToBase64 = (buffer, mimeType = 'image/png') => {\n    return `data:${mimeType};base64,${buffer.toString('base64')}`;\n};\n\nconst extractAudio = async (videoBuffer) => {\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const tempDir = os.tmpdir();\n    const inputPath = path.join(tempDir, `input_${Date.now()}.mp4`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.mp3`);\n    \n    fs.writeFileSync(inputPath, videoBuffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg(inputPath)\n            .noVideo()\n            .audioCodec('libmp3lame')\n            .audioBitrate('192k')\n            .toFormat('mp3')\n            .on('end', () => {\n                const audioBuffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(inputPath);\n                fs.unlinkSync(outputPath);\n                resolve(audioBuffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(inputPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nconst addAudioToVideo = async (videoBuffer, audioBuffer) => {\n    const ffmpeg = require('fluent-ffmpeg');\n    \n    const tempDir = os.tmpdir();\n    const videoPath = path.join(tempDir, `video_${Date.now()}.mp4`);\n    const audioPath = path.join(tempDir, `audio_${Date.now()}.mp3`);\n    const outputPath = path.join(tempDir, `output_${Date.now()}.mp4`);\n    \n    fs.writeFileSync(videoPath, videoBuffer);\n    fs.writeFileSync(audioPath, audioBuffer);\n    \n    return new Promise((resolve, reject) => {\n        ffmpeg()\n            .input(videoPath)\n            .input(audioPath)\n            .outputOptions([\n                '-c:v', 'copy',\n                '-c:a', 'aac',\n                '-map', '0:v:0',\n                '-map', '1:a:0',\n                '-shortest'\n            ])\n            .toFormat('mp4')\n            .on('end', () => {\n                const resultBuffer = fs.readFileSync(outputPath);\n                fs.unlinkSync(videoPath);\n                fs.unlinkSync(audioPath);\n                fs.unlinkSync(outputPath);\n                resolve(resultBuffer);\n            })\n            .on('error', (err) => {\n                try { fs.unlinkSync(videoPath); } catch (e) {}\n                try { fs.unlinkSync(audioPath); } catch (e) {}\n                try { fs.unlinkSync(outputPath); } catch (e) {}\n                reject(err);\n            })\n            .save(outputPath);\n    });\n};\n\nmodule.exports = {\n    toAudio,\n    toPTT,\n    toVideo,\n    toGif,\n    resizeImage,\n    compressImage,\n    convertImageFormat,\n    getMediaInfo,\n    base64ToBuffer,\n    bufferToBase64,\n    extractAudio,\n    addAudioToVideo\n};\n","path":null,"size_bytes":9884,"size_tokens":null},"source-1/lib/game.js":{"content":"require('../settings');\r\nconst fs = require('fs');\r\nconst jimp = require('jimp');\r\nconst chalk = require('chalk');\r\nconst { sleep, clockString } = require('./function')\r\n\r\nfunction pickRandom(list) {\r\n\treturn list[Math.floor(list.length * Math.random())]\r\n}\r\n\r\nconst rdGame = (bd, id, tm) => Object.keys(bd).find(a => a.startsWith(id) && a.endsWith(tm));\r\n\r\nconst iGame = (bd, id) => (a => a && bd[a].id)(Object.keys(bd).find(a => a.startsWith(id)));\r\n\r\nconst tGame = (bd, id) => (a => a && bd[a].time)(Object.keys(bd).find(a => a.startsWith(id)));\r\n\r\nconst gameSlot = async (conn, m, db) => {\r\n\tif (db.users[m.sender].limit < 1) return m.reply(global.mess.limit)\r\n\tconst sotoy = ['üçá','üçâ','üçã','üçå','üçé','üçë','üçí','ü´ê','ü••','ü•ë']\r\n\tconst slot1 = pickRandom(sotoy)\r\n\tconst slot2 = pickRandom(sotoy)\r\n\tconst slot3 = pickRandom(sotoy)\r\n\tconst listSlot1 = `${pickRandom(sotoy)} : ${pickRandom(sotoy)} : ${pickRandom(sotoy)}`\r\n\tconst listSlot2 = `${slot1} : ${slot2} : ${slot3}`\r\n\tconst listSlot3 = `${pickRandom(sotoy)} : ${pickRandom(sotoy)} : ${pickRandom(sotoy)}`\r\n\tconst randomLimit = Math.floor(Math.random() * 10)\r\n\tconst botNumber = await conn.decodeJid(conn.user.id)\r\n\ttry {\r\n\t\tif (slot1 === slot2 && slot2 === slot3) {\r\n\t\t\tdb.users[m.sender].limit -= 1\r\n\t\t\tdb.set[botNumber].limit += 1\r\n\t\t\tlet sloth =`[  üé∞VIRTUAL SLOT üé∞  ]\\n------------------------\\n\\n${listSlot1}\\n${listSlot2} <=====\\n${listSlot3}\\n\\n------------------------\\n[  üé∞ VIRTUAL SLOT üé∞  ]\\n\\n*Keterangan* :\\n_You Winüéâ_ <=====Limit + ${randomLimit}, Uang + ${randomLimit * 500}`\r\n\t\t\tconn.sendMessage(m.chat, { text: sloth }, { quoted: m })\r\n\t\t\tdb.users[m.sender].limit += randomLimit\r\n\t\t\tdb.users[m.sender].money += randomLimit * 500\r\n\t\t} else {\r\n\t\t\tdb.users[m.sender].limit -= 1\r\n\t\t\tdb.set[botNumber].limit += 1\r\n\t\t\tlet sloth =`[  üé∞VIRTUAL SLOT üé∞  ]\\n------------------------\\n\\n${listSlot1}\\n${listSlot2} <=====\\n${listSlot3}\\n\\n------------------------\\n[  üé∞ VIRTUAL SLOT üé∞  ]\\n\\n*Keterangan* :\\n_You Lose_ <=====\\nLimit - 1`\r\n\t\t\tconn.sendMessage(m.chat, { text: sloth }, { quoted: m })\r\n\t\t}\r\n\t} catch (e) {\r\n\t\tm.reply('Error!')\r\n\t}\r\n}\r\n\r\nconst gameCasinoSolo = async (conn, m, prefix, db) => {\r\n\ttry {\r\n\t\tlet buatall = 1\r\n\t\tif (db.users[m.sender].limit < 1) return m.reply(global.mess.limit)\r\n\t\tconst botNumber = await conn.decodeJid(conn.user.id)\r\n\t\tlet randomaku = `${Math.floor(Math.random() * 101)}`.trim()\r\n\t\tlet randomkamu = `${Math.floor(Math.random() * 81)}`.trim() //hehe Biar Susah Menang :v\r\n\t\tlet Aku = (randomaku * 1)\r\n\t\tlet Kamu = (randomkamu * 1)\r\n\t\tlet count = m.args[0]\r\n\t\tcount = count ? 'all' === count ? Math.floor(db.users[m.sender].money / buatall) : parseInt(count) : m.args[0] ? parseInt(m.args[0]) : 1\r\n\t\tcount = Math.max(1, count)\r\n\t\tif (m.args.length < 1) return m.reply(prefix + 'casino <jumlah>\\n' + prefix + 'casino 1000')\r\n\t\tif (isNaN(m.args[0])) return m.reply(`Masukkan jumlahnya!\\nContoh : ${prefix + m.command} 1000`)\r\n\t\tif (db.users[m.sender].money >= count * 1) {\r\n\t\t\tdb.users[m.sender].limit -= 1\r\n\t\t\tdb.users[m.sender].money -= count * 1\r\n\t\t\tdb.set[botNumber].money += count * 1\r\n\t\t\tif (Aku > Kamu) {\r\n\t\t\t\tm.reply(`üí∞ Casino üí∞\\n*Kamu:* ${Kamu} Point\\n*Computer:* ${Aku} Point\\n\\n*You LOSE*\\nKamu kehilangan ${count} Uang`.trim())\r\n\t\t\t} else if (Aku < Kamu) {\r\n\t\t\t\tdb.users[m.sender].money += count * 2\r\n\t\t\t\tm.reply(`üí∞ Casino üí∞\\n*Kamu:* ${Kamu} Point\\n*Computer:* ${Aku} Point\\n\\n*You Win*\\nKamu mendapatkan ${count * 2} Uang`.trim())\r\n\t\t\t} else {\r\n\t\t\t\tdb.users[m.sender].money += count * 1\r\n\t\t\t\tm.reply(`üí∞ Casino üí∞\\n*Kamu:* ${Kamu} Point\\n*Computer:* ${Aku} Point\\n\\n*SERI*\\nKamu mendapatkan ${count * 1} Uang`.trim())\r\n\t\t\t}\r\n\t\t} else m.reply(`Uang kamu tidak mencukupi untuk Casino silahkan *kumpulkan* terlebih dahulu!`)\r\n\t} catch (e) {\r\n\t\tm.reply('Error!')\r\n\t}\r\n}\r\n\r\nconst gameSamgongSolo = async (conn, m, db) => {\r\n\tconst suits = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è'];\r\n\tconst ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\r\n\tif (db.users[m.sender].limit < 1) return m.reply(global.mess.limit)\r\n\tconst count = parseInt(m.args[0]);\r\n\tif (isNaN(count) || count < 5000) return m.reply('Taruhan minimal adalah 5000!');\r\n\tif (db.users[m.sender].money < count) return m.reply(`Uang kamu tidak mencukupi untuk Samgong silahkan *kumpulkan* terlebih dahulu!`)\r\n\tdb.users[m.sender].money -= count;\r\n\tdb.users[m.sender].limit -= 1\r\n\tlet { key } = await m.reply('*üÉèPermainan dimulai!* Kartu sedang dibagikan...');\r\n\tawait sleep(5000);\r\n\tconst deck = ranks.flatMap(rank => suits.map(suit => `${rank} ${suit}`)).sort(() => Math.random() - 0.5);\r\n\tconst draw = () => [deck.pop(), deck.pop(), deck.pop()];\r\n\tconst calcScore = hand => hand.reduce((sum, card) => sum + (['J', 'Q', 'K'].includes(card.split(' ')[0]) ? 10 : card.split(' ')[0] === 'A' ? 15 : parseInt(card)), 0);\r\n\t\r\n\tlet playerHand = draw(), botHand = draw();\r\n\tlet playerScore = calcScore(playerHand), botScore = calcScore(botHand);\r\n\t\r\n\tawait m.reply(`*üÉèKartu Dibagikan:*\\nü§ì *Kamu:* ${playerHand.join(', ')}\\nü§ñ *Bot:* ${botHand.join(', ')}`, { edit: key });\r\n\tawait sleep(2000);\r\n\twhile (playerScore < 30 && botScore < 30 && playerHand.length < 4) {\r\n\t\tif (playerScore < 30) playerHand.push(deck.pop());\r\n\t\tif (botScore < 30) botHand.push(deck.pop());\r\n\t\tplayerScore = calcScore(playerHand);\r\n\t\tbotScore = calcScore(botHand);\r\n\t}\r\n\t\r\n\tlet winnings = count * 1.5;\r\n\tlet result = playerScore > 30 ? 'üíÄ Kamu kalah!' : playerScore === botScore ? 'ü§ù Hasil Seri! Taruhan dikembalikan' : botScore > 30 || playerScore > botScore ? `üéâ Kamu menang! +${winnings} üíµ` : 'üòû Bot menang!';\r\n\tif (playerScore <= 30 && (botScore > 30 || playerScore > botScore)) db.users[m.sender].money += (playerScore === botScore ? count : winnings);\r\n\tawait m.reply(`*üÉèHasil Akhir:*\\nü§ì *Kamu:* ${playerHand.join(', ')} (${playerScore})\\nü§ñ *Bot:* ${botHand.join(', ')} (${botScore})\\n\\n${result}`, { edit: key })\r\n}\r\n\r\nconst gameMerampok = async (m, db) => {\r\n\tif (db.users[m.sender].limit < 1) return m.reply(global.mess.limit)\r\n\tdb.users[m.sender].limit -= 1\r\n\tlet __timers = (new Date - db.users[m.sender].lastrampok)\r\n\tlet _timers = (3600000 - __timers)\r\n\tlet timers = clockString(_timers)\r\n\tif (new Date - db.users[m.sender].lastrampok > 3600000) {\r\n\t\tlet dapat = (Math.floor(Math.random() * 10000))\r\n\t\tlet who\r\n\t\tif (m.isGroup) who = m.mentionedJid ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : m.mentionedJid[0]\r\n\t\telse who = m.chat\r\n\t\tif (!who) return m.reply('Tag salah satu')\r\n\t\tif (!db.users[who]) return m.reply('Target tidak terdaftar di database!')\r\n\t\tif (10000 > db.users[who].money) return m.reply('Targetnya Kismin ngabüóø')\r\n\t\tdb.users[who].money -= dapat\r\n\t\tdb.users[m.sender].money += dapat\r\n\t\tdb.users[m.sender].lastrampok = new Date * 1\r\n\t\tm.reply(`Berhasil Merampok Money Target Sebesar ${dapat}`)\r\n\t} else m.reply(`Anda Sudah merampok dan berhasil sembunyi, tunggu ${timers} untuk merampok lagi`)\r\n}\r\n\r\nconst gameBegal = async (conn, m, db) => {\r\n\tif (db.users[m.sender].limit < 1) return m.reply(global.mess.limit)\r\n\tdb.users[m.sender].limit -= 1\r\n\tlet user = db.users[m.sender]\r\n\tlet __timers = (new Date - user.lastbegal)\r\n\tlet _timers = (3600000 - __timers)\r\n\tlet timers = clockString(_timers)\r\n\tconst botNumber = await conn.decodeJid(conn.user.id)\r\n\tconst randomUang = Math.floor(Math.random() * 10001)\r\n\tlet random = [{teks: 'Pemain Berhasil Kabur!', no: 0},{teks: 'Pemain Melarikan Diri!', no: 0},{teks: 'Pemain Bersembunyi', no: 0},{teks: 'Pemain Bunuh Diri', no: 2},{teks: 'Pemain Berhasil Tertangkap', no: 2},{teks: 'Pemain Tidak Di Temukan!', no: 0},{teks: 'Pemain Lebih Kuat Dari Kamu!', no: 1},{teks: 'Pemain Menggunakan Cheat', no: 1},{teks: 'Pemain Lapor Polisi', no: 0},{teks: 'Pemain Tertangkap!', no: 2},{teks: 'Pemain Menyerahkan Diri', no: 2}]\r\n\tlet teksnya = await pickRandom(random);\r\n\tif (new Date - user.lastbegal > 3600000) {\r\n\t\tlet { key } = await m.reply('Sedang Mencari Pemain...')\r\n\t\tawait sleep(2000)\r\n\t\tif (teksnya.no === 0) {\r\n\t\t\tawait m.reply({ text: teksnya.teks, edit: key })\r\n\t\t\tawait m.reply('Gagal Mencari Pemain, Silahkan Coba lagi')\r\n\t\t} else if (teksnya.no === 1) {\r\n\t\t\tawait m.reply({ text: teksnya.teks, edit: key })\r\n\t\t\tawait m.reply(`Kamu Di Bunuh Oleh Pemain\\nUang Kamu Di Rampas Sebesar *${randomUang}*`)\r\n\t\t\tdb.users[m.sender].money -= randomUang\r\n\t\t\tdb.set[botNumber].money += randomUang * 1\r\n\t\t} else {\r\n\t\t\tawait m.reply({ text: teksnya.teks, edit: key })\r\n\t\t\tawait m.reply(`Berhasil Mendapatkan Uang Sebesar : *${randomUang}*`)\r\n\t\t\tdb.users[m.sender].money += randomUang\r\n\t\t\tdb.users[m.sender].lastbegal = new Date * 1\r\n\t\t}\r\n\t} else m.reply(`Silahkan tunggu *‚è±Ô∏è${timers}* lagi untuk bisa bermain lagi`)\r\n}\r\n\r\nconst daily = async (m, db) => {\r\n\tlet user = db.users[m.sender]\r\n\tlet __timers = (new Date - user.lastclaim)\r\n\tlet _timers = (86400000 - __timers)\r\n\tlet timers = clockString(_timers)\r\n\tif (new Date - user.lastclaim > 86400000) {\r\n\t\tm.reply(`*Daily Claim*\\n_Berhasil Claim_\\n- limit : 10\\n- uang : 10000\\n\\n_Claim Di Reset_`)\r\n\t\tdb.users[m.sender].limit += 10\r\n\t\tdb.users[m.sender].money += 10000\r\n\t\tdb.users[m.sender].lastclaim = new Date * 1\r\n\t} else m.reply(`Silahkan tunggu *‚è±Ô∏è${timers}* lagi untuk bisa mengclaim lagi`)\r\n}\r\n\r\nconst buy = async (m, args, db) => {\r\n\tif (args[0] === 'limit') {\r\n\t\tif (!args[1]) return m.reply(`Masukkan Nominalnya!\\nExample : ${m.prefix + m.command} limit 10`);\r\n\t\tlet count = parseInt(args[1])\r\n\t\tif (db.users[m.sender].money >= count * 500) {\r\n\t\t\tdb.users[m.sender].limit += count * 1\r\n\t\t\tdb.users[m.sender].money -= count * 500\r\n\t\t\tm.reply(`Berhasil Membeli Limit Sebanyak ${args[1] * 1} dengan harga ${args[1] * 500}`);\r\n\t\t} else m.reply(`Uang Kamu Tidak Cukup Untuk Membeli limit!\\nUangmu Tersisa : ${db.users[m.sender].money}\\nHarga ${args[1]} Limit : ${args[1] * 500}`);\r\n\t} else m.reply(`Harga Limit : Jumlah x 500\\n‚Ä¢ 1 limit = 500\\n‚Ä¢ 2 limit = 1000\\n\\nExample : .buy limit 3`);\r\n}\r\n\r\nconst setLimit = (m, db) => db.users[m.sender].limit -= 1\r\n\r\nconst addLimit = (jumlah, no, db) => db.users[no].limit += parseInt(jumlah)\r\n\r\nconst setMoney = (m, db) => db.users[m.sender].money -= 1000\r\n\r\nconst addMoney = (jumlah, no, db) => db.users[no].money += parseInt(jumlah)\r\n\r\nconst transfer = async (m, args, db) => {\r\n\tif (args[0] == 'limit') {\r\n\t\tif (!args[1].length > 7) return m.reply(`Transfer Menu :\\nExample : ${m.prefix + m.command} limit @tag 11\\n‚Ä¢ ${m.prefix + m.command} limit @tag jumlah\\n‚Ä¢ ${m.prefix + m.command} uang @tag jumlah`);\r\n\t\tlet count = parseInt(args[2] && args[2].length > 0 ? Math.min(9999999, Math.max(parseInt(args[2]), 1)) : Math.min(1))\r\n\t\tlet who = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : args[1] ? (args[1].replace(/[^0-9]/g, '') + '@s.whatsapp.net') : false\r\n\t\tif (!who) return m.reply('Siapa yg mau di transfer?')\r\n\t\tif (db.users[who]) {\r\n\t\t\tif (db.users[m.sender].limit >= count * 1) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdb.users[m.sender].limit -= count * 1\r\n\t\t\t\t\tdb.users[who].limit += count * 1\r\n\t\t\t\t\tm.reply(`Berhasil mentransfer limit sebesar ${count}, kepada @${who.split('@')[0]}`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tdb.users[m.sender].limit += count * 1\r\n\t\t\t\t\tm.reply('Gagal Transfer')\r\n\t\t\t\t}\r\n\t\t\t} else m.reply(`Limit tidak mencukupi!!\\nLimit mu tersisa : *${db.users[m.sender].limit}*`)\r\n\t\t} else m.reply(`Nomer ${who.split('@')[0]} Bukan User bot!`)\r\n\t} else if (args[0] == 'uang') {\r\n\t\tif (!args[1].length > 7) return m.reply(`Transfer Menu :\\nExample : ${m.prefix + m.command} limit @tag 11\\n‚Ä¢ ${m.prefix + m.command} limit @tag jumlah\\n‚Ä¢ ${m.prefix + m.command} uang @tag jumlah`);\r\n\t\tlet count = parseInt(args[2] && args[2].length > 0 ? Math.min(9999999, Math.max(parseInt(args[2]), 1)) : Math.min(1))\r\n\t\tlet who = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : args[1] ? (args[1].replace(/[^0-9]/g, '') + '@s.whatsapp.net') : false\r\n\t\tif (!who) return m.reply('Siapa yg mau di transfer?')\r\n\t\tif (db.users[who]) {\r\n\t\t\tif (db.users[m.sender].money >= count * 1) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdb.users[m.sender].money -= count * 1\r\n\t\t\t\t\tdb.users[who].money += count * 1\r\n\t\t\t\t\tm.reply(`Berhasil mentransfer uang sebesar ${count}, kepada @${who.split('@')[0]}`)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tdb.users[m.sender].money += count * 1\r\n\t\t\t\t\tm.reply('Gagal Transfer')\r\n\t\t\t\t}\r\n\t\t\t} else m.reply(`Uang tidak mencukupi!!\\Uang mu tersisa : *${db.users[m.sender].money}*`)\r\n\t\t} else m.reply(`Nomer ${who.split('@')[0]} Bukan User bot!`)\r\n\t} else m.reply(`Transfer Menu :\\nExample : ${m.prefix + m.command} limit @tag 11\\n‚Ä¢ ${m.prefix + m.command} limit @tag jumlah\\n‚Ä¢ ${m.prefix + m.command} uang @tag jumlah`);\r\n}\r\n\r\n/*\r\n\t* Create By Naze\r\n\t* Follow https://github.com/nazedev\r\n\t* Whatsapp : https://whatsapp.com/channel/0029VaWOkNm7DAWtkvkJBK43\r\n*/\r\n\r\nclass Blackjack {\r\n\tconstructor(data) {\r\n\t\tthis.id = data.id || '';\r\n\t\tthis.skip = data.skip || [];\r\n\t\tthis.host = data.host || '';\r\n\t\tthis.leader = data.leader || '';\r\n\t\tthis.winner = data.winner || [];\r\n\t\tthis.players = data.players || [];\r\n\t\tthis.started = data.started || false;\r\n\t\tthis.startCard = data.startCard || {};\r\n\t\tthis.submitCard = data.submitCard || [];\r\n\t\tthis.secondDeck = data.secondDeck || [];\r\n\t\tthis.deck = data.deck || this.generateDeck();\r\n\t}\r\n\t\r\n\tgenerateDeck() {\r\n\t\tlet deck = [];\r\n\t\tconst suits = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è'];\r\n\t\tconst ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];\r\n\t\tfor (let suit of suits) {\r\n\t\t\tfor (let rank of ranks) {\r\n\t\t\t\tdeck.push({ rank: rank, suit: suit });\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn deck;\r\n\t}\r\n\t\r\n\tshuffleDeck() {\r\n\t\tfor (let i = this.deck.length - 1; i > 0; i--) {\r\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\r\n\t\t\t[this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];\r\n\t\t}\r\n\t}\r\n\t\r\n\tdistributeCards() {\r\n\t\tthis.shuffleDeck();\r\n\t\tfor (let player of this.players) {\r\n\t\t\tplayer.cards.push(...this.deck.splice(0, { 2: 10, 3: 7, 4: 7, 5: 6, 6: 6, 7: 5, 8: 5, 9: 4, 10: 4 }[this.players.length]));\r\n\t\t}\r\n\t\tthis.startCard = this.deck.shift();\r\n\t\tthis.secondDeck.push(this.startCard);\r\n\t\tthis.started = true;\r\n\t}\r\n\t\r\n\thasMatching(player) {\r\n\t\treturn this.players.find(p => p.id === player)?.cards?.some(card => card?.suit === this.startCard.suit) || false;\r\n\t}\r\n\t\r\n\tresolveRound() {\r\n\t\tconst rankToValue = (rank) => rank === 'A' ? 14 : rank === 'K' ? 13 :  rank === 'Q' ? 12 : rank === 'J' ? 11 : parseInt(rank) || 0;\r\n\t\tlet highestCard = this.submitCard[0];\r\n\t\tlet leaderId = highestCard.id;\r\n\t\tfor (let c of this.submitCard) {\r\n\t\t\tif (rankToValue(c.card.rank) > rankToValue(highestCard.card.rank)) {\r\n\t\t\t\thighestCard = c;\r\n\t\t\t\tleaderId = c.id;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (leaderId) {\r\n\t\t\tthis.leader = leaderId;\r\n\t\t\tthis.startCard = {};\r\n\t\t\tthis.submitCard = [];\r\n\t\t\treturn `@${leaderId.split('@')[0]} memimpin ronde berikutnya!`\r\n\t\t}\r\n\t}\r\n\t\r\n\treuseSubmitCardsForDrinking() {\r\n\t\tconst drinkers = this.players.filter(p => !this.hasMatching(p.id) && !this.skip.includes(p.id));\r\n\t\tconst cards = this.submitCard.map(s => s.card);\r\n\t\tif ((this.submitCard.length + this.skip.length) === this.players.length && cards.length === 1) {\r\n\t\t\tconst owner = this.submitCard[0].id;\r\n\t\t\tthis.leader = owner;\r\n\t\t\tfor (const player of this.players) {\r\n\t\t\t\tif (player.id !== owner) this.skip.push(player.id);\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmsg: `Hanya @${owner.split('@')[0]} yang punya kartu, dia jadi pemimpin baru. Sesi lanjut.`,\r\n\t\t\t\tcontinue: true\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet index = 0;\r\n\t\t\tfor (const card of cards) {\r\n\t\t\t\tif (!drinkers.length) break;\r\n\t\t\t\tconst player = this.players.find(p => p.id === drinkers[index % drinkers.length].id);\r\n\t\t\t\tplayer.cards.push(card);\r\n\t\t\t\tif (!this.skip.find(a => a.id === player.id)) this.skip.push({ id: player.id });\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmsg: `Kartu dari submitCard dibagi ke pemain yang harus minum.`,\r\n\t\t\t\tcontinue: true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass SnakeLadder {\r\n\tconstructor(data) {\r\n\t\tthis.turn = data.turn || 0;\r\n\t\tthis.host = data.host || null;\r\n\t\tthis.start = data.start || false;\r\n\t\tthis.players = data.players || [];\r\n\t\tthis.map = data.map || this.createMap();\r\n\t}\r\n\t\r\n\trollDice() {\r\n\t\treturn Math.floor(Math.random() * 6) + 1;\r\n\t}\r\n\t\r\n\tcreateMap () {\r\n\t\tconst data = [{\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map1.jpg',\r\n\t\t\tmove: { 4: 56, 12: 50, 14: 55, 22: 58, 41: 79, 54: 88, 96: 42, 94: 71, 75: 32, 48: 16, 37: 3, 28: 10 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map2.jpg',\r\n\t\t\tmove: { 7: 36, 21: 58, 31: 51, 34: 84, 54: 89, 63: 82, 96: 72, 78: 59, 66: 12, 56: 20, 43: 24, 33: 5 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map3.jpg',\r\n\t\t\tmove: { 8: 29, 10: 32, 20: 39, 27: 85, 51: 67, 72: 91, 79: 100, 98: 65, 94: 75, 93: 73, 64: 60, 62: 19, 56: 24, 53: 50, 17: 7 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map4.jpg',\r\n\t\t\tmove: { 8: 29, 10: 32, 20: 39, 27: 85, 51: 67, 72: 91, 79: 100, 98: 65, 94: 75, 93: 73, 64: 60, 62: 19, 56: 24, 53: 50, 17: 7 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map5.jpg',\r\n\t\t\tmove: { 1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 51: 67, 72: 91, 80: 99, 98: 79, 94: 75, 93: 73, 87: 36, 64: 60, 62: 19, 54: 34, 17: 7 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map6.jpg',\r\n\t\t\tmove: { 4: 23, 13: 46, 33: 52, 42: 63, 50: 69, 62: 81, 74: 93, 99: 41, 95: 76, 89: 53, 66: 45, 54: 31, 43: 17, 40: 2, 27: 5 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map7.jpg',\r\n\t\t\tmove: { 1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 51: 67, 71: 91, 80: 100, 98: 79, 95: 75, 93: 73, 87: 24, 64: 60, 62: 19, 54: 34, 17: 7 },\r\n\t\t\tmode: ''\r\n\t\t}, {\r\n\t\t\turl: 'https://raw.githubusercontent.com/nazedev/database/master/games/images/map/map8.jpg',\r\n\t\t\tmove: { 2: 38, 7: 14, 8: 31, 15: 26, 21: 42, 28: 84, 36: 44, 51: 67, 71: 91, 78: 98, 87: 94, 99: 80, 95: 75, 92: 88, 89: 68, 74: 53, 64: 60, 62: 19, 49: 11, 46: 25, 16: 6 },\r\n\t\t\tmode: ''\r\n\t\t}];\r\n\t\treturn data[Math.floor(Math.random() * data.length)];\r\n\t}\r\n\t\r\n\tnextTurn() {\r\n\t\tthis.turn = (this.turn + 1) % this.players.length;\r\n\t}\r\n\t\r\n\tasync drawBoard(boardUrl, players = []) {\r\n\t\ttry {\r\n\t\t\tconst board = await jimp.read(boardUrl);\r\n\t\t\tboard.resize(612, 612);\r\n\t\t\tconst width = board.getWidth();\r\n\t\t\tconst height = board.getHeight();\r\n\t\t\tconst size = Math.min(width, height);\r\n\t\t\tboard.crop((width - size) / 2, (height - size) / 2, size, size);\r\n\t\t\tconst tileSize = size / 10;\r\n\t\t\tplayers.filter(a => a.move !== null);\r\n\t\t\tfor (let i = 0; i < players.length; i++) {\r\n\t\t\t\tconst position = players[i].move;\r\n\t\t\t\tconst row = Math.floor((position - 1) / 10);\r\n\t\t\t\tconst col = (row % 2 === 0) ? (position - 1) % 10 : 9 - (position - 1) % 10;\r\n\t\t\t\tconst x = col * tileSize;\r\n\t\t\t\tconst y = (9 - row) * tileSize;\r\n\t\t\t\tconst player = await jimp.read(`https://raw.githubusercontent.com/nazedev/database/master/games/images/player${i + 1}.png`);\r\n\t\t\t\tconst pionSize = tileSize * 0.7;\r\n\t\t\t\tplayer.resize(pionSize, pionSize);\r\n\t\t\t\tboard.composite(player, x + tileSize / 2 - pionSize / 2, y + tileSize / 2 - pionSize / 2, {\r\n\t\t\t\t\tmode: jimp.BLEND_SOURCE_OVER\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tconst result = await board.getBufferAsync(jimp.MIME_JPEG);\r\n\t\t\treturn result;\r\n\t\t} catch (e) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = { rdGame, iGame, tGame, gameSlot, gameCasinoSolo, gameSamgongSolo, gameMerampok, gameBegal, daily, buy, setLimit, addLimit, addMoney, setMoney, transfer, Blackjack, SnakeLadder }\r\n\r\nlet file = require.resolve(__filename)\r\nfs.watchFile(file, () => {\r\n\tfs.unwatchFile(file)\r\n\tconsole.log(chalk.redBright(`Update ${__filename}`))\r\n\tdelete require.cache[file]\r\n\trequire(file)\r\n});","path":null,"size_bytes":19913,"size_tokens":null},"source-2/lib/utils/logger.js":{"content":"const chalk = require('chalk');\nconst moment = require('moment-timezone');\nconst { timezone } = require('../../config');\n\nconst time = () => moment.tz(timezone).format('HH:mm:ss');\n\nconst styles = {\n    incoming: chalk.hex('#FFA500').bold,\n    outgoing: chalk.hex('#00FF00').bold,\n    error: chalk.hex('#FF0000').bold,\n    info: chalk.hex('#ADD8E6').bold,\n    success: chalk.hex('#32CD32').bold,\n    time: chalk.hex('#FFFFFF').dim\n};\n\nconst logger = {\n    info: (message) => console.log(styles.info(`[${time()}] ${message}`)),\n    error: (message) => console.error(styles.error(`[${time()}] ${message}`)),\n    success: (message) => console.log(styles.success(`[${time()}] ${message}`)),\n    incoming: (message) => console.log(styles.incoming(`[${time()}] ${message}`)),\n    outgoing: (message) => console.log(styles.outgoing(`[${time()}] ${message}`))\n};\n\nmodule.exports = {\n    logger,\n    time,\n    styles\n};","path":null,"size_bytes":910,"size_tokens":null},"ciel/src/handlers/commands/download.js":{"content":"const axios = require('axios');\nconst settings = require('../../../config/settings');\nconst { tmate } = require('../../../lib/tmate');\nconst SavetikAPI = require('../../../lib/tikSnap');\n\nconst tiktok = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link TikTok!\\nContoh: .tiktok https://vt.tiktok.com/xxx');\n    \n    if (!text.includes('tiktok.com')) {\n        return m.reply('Link tidak valid! Harus link TikTok.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.post('https://www.tikwm.com/api/', {\n            url: text,\n            hd: 1\n        });\n        \n        if (!response.data.data) {\n            throw new Error('API utama gagal');\n        }\n        \n        const data = response.data.data;\n        const videoUrl = data.hdplay || data.play;\n        \n        const videoBuffer = await axios.get(videoUrl, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, {\n            video: Buffer.from(videoBuffer.data),\n            caption: `*üì± TikTok Download*\\n\\n*Author:* ${data.author?.nickname || 'Unknown'}\\n*Likes:* ${data.digg_count || 0}\\n*Views:* ${data.play_count || 0}`\n        }, { quoted: m });\n        \n    } catch (e) {\n        console.log('TikTok API utama gagal, mencoba fallback...');\n        try {\n            const result = await tmate.download(text);\n            if (!result || !result.downloadLinks?.length) {\n                throw new Error('Tmate gagal');\n            }\n            \n            const videoLink = result.downloadLinks.find(l => \n                l.linkText?.includes('Without Watermark') || l.linkText?.includes('HD')\n            ) || result.downloadLinks[0];\n            \n            if (!videoLink?.link) throw new Error('Tidak ada link download');\n            \n            const videoBuffer = await axios.get(videoLink.link, { responseType: 'arraybuffer' });\n            \n            await conn.sendMessage(m.chat, {\n                video: Buffer.from(videoBuffer.data),\n                caption: `*üì± TikTok Download*\\n\\n*Title:* ${result.title || 'Unknown'}\\n*Username:* ${result.username || 'Unknown'}`\n            }, { quoted: m });\n        } catch (e2) {\n            console.error('TikTok fallback error:', e2);\n            m.reply('Gagal download video TikTok! Coba lagi nanti.');\n        }\n    }\n};\n\nconst tt = tiktok;\nconst tiktokdl = tiktok;\n\nconst tiktokaudio = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link TikTok!\\nContoh: .tiktokaudio https://vt.tiktok.com/xxx');\n    \n    if (!text.includes('tiktok.com')) {\n        return m.reply('Link tidak valid! Harus link TikTok.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.post('https://www.tikwm.com/api/', {\n            url: text\n        });\n        \n        if (!response.data.data) {\n            return m.reply('Audio tidak ditemukan!');\n        }\n        \n        const data = response.data.data;\n        const audioUrl = data.music;\n        \n        const audioBuffer = await axios.get(audioUrl, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, {\n            audio: Buffer.from(audioBuffer.data),\n            mimetype: 'audio/mpeg'\n        }, { quoted: m });\n        \n    } catch (e) {\n        console.error('TikTok audio error:', e);\n        m.reply('Gagal download audio TikTok! Coba lagi nanti.');\n    }\n};\n\nconst ttmp3 = tiktokaudio;\nconst ttaudio = tiktokaudio;\n\nconst instagram = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link Instagram!\\nContoh: .instagram https://www.instagram.com/reel/xxx');\n    \n    if (!text.includes('instagram.com')) {\n        return m.reply('Link tidak valid! Harus link Instagram.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://api.agatz.xyz/api/instagram?url=${encodeURIComponent(text)}`);\n        \n        if (!response.data.data || !response.data.data.length) {\n            return m.reply('Media tidak ditemukan! Pastikan akun tidak private.');\n        }\n        \n        const media = response.data.data[0];\n        \n        if (media.type === 'video') {\n            const videoBuffer = await axios.get(media.url, { responseType: 'arraybuffer' });\n            await conn.sendMessage(m.chat, {\n                video: Buffer.from(videoBuffer.data),\n                caption: '*üì∏ Instagram Download*'\n            }, { quoted: m });\n        } else {\n            const imageBuffer = await axios.get(media.url, { responseType: 'arraybuffer' });\n            await conn.sendMessage(m.chat, {\n                image: Buffer.from(imageBuffer.data),\n                caption: '*üì∏ Instagram Download*'\n            }, { quoted: m });\n        }\n        \n    } catch (e) {\n        console.error('Instagram error:', e);\n        m.reply('Gagal download media Instagram! Pastikan link valid dan akun tidak private.');\n    }\n};\n\nconst ig = instagram;\nconst igdl = instagram;\n\nconst facebook = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link Facebook!\\nContoh: .facebook https://www.facebook.com/watch?v=xxx');\n    \n    if (!text.includes('facebook.com') && !text.includes('fb.watch')) {\n        return m.reply('Link tidak valid! Harus link Facebook.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://api.agatz.xyz/api/facebook?url=${encodeURIComponent(text)}`);\n        \n        if (!response.data.data) {\n            return m.reply('Video tidak ditemukan!');\n        }\n        \n        const videoUrl = response.data.data.hd || response.data.data.sd;\n        const videoBuffer = await axios.get(videoUrl, { responseType: 'arraybuffer' });\n        \n        await conn.sendMessage(m.chat, {\n            video: Buffer.from(videoBuffer.data),\n            caption: '*üìò Facebook Download*'\n        }, { quoted: m });\n        \n    } catch (e) {\n        console.error('Facebook error:', e);\n        m.reply('Gagal download video Facebook! Coba lagi nanti.');\n    }\n};\n\nconst fb = facebook;\nconst fbdl = facebook;\n\nconst twitter = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link Twitter/X!\\nContoh: .twitter https://twitter.com/xxx/status/xxx');\n    \n    if (!text.includes('twitter.com') && !text.includes('x.com')) {\n        return m.reply('Link tidak valid! Harus link Twitter/X.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://api.agatz.xyz/api/twitter?url=${encodeURIComponent(text)}`);\n        \n        if (!response.data.data) {\n            return m.reply('Media tidak ditemukan!');\n        }\n        \n        const media = response.data.data[0];\n        \n        if (media.type === 'video') {\n            const videoBuffer = await axios.get(media.url, { responseType: 'arraybuffer' });\n            await conn.sendMessage(m.chat, {\n                video: Buffer.from(videoBuffer.data),\n                caption: '*üê¶ Twitter Download*'\n            }, { quoted: m });\n        } else {\n            const imageBuffer = await axios.get(media.url, { responseType: 'arraybuffer' });\n            await conn.sendMessage(m.chat, {\n                image: Buffer.from(imageBuffer.data),\n                caption: '*üê¶ Twitter Download*'\n            }, { quoted: m });\n        }\n        \n    } catch (e) {\n        console.error('Twitter error:', e);\n        m.reply('Gagal download media Twitter! Coba lagi nanti.');\n    }\n};\n\nconst tw = twitter;\nconst x = twitter;\n\nconst youtube = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link atau judul YouTube!\\nContoh: .youtube https://youtu.be/xxx');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        let videoId = null;\n        \n        if (text.includes('youtube.com') || text.includes('youtu.be')) {\n            const match = text.match(/(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^\"&?\\/\\s]{11})/);\n            if (match) videoId = match[1];\n        }\n        \n        if (!videoId) {\n            const searchResponse = await axios.get(`https://www.googleapis.com/youtube/v3/search`, {\n                params: {\n                    part: 'snippet',\n                    q: text,\n                    type: 'video',\n                    maxResults: 1,\n                    key: settings.apis.youtube || process.env.YOUTUBE_API_KEY\n                }\n            });\n            \n            if (searchResponse.data.items && searchResponse.data.items.length > 0) {\n                videoId = searchResponse.data.items[0].id.videoId;\n            }\n        }\n        \n        if (!videoId) {\n            return m.reply('Video tidak ditemukan!');\n        }\n        \n        m.reply(`*üé¨ YouTube*\\n\\nVideo ID: ${videoId}\\n\\nFitur YouTube membutuhkan API tambahan. Silakan hubungi owner untuk mengaktifkan downloader YouTube.`);\n        \n    } catch (e) {\n        console.error('YouTube error:', e);\n        m.reply('Gagal memproses video YouTube! Coba lagi nanti.');\n    }\n};\n\nconst yt = youtube;\nconst ytdl = youtube;\n\nconst play = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan judul lagu!\\nContoh: .play dewa 19 kangen');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        m.reply(`*üéµ Play*\\n\\nMencari: ${text}\\n\\nFitur play music membutuhkan API tambahan. Silakan hubungi owner untuk mengaktifkan fitur ini.`);\n        \n    } catch (e) {\n        console.error('Play error:', e);\n        m.reply('Gagal menemukan lagu! Coba lagi nanti.');\n    }\n};\n\nconst spotify = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link Spotify atau judul lagu!\\nContoh: .spotify lagu favorit');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        m.reply(`*üéß Spotify*\\n\\nMencari: ${text}\\n\\nFitur Spotify membutuhkan API tambahan. Silakan hubungi owner untuk mengaktifkan fitur ini.`);\n        \n    } catch (e) {\n        console.error('Spotify error:', e);\n        m.reply('Gagal memproses lagu! Coba lagi nanti.');\n    }\n};\n\nconst pinterest = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan keyword pencarian!\\nContoh: .pinterest anime wallpaper');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://api.agatz.xyz/api/pinterest?q=${encodeURIComponent(text)}`);\n        \n        if (!response.data.data || !response.data.data.length) {\n            return m.reply('Gambar tidak ditemukan!');\n        }\n        \n        const images = response.data.data.slice(0, 5);\n        \n        for (const img of images) {\n            const imageBuffer = await axios.get(img, { responseType: 'arraybuffer' });\n            await conn.sendMessage(m.chat, {\n                image: Buffer.from(imageBuffer.data)\n            }, { quoted: m });\n        }\n        \n    } catch (e) {\n        console.error('Pinterest error:', e);\n        m.reply('Gagal mencari gambar! Coba lagi nanti.');\n    }\n};\n\nconst pin = pinterest;\n\nconst mediafire = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link MediaFire!\\nContoh: .mediafire https://www.mediafire.com/file/xxx');\n    \n    if (!text.includes('mediafire.com')) {\n        return m.reply('Link tidak valid! Harus link MediaFire.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const response = await axios.get(`https://api.agatz.xyz/api/mediafire?url=${encodeURIComponent(text)}`);\n        \n        if (!response.data.data) {\n            return m.reply('File tidak ditemukan!');\n        }\n        \n        const data = response.data.data;\n        \n        const fileInfo = `*üìÅ MediaFire*\n\n*Nama:* ${data.filename || 'Unknown'}\n*Size:* ${data.size || 'Unknown'}\n*Tipe:* ${data.mimetype || 'Unknown'}\n\n*Link Download:* ${data.link}`;\n        \n        m.reply(fileInfo);\n        \n    } catch (e) {\n        console.error('MediaFire error:', e);\n        m.reply('Gagal mendapatkan link download! Coba lagi nanti.');\n    }\n};\n\nconst mf = mediafire;\n\nconst douyin = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link Douyin!\\nContoh: .douyin https://v.douyin.com/xxx');\n    \n    if (!text.includes('douyin.com')) {\n        return m.reply('Link tidak valid! Harus link Douyin.');\n    }\n    \n    const urlPattern = /^https?:\\/\\/(www\\.)?(v\\.)?douyin\\.com\\/.+$/i;\n    if (!urlPattern.test(text.trim())) {\n        return m.reply('Link tidak valid! Harus link Douyin yang benar.');\n    }\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const savetik = new SavetikAPI();\n        const result = await savetik.download({ url: text });\n        \n        if (!result || result.status !== 'ok' || !result.downloadLinks?.length) {\n            throw new Error('SavetikAPI gagal');\n        }\n        \n        const videoLink = result.downloadLinks.find(l => \n            l.text?.includes('Without Watermark') || l.text?.includes('HD')\n        ) || result.downloadLinks[0];\n        \n        if (!videoLink?.link) throw new Error('Tidak ada link download');\n        \n        const downloadUrl = videoLink.link;\n        if (!downloadUrl.startsWith('http')) {\n            throw new Error('URL download tidak valid');\n        }\n        \n        const videoBuffer = await axios.get(downloadUrl, { \n            responseType: 'arraybuffer',\n            timeout: 60000\n        });\n        \n        const contentType = videoBuffer.headers?.['content-type'] || '';\n        if (!contentType.includes('video') && !contentType.includes('octet-stream')) {\n            throw new Error('Response bukan video');\n        }\n        \n        await conn.sendMessage(m.chat, {\n            video: Buffer.from(videoBuffer.data),\n            caption: `*üì± Douyin Download*\\n\\n*Title:* ${result.videoTitle || 'Unknown'}`\n        }, { quoted: m });\n        \n    } catch (e) {\n        console.error('Douyin error:', e);\n        m.reply('Gagal download video Douyin! Coba lagi nanti.');\n    }\n};\n\nconst dy = douyin;\n\nconst pixiv = async (conn, m, { text }) => {\n    if (!text) return m.reply('Masukkan link Pixiv atau keyword pencarian!\\nContoh: .pixiv https://www.pixiv.net/en/artworks/123456\\nAtau: .pixiv anime girl');\n    \n    await m.reply(settings.messages.wait);\n    \n    try {\n        const { pixivdl } = require('../../../lib/pixiv');\n        const result = await pixivdl(text);\n        \n        if (!result || !result.media || !result.media.length) {\n            return m.reply('Gambar tidak ditemukan!');\n        }\n        \n        const caption = `*üé® Pixiv Download*\n\n*Artist:* ${result.artist}\n*Title:* ${result.caption}\n*Tags:* ${result.tags?.slice(0, 5).join(', ') || '-'}`;\n        \n        const images = result.media.slice(0, 5);\n        let isFirst = true;\n        \n        for (const img of images) {\n            try {\n                const imgUrl = typeof img === 'string' ? img : img.original || img.url;\n                if (!imgUrl) continue;\n                \n                const imageBuffer = await axios.get(imgUrl, { \n                    responseType: 'arraybuffer',\n                    timeout: 30000,\n                    headers: {\n                        'Referer': 'https://www.pixiv.net/',\n                        'User-Agent': 'Mozilla/5.0'\n                    }\n                });\n                \n                await conn.sendMessage(m.chat, {\n                    image: Buffer.from(imageBuffer.data),\n                    caption: isFirst ? caption : ''\n                }, { quoted: m });\n                \n                isFirst = false;\n            } catch (imgErr) {\n                console.error('Pixiv image download error:', imgErr.message);\n            }\n        }\n        \n    } catch (e) {\n        console.error('Pixiv error:', e);\n        m.reply(`Gagal download dari Pixiv! ${e.message || 'Coba lagi nanti.'}`);\n    }\n};\n\nconst pxv = pixiv;\n\nmodule.exports = {\n    tiktok,\n    tt,\n    tiktokdl,\n    tiktokaudio,\n    ttmp3,\n    ttaudio,\n    instagram,\n    ig,\n    igdl,\n    facebook,\n    fb,\n    fbdl,\n    twitter,\n    tw,\n    x,\n    youtube,\n    yt,\n    ytdl,\n    play,\n    spotify,\n    pinterest,\n    pin,\n    mediafire,\n    mf,\n    douyin,\n    dy,\n    pixiv,\n    pxv\n};\n","path":null,"size_bytes":16356,"size_tokens":null},"ciel/src/utils/functions.js":{"content":"const fs = require('fs-extra');\nconst path = require('path');\nconst axios = require('axios');\nconst https = require('https');\nconst crypto = require('crypto');\nconst FileType = require('file-type');\nconst moment = require('moment-timezone');\n\nconst sizeFormatter = (options = {}) => {\n    const units = options.std === 'IEC' ? ['B', 'KiB', 'MiB', 'GiB', 'TiB'] : ['B', 'KB', 'MB', 'GB', 'TB'];\n    return (bytes) => {\n        if (bytes === 0) return '0 B';\n        const i = Math.floor(Math.log(bytes) / Math.log(1024));\n        return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + units[i];\n    };\n};\n\nconst unsafeAgent = new https.Agent({ rejectUnauthorized: false });\n\nconst runtime = (seconds) => {\n    seconds = Number(seconds);\n    const d = Math.floor(seconds / (3600 * 24));\n    const h = Math.floor(seconds % (3600 * 24) / 3600);\n    const m = Math.floor(seconds % 3600 / 60);\n    const s = Math.floor(seconds % 60);\n    const dDisplay = d > 0 ? d + (d == 1 ? \" hari, \" : \" hari, \") : \"\";\n    const hDisplay = h > 0 ? h + (h == 1 ? \" jam, \" : \" jam, \") : \"\";\n    const mDisplay = m > 0 ? m + (m == 1 ? \" menit, \" : \" menit, \") : \"\";\n    const sDisplay = s > 0 ? s + (s == 1 ? \" detik\" : \" detik\") : \"\";\n    return dDisplay + hDisplay + mDisplay + sDisplay;\n};\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst isUrl = (text) => {\n    return text?.match(/https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)/gi);\n};\n\nconst getBuffer = async (url, options = {}) => {\n    try {\n        const { data } = await axios.get(url, {\n            responseType: 'arraybuffer',\n            httpsAgent: unsafeAgent,\n            headers: {\n                'DNT': 1,\n                'Upgrade-Insecure-Request': 1,\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            ...options\n        });\n        return data;\n    } catch (e) {\n        console.error('getBuffer error:', e.message);\n        return null;\n    }\n};\n\nconst fetchJson = async (url, options = {}) => {\n    try {\n        const { data } = await axios.get(url, {\n            httpsAgent: unsafeAgent,\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            ...options\n        });\n        return data;\n    } catch (e) {\n        console.error('fetchJson error:', e.message);\n        return null;\n    }\n};\n\nconst postJson = async (url, body = {}, options = {}) => {\n    try {\n        const { data } = await axios.post(url, body, {\n            httpsAgent: unsafeAgent,\n            headers: {\n                'Content-Type': 'application/json',\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            ...options\n        });\n        return data;\n    } catch (e) {\n        console.error('postJson error:', e.message);\n        return null;\n    }\n};\n\nconst clockString = (ms) => {\n    const h = isNaN(ms) ? '--' : Math.floor(ms / 3600000);\n    const m = isNaN(ms) ? '--' : Math.floor(ms / 60000) % 60;\n    const s = isNaN(ms) ? '--' : Math.floor(ms / 1000) % 60;\n    return [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');\n};\n\nconst formatDate = (n, locale = 'id') => {\n    const d = new Date(n);\n    return d.toLocaleDateString(locale, {\n        weekday: 'long',\n        day: 'numeric',\n        month: 'long',\n        year: 'numeric',\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric'\n    });\n};\n\nconst getTime = (format, date) => {\n    if (date) {\n        return moment(date).locale('id').format(format);\n    }\n    return moment.tz('Asia/Jakarta').locale('id').format(format);\n};\n\nconst getGreeting = () => {\n    const hour = moment.tz('Asia/Jakarta').format('HH');\n    if (hour < 5) return 'Selamat Malam üåÉ';\n    if (hour < 11) return 'Selamat Pagi üåÖ';\n    if (hour < 15) return 'Selamat Siang ‚òÄÔ∏è';\n    if (hour < 18) return 'Selamat Sore üåá';\n    return 'Selamat Malam üåô';\n};\n\nconst bytesToSize = (bytes, decimals = 2) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n};\n\nconst getSizeMedia = async (path) => {\n    if (typeof path === 'string' && /^https?:\\/\\//.test(path)) {\n        try {\n            const res = await axios.head(path, { httpsAgent: unsafeAgent });\n            const length = parseInt(res.headers['content-length']);\n            return !isNaN(length) ? bytesToSize(length) : '0 Bytes';\n        } catch (e) {\n            return '0 Bytes';\n        }\n    } else if (Buffer.isBuffer(path)) {\n        return bytesToSize(Buffer.byteLength(path));\n    }\n    return '0 Bytes';\n};\n\nconst parseMention = (text = '') => {\n    return [...text.matchAll(/@([0-9]{5,16}|0)/g)].map(v => v[1] + '@s.whatsapp.net');\n};\n\nconst getGroupAdmins = (participants) => {\n    const admins = [];\n    for (const p of participants) {\n        if (p.admin === 'superadmin' || p.admin === 'admin') {\n            admins.push(p.id);\n        }\n    }\n    return admins;\n};\n\nconst pickRandom = (list) => list[Math.floor(list.length * Math.random())];\n\nconst generateToken = (length = 8) => {\n    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let token = '';\n    for (let i = 0; i < length; i++) {\n        token += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return token;\n};\n\nconst getRandom = (ext = '') => {\n    return `${Math.floor(Math.random() * 100000)}${ext}`;\n};\n\nconst limitText = (text, limit) => {\n    if (text.length <= limit) return text;\n    return text.substring(0, limit) + '...';\n};\n\nconst isEmoji = (str) => {\n    try {\n        const emojiRegex = /[\\p{Emoji}]/u;\n        return emojiRegex.test(str);\n    } catch {\n        return false;\n    }\n};\n\nconst formatNumber = (num) => {\n    return num.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, '.');\n};\n\nconst getFileType = async (buffer) => {\n    try {\n        const type = await FileType.fromBuffer(buffer);\n        return type ? type.mime : 'application/octet-stream';\n    } catch (e) {\n        return 'application/octet-stream';\n    }\n};\n\nconst writeFile = async (filePath, data) => {\n    try {\n        await fs.ensureDir(path.dirname(filePath));\n        await fs.writeFile(filePath, data);\n        return true;\n    } catch (e) {\n        console.error('writeFile error:', e.message);\n        return false;\n    }\n};\n\nconst readFile = async (filePath) => {\n    try {\n        return await fs.readFile(filePath);\n    } catch (e) {\n        console.error('readFile error:', e.message);\n        return null;\n    }\n};\n\nconst deleteFile = async (filePath) => {\n    try {\n        await fs.unlink(filePath);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\nconst hashString = (str) => {\n    return crypto.createHash('sha256').update(str).digest('hex');\n};\n\nconst cleanTemp = async () => {\n    const tempDir = path.join(process.cwd(), 'src', 'temp');\n    try {\n        const files = await fs.readdir(tempDir);\n        for (const file of files) {\n            if (file !== '.gitkeep') {\n                await fs.unlink(path.join(tempDir, file));\n            }\n        }\n        console.log('‚úÖ Temp folder cleaned');\n    } catch (e) {\n        console.error('cleanTemp error:', e.message);\n    }\n};\n\nconst delay = (ms) => new Promise(r => setTimeout(r, ms));\n\nconst formatMoney = (money) => {\n    return new Intl.NumberFormat('id-ID', {\n        style: 'currency',\n        currency: 'IDR',\n        minimumFractionDigits: 0\n    }).format(money);\n};\n\nmodule.exports = {\n    runtime,\n    sleep,\n    delay,\n    isUrl,\n    getBuffer,\n    fetchJson,\n    postJson,\n    clockString,\n    formatDate,\n    getTime,\n    getGreeting,\n    bytesToSize,\n    getSizeMedia,\n    parseMention,\n    getGroupAdmins,\n    pickRandom,\n    generateToken,\n    getRandom,\n    limitText,\n    isEmoji,\n    formatNumber,\n    formatMoney,\n    getFileType,\n    writeFile,\n    readFile,\n    deleteFile,\n    hashString,\n    cleanTemp\n};","path":null,"size_bytes":8253,"size_tokens":null},"ciel/ecosystem.config.js":{"content":"module.exports = {\n  apps: [\n    {\n      name: 'ciel-bot',\n      script: 'src/index.js',\n      cwd: __dirname,\n      instances: 1,\n      autorestart: true,\n      watch: false,\n      max_memory_restart: '1G',\n      env: {\n        NODE_ENV: 'production',\n        PORT: 5000\n      },\n      env_development: {\n        NODE_ENV: 'development',\n        PORT: 5000\n      },\n      error_file: 'logs/error.log',\n      out_file: 'logs/output.log',\n      log_file: 'logs/combined.log',\n      time: true,\n      merge_logs: true,\n      log_date_format: 'YYYY-MM-DD HH:mm:ss Z'\n    }\n  ]\n};\n","path":null,"size_bytes":577,"size_tokens":null},"source-1/src/antispam.js":{"content":"const usedCommandRecently = new Set()\r\n\r\nconst isFiltered = (from) => !!usedCommandRecently.has(from)\r\n\r\nconst addFilter = (from) => {\r\n\tusedCommandRecently.add(from)\r\n\tsetTimeout(() => usedCommandRecently.delete(from), 5000)\r\n}\r\n\r\nmodule.exports = {\r\n\tantiSpam: {\r\n\t\tisFiltered,\r\n\t\taddFilter\r\n\t}\r\n}","path":null,"size_bytes":299,"size_tokens":null},"source-1/install.sh":{"content":"#!/usr/bin/bash\r\n\r\npkg install git nodejs ffmpeg imagemagick yarn\r\nyarn install\r\nnpm start\r\n\r\necho \"Installation complete. To start the script, run: npm start\"\r\n","path":null,"size_bytes":161,"size_tokens":null}},"version":2}